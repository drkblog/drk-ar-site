var sidila;(()=>{var __webpack_modules__={498:(__unused_webpack_module,exports)=>{eval("/**\n * This file was generated from src\\grammar\\sidila.peg\n * See https://canopy.jcoglan.com/ for documentation\n */\n\n(function () {\n  'use strict';\n\n  function TreeNode (text, offset, elements) {\n    this.text = text;\n    this.offset = offset;\n    this.elements = elements;\n  }\n\n  TreeNode.prototype.forEach = function (block, context) {\n    for (var el = this.elements, i = 0, n = el.length; i < n; i++) {\n      block.call(context, el[i], i, el);\n    }\n  };\n\n  if (typeof Symbol !== 'undefined' && Symbol.iterator) {\n    TreeNode.prototype[Symbol.iterator] = function () {\n      return this.elements[Symbol.iterator]();\n    };\n  }\n\n  var TreeNode1 = function (text, offset, elements) {\n    TreeNode.apply(this, arguments);\n    this['condition'] = elements[1];\n    this['body'] = elements[2];\n  };\n  inherit(TreeNode1, TreeNode);\n\n  var TreeNode2 = function (text, offset, elements) {\n    TreeNode.apply(this, arguments);\n    this['condition'] = elements[1];\n    this['body'] = elements[2];\n  };\n  inherit(TreeNode2, TreeNode);\n\n  var TreeNode3 = function (text, offset, elements) {\n    TreeNode.apply(this, arguments);\n    this['body'] = elements[1];\n  };\n  inherit(TreeNode3, TreeNode);\n\n  var TreeNode4 = function (text, offset, elements) {\n    TreeNode.apply(this, arguments);\n    this['not'] = elements[0];\n  };\n  inherit(TreeNode4, TreeNode);\n\n  var TreeNode5 = function (text, offset, elements) {\n    TreeNode.apply(this, arguments);\n    this['not'] = elements[0];\n    this['sprite'] = elements[2];\n    this['look_up_direction'] = elements[3];\n  };\n  inherit(TreeNode5, TreeNode);\n\n  var TreeNode6 = function (text, offset, elements) {\n    TreeNode.apply(this, arguments);\n    this['direction'] = elements[1];\n  };\n  inherit(TreeNode6, TreeNode);\n\n  var FAILURE = {};\n\n  var Grammar = {\n    _read_body () {\n      var address0 = FAILURE, index0 = this._offset;\n      this._cache._body = this._cache._body || {};\n      var cached = this._cache._body[index0];\n      if (cached) {\n        this._offset = cached[1];\n        return cached[0];\n      }\n      var index1 = this._offset, elements0 = [], address1 = null;\n      while (true) {\n        var index2 = this._offset, elements1 = new Array(1);\n        var address2 = FAILURE;\n        address2 = this._read_ws();\n        if (address2 !== FAILURE) {\n          var address3 = FAILURE;\n          var index3 = this._offset;\n          address3 = this._read_turn();\n          if (address3 === FAILURE) {\n            this._offset = index3;\n            address3 = this._read_move();\n            if (address3 === FAILURE) {\n              this._offset = index3;\n              address3 = this._read_back();\n              if (address3 === FAILURE) {\n                this._offset = index3;\n                address3 = this._read_shoot();\n                if (address3 === FAILURE) {\n                  this._offset = index3;\n                  address3 = this._read_branch();\n                  if (address3 === FAILURE) {\n                    this._offset = index3;\n                    address3 = this._read_loop();\n                    if (address3 === FAILURE) {\n                      this._offset = index3;\n                    }\n                  }\n                }\n              }\n            }\n          }\n          if (address3 !== FAILURE) {\n            elements1[0] = address3;\n            var address4 = FAILURE;\n            address4 = this._read_ws();\n            if (address4 !== FAILURE) {\n              var address5 = FAILURE;\n              address5 = this._read_nl();\n              if (address5 !== FAILURE) {\n              } else {\n                elements1 = null;\n                this._offset = index2;\n              }\n            } else {\n              elements1 = null;\n              this._offset = index2;\n            }\n          } else {\n            elements1 = null;\n            this._offset = index2;\n          }\n        } else {\n          elements1 = null;\n          this._offset = index2;\n        }\n        if (elements1 === null) {\n          address1 = FAILURE;\n        } else {\n          address1 = new TreeNode(this._input.substring(index2, this._offset), index2, elements1);\n          this._offset = this._offset;\n        }\n        if (address1 !== FAILURE) {\n          elements0.push(address1);\n        } else {\n          break;\n        }\n      }\n      if (elements0.length >= 0) {\n        address0 = new TreeNode(this._input.substring(index1, this._offset), index1, elements0);\n        this._offset = this._offset;\n      } else {\n        address0 = FAILURE;\n      }\n      this._cache._body[index0] = [address0, this._offset];\n      return address0;\n    },\n\n    _read_loop () {\n      var address0 = FAILURE, index0 = this._offset;\n      this._cache._loop = this._cache._loop || {};\n      var cached = this._cache._loop[index0];\n      if (cached) {\n        this._offset = cached[1];\n        return cached[0];\n      }\n      var index1 = this._offset, elements0 = new Array(3);\n      var address1 = FAILURE;\n      var chunk0 = null, max0 = this._offset + 8;\n      if (max0 <= this._inputSize) {\n        chunk0 = this._input.substring(this._offset, max0);\n      }\n      if (chunk0 === 'mientras') {\n        address1 = new TreeNode(this._input.substring(this._offset, this._offset + 8), this._offset, []);\n        this._offset = this._offset + 8;\n      } else {\n        address1 = FAILURE;\n        if (this._offset > this._failure) {\n          this._failure = this._offset;\n          this._expected = [];\n        }\n        if (this._offset === this._failure) {\n          this._expected.push(['SiDiLa::loop', '\\'mientras\\'']);\n        }\n      }\n      if (address1 !== FAILURE) {\n        elements0[0] = address1;\n        var address2 = FAILURE;\n        address2 = this._read_ws();\n        if (address2 !== FAILURE) {\n          var address3 = FAILURE;\n          address3 = this._read_condition();\n          if (address3 !== FAILURE) {\n            elements0[1] = address3;\n            var address4 = FAILURE;\n            address4 = this._read_ws();\n            if (address4 !== FAILURE) {\n              var address5 = FAILURE;\n              var chunk1 = null, max1 = this._offset + 1;\n              if (max1 <= this._inputSize) {\n                chunk1 = this._input.substring(this._offset, max1);\n              }\n              if (chunk1 === '(') {\n                address5 = new TreeNode(this._input.substring(this._offset, this._offset + 1), this._offset, []);\n                this._offset = this._offset + 1;\n              } else {\n                address5 = FAILURE;\n                if (this._offset > this._failure) {\n                  this._failure = this._offset;\n                  this._expected = [];\n                }\n                if (this._offset === this._failure) {\n                  this._expected.push(['SiDiLa::loop', '\\'(\\'']);\n                }\n              }\n              if (address5 !== FAILURE) {\n                var address6 = FAILURE;\n                address6 = this._read_nl();\n                if (address6 !== FAILURE) {\n                  var address7 = FAILURE;\n                  address7 = this._read_body();\n                  if (address7 !== FAILURE) {\n                    elements0[2] = address7;\n                    var address8 = FAILURE;\n                    address8 = this._read_nl();\n                    if (address8 !== FAILURE) {\n                      var address9 = FAILURE;\n                      address9 = this._read_ws();\n                      if (address9 !== FAILURE) {\n                        var address10 = FAILURE;\n                        var chunk2 = null, max2 = this._offset + 1;\n                        if (max2 <= this._inputSize) {\n                          chunk2 = this._input.substring(this._offset, max2);\n                        }\n                        if (chunk2 === ')') {\n                          address10 = new TreeNode(this._input.substring(this._offset, this._offset + 1), this._offset, []);\n                          this._offset = this._offset + 1;\n                        } else {\n                          address10 = FAILURE;\n                          if (this._offset > this._failure) {\n                            this._failure = this._offset;\n                            this._expected = [];\n                          }\n                          if (this._offset === this._failure) {\n                            this._expected.push(['SiDiLa::loop', '\\')\\'']);\n                          }\n                        }\n                        if (address10 !== FAILURE) {\n                        } else {\n                          elements0 = null;\n                          this._offset = index1;\n                        }\n                      } else {\n                        elements0 = null;\n                        this._offset = index1;\n                      }\n                    } else {\n                      elements0 = null;\n                      this._offset = index1;\n                    }\n                  } else {\n                    elements0 = null;\n                    this._offset = index1;\n                  }\n                } else {\n                  elements0 = null;\n                  this._offset = index1;\n                }\n              } else {\n                elements0 = null;\n                this._offset = index1;\n              }\n            } else {\n              elements0 = null;\n              this._offset = index1;\n            }\n          } else {\n            elements0 = null;\n            this._offset = index1;\n          }\n        } else {\n          elements0 = null;\n          this._offset = index1;\n        }\n      } else {\n        elements0 = null;\n        this._offset = index1;\n      }\n      if (elements0 === null) {\n        address0 = FAILURE;\n      } else {\n        address0 = this._actions.makeLoop(this._input, index1, this._offset, elements0);\n        this._offset = this._offset;\n      }\n      this._cache._loop[index0] = [address0, this._offset];\n      return address0;\n    },\n\n    _read_branch () {\n      var address0 = FAILURE, index0 = this._offset;\n      this._cache._branch = this._cache._branch || {};\n      var cached = this._cache._branch[index0];\n      if (cached) {\n        this._offset = cached[1];\n        return cached[0];\n      }\n      var index1 = this._offset, elements0 = new Array(4);\n      var address1 = FAILURE;\n      var chunk0 = null, max0 = this._offset + 2;\n      if (max0 <= this._inputSize) {\n        chunk0 = this._input.substring(this._offset, max0);\n      }\n      if (chunk0 === 'si') {\n        address1 = new TreeNode(this._input.substring(this._offset, this._offset + 2), this._offset, []);\n        this._offset = this._offset + 2;\n      } else {\n        address1 = FAILURE;\n        if (this._offset > this._failure) {\n          this._failure = this._offset;\n          this._expected = [];\n        }\n        if (this._offset === this._failure) {\n          this._expected.push(['SiDiLa::branch', '\\'si\\'']);\n        }\n      }\n      if (address1 !== FAILURE) {\n        elements0[0] = address1;\n        var address2 = FAILURE;\n        address2 = this._read_ws();\n        if (address2 !== FAILURE) {\n          var address3 = FAILURE;\n          address3 = this._read_condition();\n          if (address3 !== FAILURE) {\n            elements0[1] = address3;\n            var address4 = FAILURE;\n            address4 = this._read_ws();\n            if (address4 !== FAILURE) {\n              var address5 = FAILURE;\n              var chunk1 = null, max1 = this._offset + 1;\n              if (max1 <= this._inputSize) {\n                chunk1 = this._input.substring(this._offset, max1);\n              }\n              if (chunk1 === '(') {\n                address5 = new TreeNode(this._input.substring(this._offset, this._offset + 1), this._offset, []);\n                this._offset = this._offset + 1;\n              } else {\n                address5 = FAILURE;\n                if (this._offset > this._failure) {\n                  this._failure = this._offset;\n                  this._expected = [];\n                }\n                if (this._offset === this._failure) {\n                  this._expected.push(['SiDiLa::branch', '\\'(\\'']);\n                }\n              }\n              if (address5 !== FAILURE) {\n                var address6 = FAILURE;\n                address6 = this._read_nl();\n                if (address6 !== FAILURE) {\n                  var address7 = FAILURE;\n                  address7 = this._read_body();\n                  if (address7 !== FAILURE) {\n                    elements0[2] = address7;\n                    var address8 = FAILURE;\n                    address8 = this._read_nl();\n                    if (address8 !== FAILURE) {\n                      var address9 = FAILURE;\n                      address9 = this._read_ws();\n                      if (address9 !== FAILURE) {\n                        var address10 = FAILURE;\n                        var chunk2 = null, max2 = this._offset + 1;\n                        if (max2 <= this._inputSize) {\n                          chunk2 = this._input.substring(this._offset, max2);\n                        }\n                        if (chunk2 === ')') {\n                          address10 = new TreeNode(this._input.substring(this._offset, this._offset + 1), this._offset, []);\n                          this._offset = this._offset + 1;\n                        } else {\n                          address10 = FAILURE;\n                          if (this._offset > this._failure) {\n                            this._failure = this._offset;\n                            this._expected = [];\n                          }\n                          if (this._offset === this._failure) {\n                            this._expected.push(['SiDiLa::branch', '\\')\\'']);\n                          }\n                        }\n                        if (address10 !== FAILURE) {\n                          var address11 = FAILURE;\n                          var index2 = this._offset;\n                          var index3 = this._offset, elements1 = new Array(2);\n                          var address12 = FAILURE;\n                          address12 = this._read_ws();\n                          if (address12 !== FAILURE) {\n                            var address13 = FAILURE;\n                            var chunk3 = null, max3 = this._offset + 5;\n                            if (max3 <= this._inputSize) {\n                              chunk3 = this._input.substring(this._offset, max3);\n                            }\n                            if (chunk3 === 'si no') {\n                              address13 = new TreeNode(this._input.substring(this._offset, this._offset + 5), this._offset, []);\n                              this._offset = this._offset + 5;\n                            } else {\n                              address13 = FAILURE;\n                              if (this._offset > this._failure) {\n                                this._failure = this._offset;\n                                this._expected = [];\n                              }\n                              if (this._offset === this._failure) {\n                                this._expected.push(['SiDiLa::branch', '\\'si no\\'']);\n                              }\n                            }\n                            if (address13 !== FAILURE) {\n                              elements1[0] = address13;\n                              var address14 = FAILURE;\n                              address14 = this._read_ws();\n                              if (address14 !== FAILURE) {\n                                var address15 = FAILURE;\n                                var chunk4 = null, max4 = this._offset + 1;\n                                if (max4 <= this._inputSize) {\n                                  chunk4 = this._input.substring(this._offset, max4);\n                                }\n                                if (chunk4 === '(') {\n                                  address15 = new TreeNode(this._input.substring(this._offset, this._offset + 1), this._offset, []);\n                                  this._offset = this._offset + 1;\n                                } else {\n                                  address15 = FAILURE;\n                                  if (this._offset > this._failure) {\n                                    this._failure = this._offset;\n                                    this._expected = [];\n                                  }\n                                  if (this._offset === this._failure) {\n                                    this._expected.push(['SiDiLa::branch', '\\'(\\'']);\n                                  }\n                                }\n                                if (address15 !== FAILURE) {\n                                  var address16 = FAILURE;\n                                  address16 = this._read_nl();\n                                  if (address16 !== FAILURE) {\n                                    var address17 = FAILURE;\n                                    address17 = this._read_body();\n                                    if (address17 !== FAILURE) {\n                                      elements1[1] = address17;\n                                      var address18 = FAILURE;\n                                      address18 = this._read_nl();\n                                      if (address18 !== FAILURE) {\n                                        var address19 = FAILURE;\n                                        address19 = this._read_ws();\n                                        if (address19 !== FAILURE) {\n                                          var address20 = FAILURE;\n                                          var chunk5 = null, max5 = this._offset + 1;\n                                          if (max5 <= this._inputSize) {\n                                            chunk5 = this._input.substring(this._offset, max5);\n                                          }\n                                          if (chunk5 === ')') {\n                                            address20 = new TreeNode(this._input.substring(this._offset, this._offset + 1), this._offset, []);\n                                            this._offset = this._offset + 1;\n                                          } else {\n                                            address20 = FAILURE;\n                                            if (this._offset > this._failure) {\n                                              this._failure = this._offset;\n                                              this._expected = [];\n                                            }\n                                            if (this._offset === this._failure) {\n                                              this._expected.push(['SiDiLa::branch', '\\')\\'']);\n                                            }\n                                          }\n                                          if (address20 !== FAILURE) {\n                                          } else {\n                                            elements1 = null;\n                                            this._offset = index3;\n                                          }\n                                        } else {\n                                          elements1 = null;\n                                          this._offset = index3;\n                                        }\n                                      } else {\n                                        elements1 = null;\n                                        this._offset = index3;\n                                      }\n                                    } else {\n                                      elements1 = null;\n                                      this._offset = index3;\n                                    }\n                                  } else {\n                                    elements1 = null;\n                                    this._offset = index3;\n                                  }\n                                } else {\n                                  elements1 = null;\n                                  this._offset = index3;\n                                }\n                              } else {\n                                elements1 = null;\n                                this._offset = index3;\n                              }\n                            } else {\n                              elements1 = null;\n                              this._offset = index3;\n                            }\n                          } else {\n                            elements1 = null;\n                            this._offset = index3;\n                          }\n                          if (elements1 === null) {\n                            address11 = FAILURE;\n                          } else {\n                            address11 = new TreeNode3(this._input.substring(index3, this._offset), index3, elements1);\n                            this._offset = this._offset;\n                          }\n                          if (address11 === FAILURE) {\n                            address11 = new TreeNode(this._input.substring(index2, index2), index2, []);\n                            this._offset = index2;\n                          }\n                          if (address11 !== FAILURE) {\n                            elements0[3] = address11;\n                          } else {\n                            elements0 = null;\n                            this._offset = index1;\n                          }\n                        } else {\n                          elements0 = null;\n                          this._offset = index1;\n                        }\n                      } else {\n                        elements0 = null;\n                        this._offset = index1;\n                      }\n                    } else {\n                      elements0 = null;\n                      this._offset = index1;\n                    }\n                  } else {\n                    elements0 = null;\n                    this._offset = index1;\n                  }\n                } else {\n                  elements0 = null;\n                  this._offset = index1;\n                }\n              } else {\n                elements0 = null;\n                this._offset = index1;\n              }\n            } else {\n              elements0 = null;\n              this._offset = index1;\n            }\n          } else {\n            elements0 = null;\n            this._offset = index1;\n          }\n        } else {\n          elements0 = null;\n          this._offset = index1;\n        }\n      } else {\n        elements0 = null;\n        this._offset = index1;\n      }\n      if (elements0 === null) {\n        address0 = FAILURE;\n      } else {\n        address0 = this._actions.makeBranch(this._input, index1, this._offset, elements0);\n        this._offset = this._offset;\n      }\n      this._cache._branch[index0] = [address0, this._offset];\n      return address0;\n    },\n\n    _read_condition () {\n      var address0 = FAILURE, index0 = this._offset;\n      this._cache._condition = this._cache._condition || {};\n      var cached = this._cache._condition[index0];\n      if (cached) {\n        this._offset = cached[1];\n        return cached[0];\n      }\n      var index1 = this._offset;\n      address0 = this._read_ahead_condition();\n      if (address0 === FAILURE) {\n        this._offset = index1;\n        address0 = this._read_in_game_condition();\n        if (address0 === FAILURE) {\n          this._offset = index1;\n        }\n      }\n      this._cache._condition[index0] = [address0, this._offset];\n      return address0;\n    },\n\n    _read_in_game_condition () {\n      var address0 = FAILURE, index0 = this._offset;\n      this._cache._in_game_condition = this._cache._in_game_condition || {};\n      var cached = this._cache._in_game_condition[index0];\n      if (cached) {\n        this._offset = cached[1];\n        return cached[0];\n      }\n      var index1 = this._offset, elements0 = new Array(2);\n      var address1 = FAILURE;\n      address1 = this._read_not();\n      if (address1 !== FAILURE) {\n        elements0[0] = address1;\n        var address2 = FAILURE;\n        address2 = this._read_ws();\n        if (address2 !== FAILURE) {\n          var address3 = FAILURE;\n          var chunk0 = null, max0 = this._offset + 11;\n          if (max0 <= this._inputSize) {\n            chunk0 = this._input.substring(this._offset, max0);\n          }\n          if (chunk0 === 'haya salido') {\n            address3 = new TreeNode(this._input.substring(this._offset, this._offset + 11), this._offset, []);\n            this._offset = this._offset + 11;\n          } else {\n            address3 = FAILURE;\n            if (this._offset > this._failure) {\n              this._failure = this._offset;\n              this._expected = [];\n            }\n            if (this._offset === this._failure) {\n              this._expected.push(['SiDiLa::in_game_condition', '\\'haya salido\\'']);\n            }\n          }\n          if (address3 !== FAILURE) {\n            elements0[1] = address3;\n          } else {\n            elements0 = null;\n            this._offset = index1;\n          }\n        } else {\n          elements0 = null;\n          this._offset = index1;\n        }\n      } else {\n        elements0 = null;\n        this._offset = index1;\n      }\n      if (elements0 === null) {\n        address0 = FAILURE;\n      } else {\n        address0 = this._actions.makeInGameCondition(this._input, index1, this._offset, elements0);\n        this._offset = this._offset;\n      }\n      this._cache._in_game_condition[index0] = [address0, this._offset];\n      return address0;\n    },\n\n    _read_ahead_condition () {\n      var address0 = FAILURE, index0 = this._offset;\n      this._cache._ahead_condition = this._cache._ahead_condition || {};\n      var cached = this._cache._ahead_condition[index0];\n      if (cached) {\n        this._offset = cached[1];\n        return cached[0];\n      }\n      var index1 = this._offset, elements0 = new Array(4);\n      var address1 = FAILURE;\n      address1 = this._read_not();\n      if (address1 !== FAILURE) {\n        elements0[0] = address1;\n        var address2 = FAILURE;\n        address2 = this._read_ws();\n        if (address2 !== FAILURE) {\n          var address3 = FAILURE;\n          var chunk0 = null, max0 = this._offset + 3;\n          if (max0 <= this._inputSize) {\n            chunk0 = this._input.substring(this._offset, max0);\n          }\n          if (chunk0 === 'hay') {\n            address3 = new TreeNode(this._input.substring(this._offset, this._offset + 3), this._offset, []);\n            this._offset = this._offset + 3;\n          } else {\n            address3 = FAILURE;\n            if (this._offset > this._failure) {\n              this._failure = this._offset;\n              this._expected = [];\n            }\n            if (this._offset === this._failure) {\n              this._expected.push(['SiDiLa::ahead_condition', '\\'hay\\'']);\n            }\n          }\n          if (address3 !== FAILURE) {\n            elements0[1] = address3;\n            var address4 = FAILURE;\n            address4 = this._read_ws();\n            if (address4 !== FAILURE) {\n              var address5 = FAILURE;\n              address5 = this._read_sprite();\n              if (address5 !== FAILURE) {\n                elements0[2] = address5;\n                var address6 = FAILURE;\n                address6 = this._read_ws();\n                if (address6 !== FAILURE) {\n                  var address7 = FAILURE;\n                  address7 = this._read_look_up_direction();\n                  if (address7 !== FAILURE) {\n                    elements0[3] = address7;\n                  } else {\n                    elements0 = null;\n                    this._offset = index1;\n                  }\n                } else {\n                  elements0 = null;\n                  this._offset = index1;\n                }\n              } else {\n                elements0 = null;\n                this._offset = index1;\n              }\n            } else {\n              elements0 = null;\n              this._offset = index1;\n            }\n          } else {\n            elements0 = null;\n            this._offset = index1;\n          }\n        } else {\n          elements0 = null;\n          this._offset = index1;\n        }\n      } else {\n        elements0 = null;\n        this._offset = index1;\n      }\n      if (elements0 === null) {\n        address0 = FAILURE;\n      } else {\n        address0 = this._actions.makeLookAheadCondition(this._input, index1, this._offset, elements0);\n        this._offset = this._offset;\n      }\n      this._cache._ahead_condition[index0] = [address0, this._offset];\n      return address0;\n    },\n\n    _read_not () {\n      var address0 = FAILURE, index0 = this._offset;\n      this._cache._not = this._cache._not || {};\n      var cached = this._cache._not[index0];\n      if (cached) {\n        this._offset = cached[1];\n        return cached[0];\n      }\n      var index1 = this._offset;\n      var chunk0 = null, max0 = this._offset + 2;\n      if (max0 <= this._inputSize) {\n        chunk0 = this._input.substring(this._offset, max0);\n      }\n      if (chunk0 === 'no') {\n        address0 = new TreeNode(this._input.substring(this._offset, this._offset + 2), this._offset, []);\n        this._offset = this._offset + 2;\n      } else {\n        address0 = FAILURE;\n        if (this._offset > this._failure) {\n          this._failure = this._offset;\n          this._expected = [];\n        }\n        if (this._offset === this._failure) {\n          this._expected.push(['SiDiLa::not', '\\'no\\'']);\n        }\n      }\n      if (address0 === FAILURE) {\n        address0 = new TreeNode(this._input.substring(index1, index1), index1, []);\n        this._offset = index1;\n      }\n      this._cache._not[index0] = [address0, this._offset];\n      return address0;\n    },\n\n    _read_sprite () {\n      var address0 = FAILURE, index0 = this._offset;\n      this._cache._sprite = this._cache._sprite || {};\n      var cached = this._cache._sprite[index0];\n      if (cached) {\n        this._offset = cached[1];\n        return cached[0];\n      }\n      var index1 = this._offset;\n      var chunk0 = null, max0 = this._offset + 5;\n      if (max0 <= this._inputSize) {\n        chunk0 = this._input.substring(this._offset, max0);\n      }\n      if (chunk0 === 'pared') {\n        address0 = new TreeNode(this._input.substring(this._offset, this._offset + 5), this._offset, []);\n        this._offset = this._offset + 5;\n      } else {\n        address0 = FAILURE;\n        if (this._offset > this._failure) {\n          this._failure = this._offset;\n          this._expected = [];\n        }\n        if (this._offset === this._failure) {\n          this._expected.push(['SiDiLa::sprite', '\\'pared\\'']);\n        }\n      }\n      if (address0 === FAILURE) {\n        this._offset = index1;\n        var chunk1 = null, max1 = this._offset + 4;\n        if (max1 <= this._inputSize) {\n          chunk1 = this._input.substring(this._offset, max1);\n        }\n        if (chunk1 === 'algo') {\n          address0 = new TreeNode(this._input.substring(this._offset, this._offset + 4), this._offset, []);\n          this._offset = this._offset + 4;\n        } else {\n          address0 = FAILURE;\n          if (this._offset > this._failure) {\n            this._failure = this._offset;\n            this._expected = [];\n          }\n          if (this._offset === this._failure) {\n            this._expected.push(['SiDiLa::sprite', '\\'algo\\'']);\n          }\n        }\n        if (address0 === FAILURE) {\n          this._offset = index1;\n          var chunk2 = null, max2 = this._offset + 6;\n          if (max2 <= this._inputSize) {\n            chunk2 = this._input.substring(this._offset, max2);\n          }\n          if (chunk2 === 'zombie') {\n            address0 = new TreeNode(this._input.substring(this._offset, this._offset + 6), this._offset, []);\n            this._offset = this._offset + 6;\n          } else {\n            address0 = FAILURE;\n            if (this._offset > this._failure) {\n              this._failure = this._offset;\n              this._expected = [];\n            }\n            if (this._offset === this._failure) {\n              this._expected.push(['SiDiLa::sprite', '\\'zombie\\'']);\n            }\n          }\n          if (address0 === FAILURE) {\n            this._offset = index1;\n            var chunk3 = null, max3 = this._offset + 7;\n            if (max3 <= this._inputSize) {\n              chunk3 = this._input.substring(this._offset, max3);\n            }\n            if (chunk3 === 'espacio') {\n              address0 = new TreeNode(this._input.substring(this._offset, this._offset + 7), this._offset, []);\n              this._offset = this._offset + 7;\n            } else {\n              address0 = FAILURE;\n              if (this._offset > this._failure) {\n                this._failure = this._offset;\n                this._expected = [];\n              }\n              if (this._offset === this._failure) {\n                this._expected.push(['SiDiLa::sprite', '\\'espacio\\'']);\n              }\n            }\n            if (address0 === FAILURE) {\n              this._offset = index1;\n              var chunk4 = null, max4 = this._offset + 6;\n              if (max4 <= this._inputSize) {\n                chunk4 = this._input.substring(this._offset, max4);\n              }\n              if (chunk4 === 'salida') {\n                address0 = new TreeNode(this._input.substring(this._offset, this._offset + 6), this._offset, []);\n                this._offset = this._offset + 6;\n              } else {\n                address0 = FAILURE;\n                if (this._offset > this._failure) {\n                  this._failure = this._offset;\n                  this._expected = [];\n                }\n                if (this._offset === this._failure) {\n                  this._expected.push(['SiDiLa::sprite', '\\'salida\\'']);\n                }\n              }\n              if (address0 === FAILURE) {\n                this._offset = index1;\n              }\n            }\n          }\n        }\n      }\n      this._cache._sprite[index0] = [address0, this._offset];\n      return address0;\n    },\n\n    _read_look_up_direction () {\n      var address0 = FAILURE, index0 = this._offset;\n      this._cache._look_up_direction = this._cache._look_up_direction || {};\n      var cached = this._cache._look_up_direction[index0];\n      if (cached) {\n        this._offset = cached[1];\n        return cached[0];\n      }\n      var index1 = this._offset;\n      var chunk0 = null, max0 = this._offset + 8;\n      if (max0 <= this._inputSize) {\n        chunk0 = this._input.substring(this._offset, max0);\n      }\n      if (chunk0 === 'adelante') {\n        address0 = new TreeNode(this._input.substring(this._offset, this._offset + 8), this._offset, []);\n        this._offset = this._offset + 8;\n      } else {\n        address0 = FAILURE;\n        if (this._offset > this._failure) {\n          this._failure = this._offset;\n          this._expected = [];\n        }\n        if (this._offset === this._failure) {\n          this._expected.push(['SiDiLa::look_up_direction', '\\'adelante\\'']);\n        }\n      }\n      if (address0 === FAILURE) {\n        this._offset = index1;\n        var chunk1 = null, max1 = this._offset + 14;\n        if (max1 <= this._inputSize) {\n          chunk1 = this._input.substring(this._offset, max1);\n        }\n        if (chunk1 === 'a la izquierda') {\n          address0 = new TreeNode(this._input.substring(this._offset, this._offset + 14), this._offset, []);\n          this._offset = this._offset + 14;\n        } else {\n          address0 = FAILURE;\n          if (this._offset > this._failure) {\n            this._failure = this._offset;\n            this._expected = [];\n          }\n          if (this._offset === this._failure) {\n            this._expected.push(['SiDiLa::look_up_direction', '\\'a la izquierda\\'']);\n          }\n        }\n        if (address0 === FAILURE) {\n          this._offset = index1;\n          var chunk2 = null, max2 = this._offset + 12;\n          if (max2 <= this._inputSize) {\n            chunk2 = this._input.substring(this._offset, max2);\n          }\n          if (chunk2 === 'a la derecha') {\n            address0 = new TreeNode(this._input.substring(this._offset, this._offset + 12), this._offset, []);\n            this._offset = this._offset + 12;\n          } else {\n            address0 = FAILURE;\n            if (this._offset > this._failure) {\n              this._failure = this._offset;\n              this._expected = [];\n            }\n            if (this._offset === this._failure) {\n              this._expected.push(['SiDiLa::look_up_direction', '\\'a la derecha\\'']);\n            }\n          }\n          if (address0 === FAILURE) {\n            this._offset = index1;\n          }\n        }\n      }\n      this._cache._look_up_direction[index0] = [address0, this._offset];\n      return address0;\n    },\n\n    _read_move () {\n      var address0 = FAILURE, index0 = this._offset;\n      this._cache._move = this._cache._move || {};\n      var cached = this._cache._move[index0];\n      if (cached) {\n        this._offset = cached[1];\n        return cached[0];\n      }\n      var chunk0 = null, max0 = this._offset + 7;\n      if (max0 <= this._inputSize) {\n        chunk0 = this._input.substring(this._offset, max0);\n      }\n      if (chunk0 === 'avanzar') {\n        address0 = this._actions.makeMove(this._input, this._offset, this._offset + 7, []);\n        this._offset = this._offset + 7;\n      } else {\n        address0 = FAILURE;\n        if (this._offset > this._failure) {\n          this._failure = this._offset;\n          this._expected = [];\n        }\n        if (this._offset === this._failure) {\n          this._expected.push(['SiDiLa::move', '\\'avanzar\\'']);\n        }\n      }\n      this._cache._move[index0] = [address0, this._offset];\n      return address0;\n    },\n\n    _read_back () {\n      var address0 = FAILURE, index0 = this._offset;\n      this._cache._back = this._cache._back || {};\n      var cached = this._cache._back[index0];\n      if (cached) {\n        this._offset = cached[1];\n        return cached[0];\n      }\n      var chunk0 = null, max0 = this._offset + 10;\n      if (max0 <= this._inputSize) {\n        chunk0 = this._input.substring(this._offset, max0);\n      }\n      if (chunk0 === 'retroceder') {\n        address0 = this._actions.makeBack(this._input, this._offset, this._offset + 10, []);\n        this._offset = this._offset + 10;\n      } else {\n        address0 = FAILURE;\n        if (this._offset > this._failure) {\n          this._failure = this._offset;\n          this._expected = [];\n        }\n        if (this._offset === this._failure) {\n          this._expected.push(['SiDiLa::back', '\\'retroceder\\'']);\n        }\n      }\n      this._cache._back[index0] = [address0, this._offset];\n      return address0;\n    },\n\n    _read_shoot () {\n      var address0 = FAILURE, index0 = this._offset;\n      this._cache._shoot = this._cache._shoot || {};\n      var cached = this._cache._shoot[index0];\n      if (cached) {\n        this._offset = cached[1];\n        return cached[0];\n      }\n      var chunk0 = null, max0 = this._offset + 8;\n      if (max0 <= this._inputSize) {\n        chunk0 = this._input.substring(this._offset, max0);\n      }\n      if (chunk0 === 'disparar') {\n        address0 = this._actions.makeShoot(this._input, this._offset, this._offset + 8, []);\n        this._offset = this._offset + 8;\n      } else {\n        address0 = FAILURE;\n        if (this._offset > this._failure) {\n          this._failure = this._offset;\n          this._expected = [];\n        }\n        if (this._offset === this._failure) {\n          this._expected.push(['SiDiLa::shoot', '\\'disparar\\'']);\n        }\n      }\n      this._cache._shoot[index0] = [address0, this._offset];\n      return address0;\n    },\n\n    _read_turn () {\n      var address0 = FAILURE, index0 = this._offset;\n      this._cache._turn = this._cache._turn || {};\n      var cached = this._cache._turn[index0];\n      if (cached) {\n        this._offset = cached[1];\n        return cached[0];\n      }\n      var index1 = this._offset, elements0 = new Array(2);\n      var address1 = FAILURE;\n      var chunk0 = null, max0 = this._offset + 5;\n      if (max0 <= this._inputSize) {\n        chunk0 = this._input.substring(this._offset, max0);\n      }\n      if (chunk0 === 'girar') {\n        address1 = new TreeNode(this._input.substring(this._offset, this._offset + 5), this._offset, []);\n        this._offset = this._offset + 5;\n      } else {\n        address1 = FAILURE;\n        if (this._offset > this._failure) {\n          this._failure = this._offset;\n          this._expected = [];\n        }\n        if (this._offset === this._failure) {\n          this._expected.push(['SiDiLa::turn', '\\'girar\\'']);\n        }\n      }\n      if (address1 !== FAILURE) {\n        elements0[0] = address1;\n        var address2 = FAILURE;\n        address2 = this._read_ws();\n        if (address2 !== FAILURE) {\n          var address3 = FAILURE;\n          var chunk1 = null, max1 = this._offset + 5;\n          if (max1 <= this._inputSize) {\n            chunk1 = this._input.substring(this._offset, max1);\n          }\n          if (chunk1 === 'hacia') {\n            address3 = new TreeNode(this._input.substring(this._offset, this._offset + 5), this._offset, []);\n            this._offset = this._offset + 5;\n          } else {\n            address3 = FAILURE;\n            if (this._offset > this._failure) {\n              this._failure = this._offset;\n              this._expected = [];\n            }\n            if (this._offset === this._failure) {\n              this._expected.push(['SiDiLa::turn', '\\'hacia\\'']);\n            }\n          }\n          if (address3 !== FAILURE) {\n            var address4 = FAILURE;\n            address4 = this._read_ws();\n            if (address4 !== FAILURE) {\n              var address5 = FAILURE;\n              address5 = this._read_direction();\n              if (address5 !== FAILURE) {\n                elements0[1] = address5;\n              } else {\n                elements0 = null;\n                this._offset = index1;\n              }\n            } else {\n              elements0 = null;\n              this._offset = index1;\n            }\n          } else {\n            elements0 = null;\n            this._offset = index1;\n          }\n        } else {\n          elements0 = null;\n          this._offset = index1;\n        }\n      } else {\n        elements0 = null;\n        this._offset = index1;\n      }\n      if (elements0 === null) {\n        address0 = FAILURE;\n      } else {\n        address0 = this._actions.makeTurn(this._input, index1, this._offset, elements0);\n        this._offset = this._offset;\n      }\n      this._cache._turn[index0] = [address0, this._offset];\n      return address0;\n    },\n\n    _read_direction () {\n      var address0 = FAILURE, index0 = this._offset;\n      this._cache._direction = this._cache._direction || {};\n      var cached = this._cache._direction[index0];\n      if (cached) {\n        this._offset = cached[1];\n        return cached[0];\n      }\n      var index1 = this._offset;\n      var chunk0 = null, max0 = this._offset + 12;\n      if (max0 <= this._inputSize) {\n        chunk0 = this._input.substring(this._offset, max0);\n      }\n      if (chunk0 === 'la izquierda') {\n        address0 = new TreeNode(this._input.substring(this._offset, this._offset + 12), this._offset, []);\n        this._offset = this._offset + 12;\n      } else {\n        address0 = FAILURE;\n        if (this._offset > this._failure) {\n          this._failure = this._offset;\n          this._expected = [];\n        }\n        if (this._offset === this._failure) {\n          this._expected.push(['SiDiLa::direction', '\\'la izquierda\\'']);\n        }\n      }\n      if (address0 === FAILURE) {\n        this._offset = index1;\n        var chunk1 = null, max1 = this._offset + 10;\n        if (max1 <= this._inputSize) {\n          chunk1 = this._input.substring(this._offset, max1);\n        }\n        if (chunk1 === 'la derecha') {\n          address0 = new TreeNode(this._input.substring(this._offset, this._offset + 10), this._offset, []);\n          this._offset = this._offset + 10;\n        } else {\n          address0 = FAILURE;\n          if (this._offset > this._failure) {\n            this._failure = this._offset;\n            this._expected = [];\n          }\n          if (this._offset === this._failure) {\n            this._expected.push(['SiDiLa::direction', '\\'la derecha\\'']);\n          }\n        }\n        if (address0 === FAILURE) {\n          this._offset = index1;\n          var chunk2 = null, max2 = this._offset + 5;\n          if (max2 <= this._inputSize) {\n            chunk2 = this._input.substring(this._offset, max2);\n          }\n          if (chunk2 === 'atras') {\n            address0 = new TreeNode(this._input.substring(this._offset, this._offset + 5), this._offset, []);\n            this._offset = this._offset + 5;\n          } else {\n            address0 = FAILURE;\n            if (this._offset > this._failure) {\n              this._failure = this._offset;\n              this._expected = [];\n            }\n            if (this._offset === this._failure) {\n              this._expected.push(['SiDiLa::direction', '\\'atras\\'']);\n            }\n          }\n          if (address0 === FAILURE) {\n            this._offset = index1;\n          }\n        }\n      }\n      this._cache._direction[index0] = [address0, this._offset];\n      return address0;\n    },\n\n    _read_ws () {\n      var address0 = FAILURE, index0 = this._offset;\n      this._cache._ws = this._cache._ws || {};\n      var cached = this._cache._ws[index0];\n      if (cached) {\n        this._offset = cached[1];\n        return cached[0];\n      }\n      var index1 = this._offset, elements0 = [], address1 = null;\n      while (true) {\n        var index2 = this._offset, elements1 = [], address2 = null;\n        while (true) {\n          var chunk0 = null, max0 = this._offset + 1;\n          if (max0 <= this._inputSize) {\n            chunk0 = this._input.substring(this._offset, max0);\n          }\n          if (chunk0 !== null && /^[ \\t]/.test(chunk0)) {\n            address2 = new TreeNode(this._input.substring(this._offset, this._offset + 1), this._offset, []);\n            this._offset = this._offset + 1;\n          } else {\n            address2 = FAILURE;\n            if (this._offset > this._failure) {\n              this._failure = this._offset;\n              this._expected = [];\n            }\n            if (this._offset === this._failure) {\n              this._expected.push(['SiDiLa::ws', '[ \\\\t]']);\n            }\n          }\n          if (address2 !== FAILURE) {\n            elements1.push(address2);\n          } else {\n            break;\n          }\n        }\n        if (elements1.length >= 1) {\n          address1 = new TreeNode(this._input.substring(index2, this._offset), index2, elements1);\n          this._offset = this._offset;\n        } else {\n          address1 = FAILURE;\n        }\n        if (address1 !== FAILURE) {\n          elements0.push(address1);\n        } else {\n          break;\n        }\n      }\n      if (elements0.length >= 0) {\n        address0 = new TreeNode(this._input.substring(index1, this._offset), index1, elements0);\n        this._offset = this._offset;\n      } else {\n        address0 = FAILURE;\n      }\n      this._cache._ws[index0] = [address0, this._offset];\n      return address0;\n    },\n\n    _read_nl () {\n      var address0 = FAILURE, index0 = this._offset;\n      this._cache._nl = this._cache._nl || {};\n      var cached = this._cache._nl[index0];\n      if (cached) {\n        this._offset = cached[1];\n        return cached[0];\n      }\n      var index1 = this._offset, elements0 = [], address1 = null;\n      while (true) {\n        var index2 = this._offset, elements1 = [], address2 = null;\n        while (true) {\n          var chunk0 = null, max0 = this._offset + 1;\n          if (max0 <= this._inputSize) {\n            chunk0 = this._input.substring(this._offset, max0);\n          }\n          if (chunk0 !== null && /^[\\r\\n]/.test(chunk0)) {\n            address2 = new TreeNode(this._input.substring(this._offset, this._offset + 1), this._offset, []);\n            this._offset = this._offset + 1;\n          } else {\n            address2 = FAILURE;\n            if (this._offset > this._failure) {\n              this._failure = this._offset;\n              this._expected = [];\n            }\n            if (this._offset === this._failure) {\n              this._expected.push(['SiDiLa::nl', '[\\\\r\\\\n]']);\n            }\n          }\n          if (address2 !== FAILURE) {\n            elements1.push(address2);\n          } else {\n            break;\n          }\n        }\n        if (elements1.length >= 1) {\n          address1 = new TreeNode(this._input.substring(index2, this._offset), index2, elements1);\n          this._offset = this._offset;\n        } else {\n          address1 = FAILURE;\n        }\n        if (address1 !== FAILURE) {\n          elements0.push(address1);\n        } else {\n          break;\n        }\n      }\n      if (elements0.length >= 0) {\n        address0 = new TreeNode(this._input.substring(index1, this._offset), index1, elements0);\n        this._offset = this._offset;\n      } else {\n        address0 = FAILURE;\n      }\n      this._cache._nl[index0] = [address0, this._offset];\n      return address0;\n    }\n  };\n\n  var Parser = function(input, actions, types) {\n    this._input = input;\n    this._inputSize = input.length;\n    this._actions = actions;\n    this._types = types;\n    this._offset = 0;\n    this._cache = {};\n    this._failure = 0;\n    this._expected = [];\n  };\n\n  Parser.prototype.parse = function() {\n    var tree = this._read_body();\n    if (tree !== FAILURE && this._offset === this._inputSize) {\n      return tree;\n    }\n    if (this._expected.length === 0) {\n      this._failure = this._offset;\n      this._expected.push(['SiDiLa', '<EOF>']);\n    }\n    this.constructor.lastError = { offset: this._offset, expected: this._expected };\n    throw new SyntaxError(formatError(this._input, this._failure, this._expected));\n  };\n\n  Object.assign(Parser.prototype, Grammar);\n\n\n  function parse(input, options) {\n    options = options || {};\n    var parser = new Parser(input, options.actions, options.types);\n    return parser.parse();\n  }\n\n  function formatError(input, offset, expected) {\n    var lines = input.split(/\\n/g),\n        lineNo = 0,\n        position = 0;\n\n    while (position <= offset) {\n      position += lines[lineNo].length + 1;\n      lineNo += 1;\n    }\n\n    var line = lines[lineNo - 1],\n        message = 'Line ' + lineNo + ': expected one of:\\n\\n';\n\n    for (var i = 0; i < expected.length; i++) {\n      message += '    - ' + expected[i][1] + ' from ' + expected[i][0] + '\\n';\n    }\n    var number = lineNo.toString();\n    while (number.length < 6) number = ' ' + number;\n    message += '\\n' + number + ' | ' + line + '\\n';\n\n    position -= line.length + 10;\n\n    while (position < offset) {\n      message += ' ';\n      position += 1;\n    }\n    return message + '^';\n  }\n\n  function inherit(subclass, parent) {\n    function chain () {};\n    chain.prototype = parent.prototype;\n    subclass.prototype = new chain();\n    subclass.prototype.constructor = subclass;\n  }\n\n\n  var exported = { Grammar: Grammar, Parser: Parser, parse: parse };\n\n  if (true) {\n    Object.assign(exports, exported);\n  } else { var ns; }\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLG1CQUFtQjs7QUFFbkIsTUFBTSxJQUE0RDtBQUNsRTtBQUNBLElBQUksS0FBSyxXQUdOO0FBQ0gsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NpZGlsYS8uL2J1aWxkL3BlZy5qcz8yMGZmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgZnJvbSBzcmNcXGdyYW1tYXJcXHNpZGlsYS5wZWdcbiAqIFNlZSBodHRwczovL2Nhbm9weS5qY29nbGFuLmNvbS8gZm9yIGRvY3VtZW50YXRpb25cbiAqL1xuXG4oZnVuY3Rpb24gKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gVHJlZU5vZGUgKHRleHQsIG9mZnNldCwgZWxlbWVudHMpIHtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgfVxuXG4gIFRyZWVOb2RlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGJsb2NrLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgZWwgPSB0aGlzLmVsZW1lbnRzLCBpID0gMCwgbiA9IGVsLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgYmxvY2suY2FsbChjb250ZXh0LCBlbFtpXSwgaSwgZWwpO1xuICAgIH1cbiAgfTtcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLml0ZXJhdG9yKSB7XG4gICAgVHJlZU5vZGUucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50c1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBUcmVlTm9kZTEgPSBmdW5jdGlvbiAodGV4dCwgb2Zmc2V0LCBlbGVtZW50cykge1xuICAgIFRyZWVOb2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpc1snY29uZGl0aW9uJ10gPSBlbGVtZW50c1sxXTtcbiAgICB0aGlzWydib2R5J10gPSBlbGVtZW50c1syXTtcbiAgfTtcbiAgaW5oZXJpdChUcmVlTm9kZTEsIFRyZWVOb2RlKTtcblxuICB2YXIgVHJlZU5vZGUyID0gZnVuY3Rpb24gKHRleHQsIG9mZnNldCwgZWxlbWVudHMpIHtcbiAgICBUcmVlTm9kZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXNbJ2NvbmRpdGlvbiddID0gZWxlbWVudHNbMV07XG4gICAgdGhpc1snYm9keSddID0gZWxlbWVudHNbMl07XG4gIH07XG4gIGluaGVyaXQoVHJlZU5vZGUyLCBUcmVlTm9kZSk7XG5cbiAgdmFyIFRyZWVOb2RlMyA9IGZ1bmN0aW9uICh0ZXh0LCBvZmZzZXQsIGVsZW1lbnRzKSB7XG4gICAgVHJlZU5vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzWydib2R5J10gPSBlbGVtZW50c1sxXTtcbiAgfTtcbiAgaW5oZXJpdChUcmVlTm9kZTMsIFRyZWVOb2RlKTtcblxuICB2YXIgVHJlZU5vZGU0ID0gZnVuY3Rpb24gKHRleHQsIG9mZnNldCwgZWxlbWVudHMpIHtcbiAgICBUcmVlTm9kZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXNbJ25vdCddID0gZWxlbWVudHNbMF07XG4gIH07XG4gIGluaGVyaXQoVHJlZU5vZGU0LCBUcmVlTm9kZSk7XG5cbiAgdmFyIFRyZWVOb2RlNSA9IGZ1bmN0aW9uICh0ZXh0LCBvZmZzZXQsIGVsZW1lbnRzKSB7XG4gICAgVHJlZU5vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzWydub3QnXSA9IGVsZW1lbnRzWzBdO1xuICAgIHRoaXNbJ3Nwcml0ZSddID0gZWxlbWVudHNbMl07XG4gICAgdGhpc1snbG9va191cF9kaXJlY3Rpb24nXSA9IGVsZW1lbnRzWzNdO1xuICB9O1xuICBpbmhlcml0KFRyZWVOb2RlNSwgVHJlZU5vZGUpO1xuXG4gIHZhciBUcmVlTm9kZTYgPSBmdW5jdGlvbiAodGV4dCwgb2Zmc2V0LCBlbGVtZW50cykge1xuICAgIFRyZWVOb2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpc1snZGlyZWN0aW9uJ10gPSBlbGVtZW50c1sxXTtcbiAgfTtcbiAgaW5oZXJpdChUcmVlTm9kZTYsIFRyZWVOb2RlKTtcblxuICB2YXIgRkFJTFVSRSA9IHt9O1xuXG4gIHZhciBHcmFtbWFyID0ge1xuICAgIF9yZWFkX2JvZHkgKCkge1xuICAgICAgdmFyIGFkZHJlc3MwID0gRkFJTFVSRSwgaW5kZXgwID0gdGhpcy5fb2Zmc2V0O1xuICAgICAgdGhpcy5fY2FjaGUuX2JvZHkgPSB0aGlzLl9jYWNoZS5fYm9keSB8fCB7fTtcbiAgICAgIHZhciBjYWNoZWQgPSB0aGlzLl9jYWNoZS5fYm9keVtpbmRleDBdO1xuICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSBjYWNoZWRbMV07XG4gICAgICAgIHJldHVybiBjYWNoZWRbMF07XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXgxID0gdGhpcy5fb2Zmc2V0LCBlbGVtZW50czAgPSBbXSwgYWRkcmVzczEgPSBudWxsO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGluZGV4MiA9IHRoaXMuX29mZnNldCwgZWxlbWVudHMxID0gbmV3IEFycmF5KDEpO1xuICAgICAgICB2YXIgYWRkcmVzczIgPSBGQUlMVVJFO1xuICAgICAgICBhZGRyZXNzMiA9IHRoaXMuX3JlYWRfd3MoKTtcbiAgICAgICAgaWYgKGFkZHJlc3MyICE9PSBGQUlMVVJFKSB7XG4gICAgICAgICAgdmFyIGFkZHJlc3MzID0gRkFJTFVSRTtcbiAgICAgICAgICB2YXIgaW5kZXgzID0gdGhpcy5fb2Zmc2V0O1xuICAgICAgICAgIGFkZHJlc3MzID0gdGhpcy5fcmVhZF90dXJuKCk7XG4gICAgICAgICAgaWYgKGFkZHJlc3MzID09PSBGQUlMVVJFKSB7XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbmRleDM7XG4gICAgICAgICAgICBhZGRyZXNzMyA9IHRoaXMuX3JlYWRfbW92ZSgpO1xuICAgICAgICAgICAgaWYgKGFkZHJlc3MzID09PSBGQUlMVVJFKSB7XG4gICAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IGluZGV4MztcbiAgICAgICAgICAgICAgYWRkcmVzczMgPSB0aGlzLl9yZWFkX2JhY2soKTtcbiAgICAgICAgICAgICAgaWYgKGFkZHJlc3MzID09PSBGQUlMVVJFKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5kZXgzO1xuICAgICAgICAgICAgICAgIGFkZHJlc3MzID0gdGhpcy5fcmVhZF9zaG9vdCgpO1xuICAgICAgICAgICAgICAgIGlmIChhZGRyZXNzMyA9PT0gRkFJTFVSRSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5kZXgzO1xuICAgICAgICAgICAgICAgICAgYWRkcmVzczMgPSB0aGlzLl9yZWFkX2JyYW5jaCgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MzID09PSBGQUlMVVJFKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IGluZGV4MztcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzczMgPSB0aGlzLl9yZWFkX2xvb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MzID09PSBGQUlMVVJFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5kZXgzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhZGRyZXNzMyAhPT0gRkFJTFVSRSkge1xuICAgICAgICAgICAgZWxlbWVudHMxWzBdID0gYWRkcmVzczM7XG4gICAgICAgICAgICB2YXIgYWRkcmVzczQgPSBGQUlMVVJFO1xuICAgICAgICAgICAgYWRkcmVzczQgPSB0aGlzLl9yZWFkX3dzKCk7XG4gICAgICAgICAgICBpZiAoYWRkcmVzczQgIT09IEZBSUxVUkUpIHtcbiAgICAgICAgICAgICAgdmFyIGFkZHJlc3M1ID0gRkFJTFVSRTtcbiAgICAgICAgICAgICAgYWRkcmVzczUgPSB0aGlzLl9yZWFkX25sKCk7XG4gICAgICAgICAgICAgIGlmIChhZGRyZXNzNSAhPT0gRkFJTFVSRSkge1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzMSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5kZXgyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbGVtZW50czEgPSBudWxsO1xuICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbmRleDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnRzMSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbmRleDI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW1lbnRzMSA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5kZXgyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50czEgPT09IG51bGwpIHtcbiAgICAgICAgICBhZGRyZXNzMSA9IEZBSUxVUkU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkcmVzczEgPSBuZXcgVHJlZU5vZGUodGhpcy5faW5wdXQuc3Vic3RyaW5nKGluZGV4MiwgdGhpcy5fb2Zmc2V0KSwgaW5kZXgyLCBlbGVtZW50czEpO1xuICAgICAgICAgIHRoaXMuX29mZnNldCA9IHRoaXMuX29mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWRkcmVzczEgIT09IEZBSUxVUkUpIHtcbiAgICAgICAgICBlbGVtZW50czAucHVzaChhZGRyZXNzMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50czAubGVuZ3RoID49IDApIHtcbiAgICAgICAgYWRkcmVzczAgPSBuZXcgVHJlZU5vZGUodGhpcy5faW5wdXQuc3Vic3RyaW5nKGluZGV4MSwgdGhpcy5fb2Zmc2V0KSwgaW5kZXgxLCBlbGVtZW50czApO1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSB0aGlzLl9vZmZzZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRyZXNzMCA9IEZBSUxVUkU7XG4gICAgICB9XG4gICAgICB0aGlzLl9jYWNoZS5fYm9keVtpbmRleDBdID0gW2FkZHJlc3MwLCB0aGlzLl9vZmZzZXRdO1xuICAgICAgcmV0dXJuIGFkZHJlc3MwO1xuICAgIH0sXG5cbiAgICBfcmVhZF9sb29wICgpIHtcbiAgICAgIHZhciBhZGRyZXNzMCA9IEZBSUxVUkUsIGluZGV4MCA9IHRoaXMuX29mZnNldDtcbiAgICAgIHRoaXMuX2NhY2hlLl9sb29wID0gdGhpcy5fY2FjaGUuX2xvb3AgfHwge307XG4gICAgICB2YXIgY2FjaGVkID0gdGhpcy5fY2FjaGUuX2xvb3BbaW5kZXgwXTtcbiAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gY2FjaGVkWzFdO1xuICAgICAgICByZXR1cm4gY2FjaGVkWzBdO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4MSA9IHRoaXMuX29mZnNldCwgZWxlbWVudHMwID0gbmV3IEFycmF5KDMpO1xuICAgICAgdmFyIGFkZHJlc3MxID0gRkFJTFVSRTtcbiAgICAgIHZhciBjaHVuazAgPSBudWxsLCBtYXgwID0gdGhpcy5fb2Zmc2V0ICsgODtcbiAgICAgIGlmIChtYXgwIDw9IHRoaXMuX2lucHV0U2l6ZSkge1xuICAgICAgICBjaHVuazAgPSB0aGlzLl9pbnB1dC5zdWJzdHJpbmcodGhpcy5fb2Zmc2V0LCBtYXgwKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaHVuazAgPT09ICdtaWVudHJhcycpIHtcbiAgICAgICAgYWRkcmVzczEgPSBuZXcgVHJlZU5vZGUodGhpcy5faW5wdXQuc3Vic3RyaW5nKHRoaXMuX29mZnNldCwgdGhpcy5fb2Zmc2V0ICsgOCksIHRoaXMuX29mZnNldCwgW10pO1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSB0aGlzLl9vZmZzZXQgKyA4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkcmVzczEgPSBGQUlMVVJFO1xuICAgICAgICBpZiAodGhpcy5fb2Zmc2V0ID4gdGhpcy5fZmFpbHVyZSkge1xuICAgICAgICAgIHRoaXMuX2ZhaWx1cmUgPSB0aGlzLl9vZmZzZXQ7XG4gICAgICAgICAgdGhpcy5fZXhwZWN0ZWQgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fb2Zmc2V0ID09PSB0aGlzLl9mYWlsdXJlKSB7XG4gICAgICAgICAgdGhpcy5fZXhwZWN0ZWQucHVzaChbJ1NpRGlMYTo6bG9vcCcsICdcXCdtaWVudHJhc1xcJyddKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFkZHJlc3MxICE9PSBGQUlMVVJFKSB7XG4gICAgICAgIGVsZW1lbnRzMFswXSA9IGFkZHJlc3MxO1xuICAgICAgICB2YXIgYWRkcmVzczIgPSBGQUlMVVJFO1xuICAgICAgICBhZGRyZXNzMiA9IHRoaXMuX3JlYWRfd3MoKTtcbiAgICAgICAgaWYgKGFkZHJlc3MyICE9PSBGQUlMVVJFKSB7XG4gICAgICAgICAgdmFyIGFkZHJlc3MzID0gRkFJTFVSRTtcbiAgICAgICAgICBhZGRyZXNzMyA9IHRoaXMuX3JlYWRfY29uZGl0aW9uKCk7XG4gICAgICAgICAgaWYgKGFkZHJlc3MzICE9PSBGQUlMVVJFKSB7XG4gICAgICAgICAgICBlbGVtZW50czBbMV0gPSBhZGRyZXNzMztcbiAgICAgICAgICAgIHZhciBhZGRyZXNzNCA9IEZBSUxVUkU7XG4gICAgICAgICAgICBhZGRyZXNzNCA9IHRoaXMuX3JlYWRfd3MoKTtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzNCAhPT0gRkFJTFVSRSkge1xuICAgICAgICAgICAgICB2YXIgYWRkcmVzczUgPSBGQUlMVVJFO1xuICAgICAgICAgICAgICB2YXIgY2h1bmsxID0gbnVsbCwgbWF4MSA9IHRoaXMuX29mZnNldCArIDE7XG4gICAgICAgICAgICAgIGlmIChtYXgxIDw9IHRoaXMuX2lucHV0U2l6ZSkge1xuICAgICAgICAgICAgICAgIGNodW5rMSA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyh0aGlzLl9vZmZzZXQsIG1heDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjaHVuazEgPT09ICcoJykge1xuICAgICAgICAgICAgICAgIGFkZHJlc3M1ID0gbmV3IFRyZWVOb2RlKHRoaXMuX2lucHV0LnN1YnN0cmluZyh0aGlzLl9vZmZzZXQsIHRoaXMuX29mZnNldCArIDEpLCB0aGlzLl9vZmZzZXQsIFtdKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSB0aGlzLl9vZmZzZXQgKyAxO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZHJlc3M1ID0gRkFJTFVSRTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb2Zmc2V0ID4gdGhpcy5fZmFpbHVyZSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fZmFpbHVyZSA9IHRoaXMuX29mZnNldDtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2V4cGVjdGVkID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vZmZzZXQgPT09IHRoaXMuX2ZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2V4cGVjdGVkLnB1c2goWydTaURpTGE6Omxvb3AnLCAnXFwnKFxcJyddKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGFkZHJlc3M1ICE9PSBGQUlMVVJFKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFkZHJlc3M2ID0gRkFJTFVSRTtcbiAgICAgICAgICAgICAgICBhZGRyZXNzNiA9IHRoaXMuX3JlYWRfbmwoKTtcbiAgICAgICAgICAgICAgICBpZiAoYWRkcmVzczYgIT09IEZBSUxVUkUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBhZGRyZXNzNyA9IEZBSUxVUkU7XG4gICAgICAgICAgICAgICAgICBhZGRyZXNzNyA9IHRoaXMuX3JlYWRfYm9keSgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3M3ICE9PSBGQUlMVVJFKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzMFsyXSA9IGFkZHJlc3M3O1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWRkcmVzczggPSBGQUlMVVJFO1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOCA9IHRoaXMuX3JlYWRfbmwoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3M4ICE9PSBGQUlMVVJFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGFkZHJlc3M5ID0gRkFJTFVSRTtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOSA9IHRoaXMuX3JlYWRfd3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzczkgIT09IEZBSUxVUkUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGRyZXNzMTAgPSBGQUlMVVJFO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNodW5rMiA9IG51bGwsIG1heDIgPSB0aGlzLl9vZmZzZXQgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heDIgPD0gdGhpcy5faW5wdXRTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rMiA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyh0aGlzLl9vZmZzZXQsIG1heDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rMiA9PT0gJyknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MxMCA9IG5ldyBUcmVlTm9kZSh0aGlzLl9pbnB1dC5zdWJzdHJpbmcodGhpcy5fb2Zmc2V0LCB0aGlzLl9vZmZzZXQgKyAxKSwgdGhpcy5fb2Zmc2V0LCBbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IHRoaXMuX29mZnNldCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzMTAgPSBGQUlMVVJFO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fb2Zmc2V0ID4gdGhpcy5fZmFpbHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZhaWx1cmUgPSB0aGlzLl9vZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXhwZWN0ZWQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fb2Zmc2V0ID09PSB0aGlzLl9mYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXhwZWN0ZWQucHVzaChbJ1NpRGlMYTo6bG9vcCcsICdcXCcpXFwnJ10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzczEwICE9PSBGQUlMVVJFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50czAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbmRleDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzMCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbmRleDE7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzMCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5kZXgxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50czAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbmRleDE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnRzMCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbmRleDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzMCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5kZXgxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbGVtZW50czAgPSBudWxsO1xuICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbmRleDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnRzMCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbmRleDE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW1lbnRzMCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5kZXgxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50czAgPSBudWxsO1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbmRleDE7XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudHMwID09PSBudWxsKSB7XG4gICAgICAgIGFkZHJlc3MwID0gRkFJTFVSRTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZHJlc3MwID0gdGhpcy5fYWN0aW9ucy5tYWtlTG9vcCh0aGlzLl9pbnB1dCwgaW5kZXgxLCB0aGlzLl9vZmZzZXQsIGVsZW1lbnRzMCk7XG4gICAgICAgIHRoaXMuX29mZnNldCA9IHRoaXMuX29mZnNldDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhY2hlLl9sb29wW2luZGV4MF0gPSBbYWRkcmVzczAsIHRoaXMuX29mZnNldF07XG4gICAgICByZXR1cm4gYWRkcmVzczA7XG4gICAgfSxcblxuICAgIF9yZWFkX2JyYW5jaCAoKSB7XG4gICAgICB2YXIgYWRkcmVzczAgPSBGQUlMVVJFLCBpbmRleDAgPSB0aGlzLl9vZmZzZXQ7XG4gICAgICB0aGlzLl9jYWNoZS5fYnJhbmNoID0gdGhpcy5fY2FjaGUuX2JyYW5jaCB8fCB7fTtcbiAgICAgIHZhciBjYWNoZWQgPSB0aGlzLl9jYWNoZS5fYnJhbmNoW2luZGV4MF07XG4gICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgIHRoaXMuX29mZnNldCA9IGNhY2hlZFsxXTtcbiAgICAgICAgcmV0dXJuIGNhY2hlZFswXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleDEgPSB0aGlzLl9vZmZzZXQsIGVsZW1lbnRzMCA9IG5ldyBBcnJheSg0KTtcbiAgICAgIHZhciBhZGRyZXNzMSA9IEZBSUxVUkU7XG4gICAgICB2YXIgY2h1bmswID0gbnVsbCwgbWF4MCA9IHRoaXMuX29mZnNldCArIDI7XG4gICAgICBpZiAobWF4MCA8PSB0aGlzLl9pbnB1dFNpemUpIHtcbiAgICAgICAgY2h1bmswID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKHRoaXMuX29mZnNldCwgbWF4MCk7XG4gICAgICB9XG4gICAgICBpZiAoY2h1bmswID09PSAnc2knKSB7XG4gICAgICAgIGFkZHJlc3MxID0gbmV3IFRyZWVOb2RlKHRoaXMuX2lucHV0LnN1YnN0cmluZyh0aGlzLl9vZmZzZXQsIHRoaXMuX29mZnNldCArIDIpLCB0aGlzLl9vZmZzZXQsIFtdKTtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0ICsgMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZHJlc3MxID0gRkFJTFVSRTtcbiAgICAgICAgaWYgKHRoaXMuX29mZnNldCA+IHRoaXMuX2ZhaWx1cmUpIHtcbiAgICAgICAgICB0aGlzLl9mYWlsdXJlID0gdGhpcy5fb2Zmc2V0O1xuICAgICAgICAgIHRoaXMuX2V4cGVjdGVkID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX29mZnNldCA9PT0gdGhpcy5fZmFpbHVyZSkge1xuICAgICAgICAgIHRoaXMuX2V4cGVjdGVkLnB1c2goWydTaURpTGE6OmJyYW5jaCcsICdcXCdzaVxcJyddKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFkZHJlc3MxICE9PSBGQUlMVVJFKSB7XG4gICAgICAgIGVsZW1lbnRzMFswXSA9IGFkZHJlc3MxO1xuICAgICAgICB2YXIgYWRkcmVzczIgPSBGQUlMVVJFO1xuICAgICAgICBhZGRyZXNzMiA9IHRoaXMuX3JlYWRfd3MoKTtcbiAgICAgICAgaWYgKGFkZHJlc3MyICE9PSBGQUlMVVJFKSB7XG4gICAgICAgICAgdmFyIGFkZHJlc3MzID0gRkFJTFVSRTtcbiAgICAgICAgICBhZGRyZXNzMyA9IHRoaXMuX3JlYWRfY29uZGl0aW9uKCk7XG4gICAgICAgICAgaWYgKGFkZHJlc3MzICE9PSBGQUlMVVJFKSB7XG4gICAgICAgICAgICBlbGVtZW50czBbMV0gPSBhZGRyZXNzMztcbiAgICAgICAgICAgIHZhciBhZGRyZXNzNCA9IEZBSUxVUkU7XG4gICAgICAgICAgICBhZGRyZXNzNCA9IHRoaXMuX3JlYWRfd3MoKTtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzNCAhPT0gRkFJTFVSRSkge1xuICAgICAgICAgICAgICB2YXIgYWRkcmVzczUgPSBGQUlMVVJFO1xuICAgICAgICAgICAgICB2YXIgY2h1bmsxID0gbnVsbCwgbWF4MSA9IHRoaXMuX29mZnNldCArIDE7XG4gICAgICAgICAgICAgIGlmIChtYXgxIDw9IHRoaXMuX2lucHV0U2l6ZSkge1xuICAgICAgICAgICAgICAgIGNodW5rMSA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyh0aGlzLl9vZmZzZXQsIG1heDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjaHVuazEgPT09ICcoJykge1xuICAgICAgICAgICAgICAgIGFkZHJlc3M1ID0gbmV3IFRyZWVOb2RlKHRoaXMuX2lucHV0LnN1YnN0cmluZyh0aGlzLl9vZmZzZXQsIHRoaXMuX29mZnNldCArIDEpLCB0aGlzLl9vZmZzZXQsIFtdKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSB0aGlzLl9vZmZzZXQgKyAxO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZHJlc3M1ID0gRkFJTFVSRTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb2Zmc2V0ID4gdGhpcy5fZmFpbHVyZSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fZmFpbHVyZSA9IHRoaXMuX29mZnNldDtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2V4cGVjdGVkID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vZmZzZXQgPT09IHRoaXMuX2ZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2V4cGVjdGVkLnB1c2goWydTaURpTGE6OmJyYW5jaCcsICdcXCcoXFwnJ10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoYWRkcmVzczUgIT09IEZBSUxVUkUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWRkcmVzczYgPSBGQUlMVVJFO1xuICAgICAgICAgICAgICAgIGFkZHJlc3M2ID0gdGhpcy5fcmVhZF9ubCgpO1xuICAgICAgICAgICAgICAgIGlmIChhZGRyZXNzNiAhPT0gRkFJTFVSRSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGFkZHJlc3M3ID0gRkFJTFVSRTtcbiAgICAgICAgICAgICAgICAgIGFkZHJlc3M3ID0gdGhpcy5fcmVhZF9ib2R5KCk7XG4gICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzczcgIT09IEZBSUxVUkUpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMwWzJdID0gYWRkcmVzczc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhZGRyZXNzOCA9IEZBSUxVUkU7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M4ID0gdGhpcy5fcmVhZF9ubCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzczggIT09IEZBSUxVUkUpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgYWRkcmVzczkgPSBGQUlMVVJFO1xuICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M5ID0gdGhpcy5fcmVhZF93cygpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGRyZXNzOSAhPT0gRkFJTFVSRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkZHJlc3MxMCA9IEZBSUxVUkU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2h1bmsyID0gbnVsbCwgbWF4MiA9IHRoaXMuX29mZnNldCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF4MiA8PSB0aGlzLl9pbnB1dFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsyID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKHRoaXMuX29mZnNldCwgbWF4Mik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmsyID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczEwID0gbmV3IFRyZWVOb2RlKHRoaXMuX2lucHV0LnN1YnN0cmluZyh0aGlzLl9vZmZzZXQsIHRoaXMuX29mZnNldCArIDEpLCB0aGlzLl9vZmZzZXQsIFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MxMCA9IEZBSUxVUkU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vZmZzZXQgPiB0aGlzLl9mYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmFpbHVyZSA9IHRoaXMuX29mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9leHBlY3RlZCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vZmZzZXQgPT09IHRoaXMuX2ZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9leHBlY3RlZC5wdXNoKFsnU2lEaUxhOjpicmFuY2gnLCAnXFwnKVxcJyddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MxMCAhPT0gRkFJTFVSRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWRkcmVzczExID0gRkFJTFVSRTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4MiA9IHRoaXMuX29mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4MyA9IHRoaXMuX29mZnNldCwgZWxlbWVudHMxID0gbmV3IEFycmF5KDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWRkcmVzczEyID0gRkFJTFVSRTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczEyID0gdGhpcy5fcmVhZF93cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzczEyICE9PSBGQUlMVVJFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkZHJlc3MxMyA9IEZBSUxVUkU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNodW5rMyA9IG51bGwsIG1heDMgPSB0aGlzLl9vZmZzZXQgKyA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXgzIDw9IHRoaXMuX2lucHV0U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmszID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKHRoaXMuX29mZnNldCwgbWF4Myk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaHVuazMgPT09ICdzaSBubycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MxMyA9IG5ldyBUcmVlTm9kZSh0aGlzLl9pbnB1dC5zdWJzdHJpbmcodGhpcy5fb2Zmc2V0LCB0aGlzLl9vZmZzZXQgKyA1KSwgdGhpcy5fb2Zmc2V0LCBbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSB0aGlzLl9vZmZzZXQgKyA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzMTMgPSBGQUlMVVJFO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX29mZnNldCA+IHRoaXMuX2ZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmFpbHVyZSA9IHRoaXMuX29mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXhwZWN0ZWQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vZmZzZXQgPT09IHRoaXMuX2ZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXhwZWN0ZWQucHVzaChbJ1NpRGlMYTo6YnJhbmNoJywgJ1xcJ3NpIG5vXFwnJ10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzczEzICE9PSBGQUlMVVJFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50czFbMF0gPSBhZGRyZXNzMTM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWRkcmVzczE0ID0gRkFJTFVSRTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MxNCA9IHRoaXMuX3JlYWRfd3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGRyZXNzMTQgIT09IEZBSUxVUkUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkZHJlc3MxNSA9IEZBSUxVUkU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaHVuazQgPSBudWxsLCBtYXg0ID0gdGhpcy5fb2Zmc2V0ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heDQgPD0gdGhpcy5faW5wdXRTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bms0ID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKHRoaXMuX29mZnNldCwgbWF4NCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rNCA9PT0gJygnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczE1ID0gbmV3IFRyZWVOb2RlKHRoaXMuX2lucHV0LnN1YnN0cmluZyh0aGlzLl9vZmZzZXQsIHRoaXMuX29mZnNldCArIDEpLCB0aGlzLl9vZmZzZXQsIFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSB0aGlzLl9vZmZzZXQgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MxNSA9IEZBSUxVUkU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX29mZnNldCA+IHRoaXMuX2ZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZhaWx1cmUgPSB0aGlzLl9vZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9leHBlY3RlZCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fb2Zmc2V0ID09PSB0aGlzLl9mYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9leHBlY3RlZC5wdXNoKFsnU2lEaUxhOjpicmFuY2gnLCAnXFwnKFxcJyddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MxNSAhPT0gRkFJTFVSRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGRyZXNzMTYgPSBGQUlMVVJFO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MxNiA9IHRoaXMuX3JlYWRfbmwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzczE2ICE9PSBGQUlMVVJFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWRkcmVzczE3ID0gRkFJTFVSRTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MxNyA9IHRoaXMuX3JlYWRfYm9keSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MxNyAhPT0gRkFJTFVSRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50czFbMV0gPSBhZGRyZXNzMTc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGRyZXNzMTggPSBGQUlMVVJFO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzMTggPSB0aGlzLl9yZWFkX25sKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGRyZXNzMTggIT09IEZBSUxVUkUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWRkcmVzczE5ID0gRkFJTFVSRTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzMTkgPSB0aGlzLl9yZWFkX3dzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MxOSAhPT0gRkFJTFVSRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkZHJlc3MyMCA9IEZBSUxVUkU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2h1bms1ID0gbnVsbCwgbWF4NSA9IHRoaXMuX29mZnNldCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF4NSA8PSB0aGlzLl9pbnB1dFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bms1ID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKHRoaXMuX29mZnNldCwgbWF4NSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bms1ID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczIwID0gbmV3IFRyZWVOb2RlKHRoaXMuX2lucHV0LnN1YnN0cmluZyh0aGlzLl9vZmZzZXQsIHRoaXMuX29mZnNldCArIDEpLCB0aGlzLl9vZmZzZXQsIFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MyMCA9IEZBSUxVUkU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vZmZzZXQgPiB0aGlzLl9mYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmFpbHVyZSA9IHRoaXMuX29mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9leHBlY3RlZCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vZmZzZXQgPT09IHRoaXMuX2ZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9leHBlY3RlZC5wdXNoKFsnU2lEaUxhOjpicmFuY2gnLCAnXFwnKVxcJyddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MyMCAhPT0gRkFJTFVSRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMxID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5kZXgzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50czEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5kZXgzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50czEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IGluZGV4MztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMxID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5kZXgzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50czEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5kZXgzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50czEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IGluZGV4MztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMxID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5kZXgzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50czEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5kZXgzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50czEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IGluZGV4MztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHMxID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczExID0gRkFJTFVSRTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzMTEgPSBuZXcgVHJlZU5vZGUzKHRoaXMuX2lucHV0LnN1YnN0cmluZyhpbmRleDMsIHRoaXMuX29mZnNldCksIGluZGV4MywgZWxlbWVudHMxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSB0aGlzLl9vZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MxMSA9PT0gRkFJTFVSRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MxMSA9IG5ldyBUcmVlTm9kZSh0aGlzLl9pbnB1dC5zdWJzdHJpbmcoaW5kZXgyLCBpbmRleDIpLCBpbmRleDIsIFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbmRleDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MxMSAhPT0gRkFJTFVSRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzMFszXSA9IGFkZHJlc3MxMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50czAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IGluZGV4MTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5kZXgxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50czAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5kZXgxO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50czAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IGluZGV4MTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5kZXgxO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50czAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5kZXgxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50czAgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IGluZGV4MTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWxlbWVudHMwID0gbnVsbDtcbiAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5kZXgxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50czAgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5kZXgxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50czAgPSBudWxsO1xuICAgICAgICAgIHRoaXMuX29mZnNldCA9IGluZGV4MTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudHMwID0gbnVsbDtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5kZXgxO1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnRzMCA9PT0gbnVsbCkge1xuICAgICAgICBhZGRyZXNzMCA9IEZBSUxVUkU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRyZXNzMCA9IHRoaXMuX2FjdGlvbnMubWFrZUJyYW5jaCh0aGlzLl9pbnB1dCwgaW5kZXgxLCB0aGlzLl9vZmZzZXQsIGVsZW1lbnRzMCk7XG4gICAgICAgIHRoaXMuX29mZnNldCA9IHRoaXMuX29mZnNldDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhY2hlLl9icmFuY2hbaW5kZXgwXSA9IFthZGRyZXNzMCwgdGhpcy5fb2Zmc2V0XTtcbiAgICAgIHJldHVybiBhZGRyZXNzMDtcbiAgICB9LFxuXG4gICAgX3JlYWRfY29uZGl0aW9uICgpIHtcbiAgICAgIHZhciBhZGRyZXNzMCA9IEZBSUxVUkUsIGluZGV4MCA9IHRoaXMuX29mZnNldDtcbiAgICAgIHRoaXMuX2NhY2hlLl9jb25kaXRpb24gPSB0aGlzLl9jYWNoZS5fY29uZGl0aW9uIHx8IHt9O1xuICAgICAgdmFyIGNhY2hlZCA9IHRoaXMuX2NhY2hlLl9jb25kaXRpb25baW5kZXgwXTtcbiAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gY2FjaGVkWzFdO1xuICAgICAgICByZXR1cm4gY2FjaGVkWzBdO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4MSA9IHRoaXMuX29mZnNldDtcbiAgICAgIGFkZHJlc3MwID0gdGhpcy5fcmVhZF9haGVhZF9jb25kaXRpb24oKTtcbiAgICAgIGlmIChhZGRyZXNzMCA9PT0gRkFJTFVSRSkge1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbmRleDE7XG4gICAgICAgIGFkZHJlc3MwID0gdGhpcy5fcmVhZF9pbl9nYW1lX2NvbmRpdGlvbigpO1xuICAgICAgICBpZiAoYWRkcmVzczAgPT09IEZBSUxVUkUpIHtcbiAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbmRleDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhY2hlLl9jb25kaXRpb25baW5kZXgwXSA9IFthZGRyZXNzMCwgdGhpcy5fb2Zmc2V0XTtcbiAgICAgIHJldHVybiBhZGRyZXNzMDtcbiAgICB9LFxuXG4gICAgX3JlYWRfaW5fZ2FtZV9jb25kaXRpb24gKCkge1xuICAgICAgdmFyIGFkZHJlc3MwID0gRkFJTFVSRSwgaW5kZXgwID0gdGhpcy5fb2Zmc2V0O1xuICAgICAgdGhpcy5fY2FjaGUuX2luX2dhbWVfY29uZGl0aW9uID0gdGhpcy5fY2FjaGUuX2luX2dhbWVfY29uZGl0aW9uIHx8IHt9O1xuICAgICAgdmFyIGNhY2hlZCA9IHRoaXMuX2NhY2hlLl9pbl9nYW1lX2NvbmRpdGlvbltpbmRleDBdO1xuICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSBjYWNoZWRbMV07XG4gICAgICAgIHJldHVybiBjYWNoZWRbMF07XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXgxID0gdGhpcy5fb2Zmc2V0LCBlbGVtZW50czAgPSBuZXcgQXJyYXkoMik7XG4gICAgICB2YXIgYWRkcmVzczEgPSBGQUlMVVJFO1xuICAgICAgYWRkcmVzczEgPSB0aGlzLl9yZWFkX25vdCgpO1xuICAgICAgaWYgKGFkZHJlc3MxICE9PSBGQUlMVVJFKSB7XG4gICAgICAgIGVsZW1lbnRzMFswXSA9IGFkZHJlc3MxO1xuICAgICAgICB2YXIgYWRkcmVzczIgPSBGQUlMVVJFO1xuICAgICAgICBhZGRyZXNzMiA9IHRoaXMuX3JlYWRfd3MoKTtcbiAgICAgICAgaWYgKGFkZHJlc3MyICE9PSBGQUlMVVJFKSB7XG4gICAgICAgICAgdmFyIGFkZHJlc3MzID0gRkFJTFVSRTtcbiAgICAgICAgICB2YXIgY2h1bmswID0gbnVsbCwgbWF4MCA9IHRoaXMuX29mZnNldCArIDExO1xuICAgICAgICAgIGlmIChtYXgwIDw9IHRoaXMuX2lucHV0U2l6ZSkge1xuICAgICAgICAgICAgY2h1bmswID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKHRoaXMuX29mZnNldCwgbWF4MCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaHVuazAgPT09ICdoYXlhIHNhbGlkbycpIHtcbiAgICAgICAgICAgIGFkZHJlc3MzID0gbmV3IFRyZWVOb2RlKHRoaXMuX2lucHV0LnN1YnN0cmluZyh0aGlzLl9vZmZzZXQsIHRoaXMuX29mZnNldCArIDExKSwgdGhpcy5fb2Zmc2V0LCBbXSk7XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSB0aGlzLl9vZmZzZXQgKyAxMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRkcmVzczMgPSBGQUlMVVJFO1xuICAgICAgICAgICAgaWYgKHRoaXMuX29mZnNldCA+IHRoaXMuX2ZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZmFpbHVyZSA9IHRoaXMuX29mZnNldDtcbiAgICAgICAgICAgICAgdGhpcy5fZXhwZWN0ZWQgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9vZmZzZXQgPT09IHRoaXMuX2ZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZXhwZWN0ZWQucHVzaChbJ1NpRGlMYTo6aW5fZ2FtZV9jb25kaXRpb24nLCAnXFwnaGF5YSBzYWxpZG9cXCcnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhZGRyZXNzMyAhPT0gRkFJTFVSRSkge1xuICAgICAgICAgICAgZWxlbWVudHMwWzFdID0gYWRkcmVzczM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnRzMCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbmRleDE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW1lbnRzMCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5kZXgxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50czAgPSBudWxsO1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbmRleDE7XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudHMwID09PSBudWxsKSB7XG4gICAgICAgIGFkZHJlc3MwID0gRkFJTFVSRTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZHJlc3MwID0gdGhpcy5fYWN0aW9ucy5tYWtlSW5HYW1lQ29uZGl0aW9uKHRoaXMuX2lucHV0LCBpbmRleDEsIHRoaXMuX29mZnNldCwgZWxlbWVudHMwKTtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0O1xuICAgICAgfVxuICAgICAgdGhpcy5fY2FjaGUuX2luX2dhbWVfY29uZGl0aW9uW2luZGV4MF0gPSBbYWRkcmVzczAsIHRoaXMuX29mZnNldF07XG4gICAgICByZXR1cm4gYWRkcmVzczA7XG4gICAgfSxcblxuICAgIF9yZWFkX2FoZWFkX2NvbmRpdGlvbiAoKSB7XG4gICAgICB2YXIgYWRkcmVzczAgPSBGQUlMVVJFLCBpbmRleDAgPSB0aGlzLl9vZmZzZXQ7XG4gICAgICB0aGlzLl9jYWNoZS5fYWhlYWRfY29uZGl0aW9uID0gdGhpcy5fY2FjaGUuX2FoZWFkX2NvbmRpdGlvbiB8fCB7fTtcbiAgICAgIHZhciBjYWNoZWQgPSB0aGlzLl9jYWNoZS5fYWhlYWRfY29uZGl0aW9uW2luZGV4MF07XG4gICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgIHRoaXMuX29mZnNldCA9IGNhY2hlZFsxXTtcbiAgICAgICAgcmV0dXJuIGNhY2hlZFswXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleDEgPSB0aGlzLl9vZmZzZXQsIGVsZW1lbnRzMCA9IG5ldyBBcnJheSg0KTtcbiAgICAgIHZhciBhZGRyZXNzMSA9IEZBSUxVUkU7XG4gICAgICBhZGRyZXNzMSA9IHRoaXMuX3JlYWRfbm90KCk7XG4gICAgICBpZiAoYWRkcmVzczEgIT09IEZBSUxVUkUpIHtcbiAgICAgICAgZWxlbWVudHMwWzBdID0gYWRkcmVzczE7XG4gICAgICAgIHZhciBhZGRyZXNzMiA9IEZBSUxVUkU7XG4gICAgICAgIGFkZHJlc3MyID0gdGhpcy5fcmVhZF93cygpO1xuICAgICAgICBpZiAoYWRkcmVzczIgIT09IEZBSUxVUkUpIHtcbiAgICAgICAgICB2YXIgYWRkcmVzczMgPSBGQUlMVVJFO1xuICAgICAgICAgIHZhciBjaHVuazAgPSBudWxsLCBtYXgwID0gdGhpcy5fb2Zmc2V0ICsgMztcbiAgICAgICAgICBpZiAobWF4MCA8PSB0aGlzLl9pbnB1dFNpemUpIHtcbiAgICAgICAgICAgIGNodW5rMCA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyh0aGlzLl9vZmZzZXQsIG1heDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2h1bmswID09PSAnaGF5Jykge1xuICAgICAgICAgICAgYWRkcmVzczMgPSBuZXcgVHJlZU5vZGUodGhpcy5faW5wdXQuc3Vic3RyaW5nKHRoaXMuX29mZnNldCwgdGhpcy5fb2Zmc2V0ICsgMyksIHRoaXMuX29mZnNldCwgW10pO1xuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0ICsgMztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRkcmVzczMgPSBGQUlMVVJFO1xuICAgICAgICAgICAgaWYgKHRoaXMuX29mZnNldCA+IHRoaXMuX2ZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZmFpbHVyZSA9IHRoaXMuX29mZnNldDtcbiAgICAgICAgICAgICAgdGhpcy5fZXhwZWN0ZWQgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9vZmZzZXQgPT09IHRoaXMuX2ZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZXhwZWN0ZWQucHVzaChbJ1NpRGlMYTo6YWhlYWRfY29uZGl0aW9uJywgJ1xcJ2hheVxcJyddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFkZHJlc3MzICE9PSBGQUlMVVJFKSB7XG4gICAgICAgICAgICBlbGVtZW50czBbMV0gPSBhZGRyZXNzMztcbiAgICAgICAgICAgIHZhciBhZGRyZXNzNCA9IEZBSUxVUkU7XG4gICAgICAgICAgICBhZGRyZXNzNCA9IHRoaXMuX3JlYWRfd3MoKTtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzNCAhPT0gRkFJTFVSRSkge1xuICAgICAgICAgICAgICB2YXIgYWRkcmVzczUgPSBGQUlMVVJFO1xuICAgICAgICAgICAgICBhZGRyZXNzNSA9IHRoaXMuX3JlYWRfc3ByaXRlKCk7XG4gICAgICAgICAgICAgIGlmIChhZGRyZXNzNSAhPT0gRkFJTFVSRSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzMFsyXSA9IGFkZHJlc3M1O1xuICAgICAgICAgICAgICAgIHZhciBhZGRyZXNzNiA9IEZBSUxVUkU7XG4gICAgICAgICAgICAgICAgYWRkcmVzczYgPSB0aGlzLl9yZWFkX3dzKCk7XG4gICAgICAgICAgICAgICAgaWYgKGFkZHJlc3M2ICE9PSBGQUlMVVJFKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYWRkcmVzczcgPSBGQUlMVVJFO1xuICAgICAgICAgICAgICAgICAgYWRkcmVzczcgPSB0aGlzLl9yZWFkX2xvb2tfdXBfZGlyZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzczcgIT09IEZBSUxVUkUpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMwWzNdID0gYWRkcmVzczc7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50czAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbmRleDE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnRzMCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbmRleDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzMCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5kZXgxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbGVtZW50czAgPSBudWxsO1xuICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbmRleDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnRzMCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbmRleDE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW1lbnRzMCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5kZXgxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50czAgPSBudWxsO1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbmRleDE7XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudHMwID09PSBudWxsKSB7XG4gICAgICAgIGFkZHJlc3MwID0gRkFJTFVSRTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZHJlc3MwID0gdGhpcy5fYWN0aW9ucy5tYWtlTG9va0FoZWFkQ29uZGl0aW9uKHRoaXMuX2lucHV0LCBpbmRleDEsIHRoaXMuX29mZnNldCwgZWxlbWVudHMwKTtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0O1xuICAgICAgfVxuICAgICAgdGhpcy5fY2FjaGUuX2FoZWFkX2NvbmRpdGlvbltpbmRleDBdID0gW2FkZHJlc3MwLCB0aGlzLl9vZmZzZXRdO1xuICAgICAgcmV0dXJuIGFkZHJlc3MwO1xuICAgIH0sXG5cbiAgICBfcmVhZF9ub3QgKCkge1xuICAgICAgdmFyIGFkZHJlc3MwID0gRkFJTFVSRSwgaW5kZXgwID0gdGhpcy5fb2Zmc2V0O1xuICAgICAgdGhpcy5fY2FjaGUuX25vdCA9IHRoaXMuX2NhY2hlLl9ub3QgfHwge307XG4gICAgICB2YXIgY2FjaGVkID0gdGhpcy5fY2FjaGUuX25vdFtpbmRleDBdO1xuICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSBjYWNoZWRbMV07XG4gICAgICAgIHJldHVybiBjYWNoZWRbMF07XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXgxID0gdGhpcy5fb2Zmc2V0O1xuICAgICAgdmFyIGNodW5rMCA9IG51bGwsIG1heDAgPSB0aGlzLl9vZmZzZXQgKyAyO1xuICAgICAgaWYgKG1heDAgPD0gdGhpcy5faW5wdXRTaXplKSB7XG4gICAgICAgIGNodW5rMCA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyh0aGlzLl9vZmZzZXQsIG1heDApO1xuICAgICAgfVxuICAgICAgaWYgKGNodW5rMCA9PT0gJ25vJykge1xuICAgICAgICBhZGRyZXNzMCA9IG5ldyBUcmVlTm9kZSh0aGlzLl9pbnB1dC5zdWJzdHJpbmcodGhpcy5fb2Zmc2V0LCB0aGlzLl9vZmZzZXQgKyAyKSwgdGhpcy5fb2Zmc2V0LCBbXSk7XG4gICAgICAgIHRoaXMuX29mZnNldCA9IHRoaXMuX29mZnNldCArIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRyZXNzMCA9IEZBSUxVUkU7XG4gICAgICAgIGlmICh0aGlzLl9vZmZzZXQgPiB0aGlzLl9mYWlsdXJlKSB7XG4gICAgICAgICAgdGhpcy5fZmFpbHVyZSA9IHRoaXMuX29mZnNldDtcbiAgICAgICAgICB0aGlzLl9leHBlY3RlZCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9vZmZzZXQgPT09IHRoaXMuX2ZhaWx1cmUpIHtcbiAgICAgICAgICB0aGlzLl9leHBlY3RlZC5wdXNoKFsnU2lEaUxhOjpub3QnLCAnXFwnbm9cXCcnXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhZGRyZXNzMCA9PT0gRkFJTFVSRSkge1xuICAgICAgICBhZGRyZXNzMCA9IG5ldyBUcmVlTm9kZSh0aGlzLl9pbnB1dC5zdWJzdHJpbmcoaW5kZXgxLCBpbmRleDEpLCBpbmRleDEsIFtdKTtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5kZXgxO1xuICAgICAgfVxuICAgICAgdGhpcy5fY2FjaGUuX25vdFtpbmRleDBdID0gW2FkZHJlc3MwLCB0aGlzLl9vZmZzZXRdO1xuICAgICAgcmV0dXJuIGFkZHJlc3MwO1xuICAgIH0sXG5cbiAgICBfcmVhZF9zcHJpdGUgKCkge1xuICAgICAgdmFyIGFkZHJlc3MwID0gRkFJTFVSRSwgaW5kZXgwID0gdGhpcy5fb2Zmc2V0O1xuICAgICAgdGhpcy5fY2FjaGUuX3Nwcml0ZSA9IHRoaXMuX2NhY2hlLl9zcHJpdGUgfHwge307XG4gICAgICB2YXIgY2FjaGVkID0gdGhpcy5fY2FjaGUuX3Nwcml0ZVtpbmRleDBdO1xuICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSBjYWNoZWRbMV07XG4gICAgICAgIHJldHVybiBjYWNoZWRbMF07XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXgxID0gdGhpcy5fb2Zmc2V0O1xuICAgICAgdmFyIGNodW5rMCA9IG51bGwsIG1heDAgPSB0aGlzLl9vZmZzZXQgKyA1O1xuICAgICAgaWYgKG1heDAgPD0gdGhpcy5faW5wdXRTaXplKSB7XG4gICAgICAgIGNodW5rMCA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyh0aGlzLl9vZmZzZXQsIG1heDApO1xuICAgICAgfVxuICAgICAgaWYgKGNodW5rMCA9PT0gJ3BhcmVkJykge1xuICAgICAgICBhZGRyZXNzMCA9IG5ldyBUcmVlTm9kZSh0aGlzLl9pbnB1dC5zdWJzdHJpbmcodGhpcy5fb2Zmc2V0LCB0aGlzLl9vZmZzZXQgKyA1KSwgdGhpcy5fb2Zmc2V0LCBbXSk7XG4gICAgICAgIHRoaXMuX29mZnNldCA9IHRoaXMuX29mZnNldCArIDU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRyZXNzMCA9IEZBSUxVUkU7XG4gICAgICAgIGlmICh0aGlzLl9vZmZzZXQgPiB0aGlzLl9mYWlsdXJlKSB7XG4gICAgICAgICAgdGhpcy5fZmFpbHVyZSA9IHRoaXMuX29mZnNldDtcbiAgICAgICAgICB0aGlzLl9leHBlY3RlZCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9vZmZzZXQgPT09IHRoaXMuX2ZhaWx1cmUpIHtcbiAgICAgICAgICB0aGlzLl9leHBlY3RlZC5wdXNoKFsnU2lEaUxhOjpzcHJpdGUnLCAnXFwncGFyZWRcXCcnXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhZGRyZXNzMCA9PT0gRkFJTFVSRSkge1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbmRleDE7XG4gICAgICAgIHZhciBjaHVuazEgPSBudWxsLCBtYXgxID0gdGhpcy5fb2Zmc2V0ICsgNDtcbiAgICAgICAgaWYgKG1heDEgPD0gdGhpcy5faW5wdXRTaXplKSB7XG4gICAgICAgICAgY2h1bmsxID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKHRoaXMuX29mZnNldCwgbWF4MSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNodW5rMSA9PT0gJ2FsZ28nKSB7XG4gICAgICAgICAgYWRkcmVzczAgPSBuZXcgVHJlZU5vZGUodGhpcy5faW5wdXQuc3Vic3RyaW5nKHRoaXMuX29mZnNldCwgdGhpcy5fb2Zmc2V0ICsgNCksIHRoaXMuX29mZnNldCwgW10pO1xuICAgICAgICAgIHRoaXMuX29mZnNldCA9IHRoaXMuX29mZnNldCArIDQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkcmVzczAgPSBGQUlMVVJFO1xuICAgICAgICAgIGlmICh0aGlzLl9vZmZzZXQgPiB0aGlzLl9mYWlsdXJlKSB7XG4gICAgICAgICAgICB0aGlzLl9mYWlsdXJlID0gdGhpcy5fb2Zmc2V0O1xuICAgICAgICAgICAgdGhpcy5fZXhwZWN0ZWQgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuX29mZnNldCA9PT0gdGhpcy5fZmFpbHVyZSkge1xuICAgICAgICAgICAgdGhpcy5fZXhwZWN0ZWQucHVzaChbJ1NpRGlMYTo6c3ByaXRlJywgJ1xcJ2FsZ29cXCcnXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhZGRyZXNzMCA9PT0gRkFJTFVSRSkge1xuICAgICAgICAgIHRoaXMuX29mZnNldCA9IGluZGV4MTtcbiAgICAgICAgICB2YXIgY2h1bmsyID0gbnVsbCwgbWF4MiA9IHRoaXMuX29mZnNldCArIDY7XG4gICAgICAgICAgaWYgKG1heDIgPD0gdGhpcy5faW5wdXRTaXplKSB7XG4gICAgICAgICAgICBjaHVuazIgPSB0aGlzLl9pbnB1dC5zdWJzdHJpbmcodGhpcy5fb2Zmc2V0LCBtYXgyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNodW5rMiA9PT0gJ3pvbWJpZScpIHtcbiAgICAgICAgICAgIGFkZHJlc3MwID0gbmV3IFRyZWVOb2RlKHRoaXMuX2lucHV0LnN1YnN0cmluZyh0aGlzLl9vZmZzZXQsIHRoaXMuX29mZnNldCArIDYpLCB0aGlzLl9vZmZzZXQsIFtdKTtcbiAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IHRoaXMuX29mZnNldCArIDY7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZHJlc3MwID0gRkFJTFVSRTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vZmZzZXQgPiB0aGlzLl9mYWlsdXJlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2ZhaWx1cmUgPSB0aGlzLl9vZmZzZXQ7XG4gICAgICAgICAgICAgIHRoaXMuX2V4cGVjdGVkID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fb2Zmc2V0ID09PSB0aGlzLl9mYWlsdXJlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2V4cGVjdGVkLnB1c2goWydTaURpTGE6OnNwcml0ZScsICdcXCd6b21iaWVcXCcnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhZGRyZXNzMCA9PT0gRkFJTFVSRSkge1xuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5kZXgxO1xuICAgICAgICAgICAgdmFyIGNodW5rMyA9IG51bGwsIG1heDMgPSB0aGlzLl9vZmZzZXQgKyA3O1xuICAgICAgICAgICAgaWYgKG1heDMgPD0gdGhpcy5faW5wdXRTaXplKSB7XG4gICAgICAgICAgICAgIGNodW5rMyA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyh0aGlzLl9vZmZzZXQsIG1heDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNodW5rMyA9PT0gJ2VzcGFjaW8nKSB7XG4gICAgICAgICAgICAgIGFkZHJlc3MwID0gbmV3IFRyZWVOb2RlKHRoaXMuX2lucHV0LnN1YnN0cmluZyh0aGlzLl9vZmZzZXQsIHRoaXMuX29mZnNldCArIDcpLCB0aGlzLl9vZmZzZXQsIFtdKTtcbiAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0ICsgNztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFkZHJlc3MwID0gRkFJTFVSRTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX29mZnNldCA+IHRoaXMuX2ZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mYWlsdXJlID0gdGhpcy5fb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2V4cGVjdGVkID0gW107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRoaXMuX29mZnNldCA9PT0gdGhpcy5fZmFpbHVyZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2V4cGVjdGVkLnB1c2goWydTaURpTGE6OnNwcml0ZScsICdcXCdlc3BhY2lvXFwnJ10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWRkcmVzczAgPT09IEZBSUxVUkUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5kZXgxO1xuICAgICAgICAgICAgICB2YXIgY2h1bms0ID0gbnVsbCwgbWF4NCA9IHRoaXMuX29mZnNldCArIDY7XG4gICAgICAgICAgICAgIGlmIChtYXg0IDw9IHRoaXMuX2lucHV0U2l6ZSkge1xuICAgICAgICAgICAgICAgIGNodW5rNCA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyh0aGlzLl9vZmZzZXQsIG1heDQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjaHVuazQgPT09ICdzYWxpZGEnKSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzczAgPSBuZXcgVHJlZU5vZGUodGhpcy5faW5wdXQuc3Vic3RyaW5nKHRoaXMuX29mZnNldCwgdGhpcy5fb2Zmc2V0ICsgNiksIHRoaXMuX29mZnNldCwgW10pO1xuICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IHRoaXMuX29mZnNldCArIDY7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzczAgPSBGQUlMVVJFO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vZmZzZXQgPiB0aGlzLl9mYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9mYWlsdXJlID0gdGhpcy5fb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgdGhpcy5fZXhwZWN0ZWQgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29mZnNldCA9PT0gdGhpcy5fZmFpbHVyZSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fZXhwZWN0ZWQucHVzaChbJ1NpRGlMYTo6c3ByaXRlJywgJ1xcJ3NhbGlkYVxcJyddKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGFkZHJlc3MwID09PSBGQUlMVVJFKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5kZXgxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9jYWNoZS5fc3ByaXRlW2luZGV4MF0gPSBbYWRkcmVzczAsIHRoaXMuX29mZnNldF07XG4gICAgICByZXR1cm4gYWRkcmVzczA7XG4gICAgfSxcblxuICAgIF9yZWFkX2xvb2tfdXBfZGlyZWN0aW9uICgpIHtcbiAgICAgIHZhciBhZGRyZXNzMCA9IEZBSUxVUkUsIGluZGV4MCA9IHRoaXMuX29mZnNldDtcbiAgICAgIHRoaXMuX2NhY2hlLl9sb29rX3VwX2RpcmVjdGlvbiA9IHRoaXMuX2NhY2hlLl9sb29rX3VwX2RpcmVjdGlvbiB8fCB7fTtcbiAgICAgIHZhciBjYWNoZWQgPSB0aGlzLl9jYWNoZS5fbG9va191cF9kaXJlY3Rpb25baW5kZXgwXTtcbiAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gY2FjaGVkWzFdO1xuICAgICAgICByZXR1cm4gY2FjaGVkWzBdO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4MSA9IHRoaXMuX29mZnNldDtcbiAgICAgIHZhciBjaHVuazAgPSBudWxsLCBtYXgwID0gdGhpcy5fb2Zmc2V0ICsgODtcbiAgICAgIGlmIChtYXgwIDw9IHRoaXMuX2lucHV0U2l6ZSkge1xuICAgICAgICBjaHVuazAgPSB0aGlzLl9pbnB1dC5zdWJzdHJpbmcodGhpcy5fb2Zmc2V0LCBtYXgwKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaHVuazAgPT09ICdhZGVsYW50ZScpIHtcbiAgICAgICAgYWRkcmVzczAgPSBuZXcgVHJlZU5vZGUodGhpcy5faW5wdXQuc3Vic3RyaW5nKHRoaXMuX29mZnNldCwgdGhpcy5fb2Zmc2V0ICsgOCksIHRoaXMuX29mZnNldCwgW10pO1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSB0aGlzLl9vZmZzZXQgKyA4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkcmVzczAgPSBGQUlMVVJFO1xuICAgICAgICBpZiAodGhpcy5fb2Zmc2V0ID4gdGhpcy5fZmFpbHVyZSkge1xuICAgICAgICAgIHRoaXMuX2ZhaWx1cmUgPSB0aGlzLl9vZmZzZXQ7XG4gICAgICAgICAgdGhpcy5fZXhwZWN0ZWQgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fb2Zmc2V0ID09PSB0aGlzLl9mYWlsdXJlKSB7XG4gICAgICAgICAgdGhpcy5fZXhwZWN0ZWQucHVzaChbJ1NpRGlMYTo6bG9va191cF9kaXJlY3Rpb24nLCAnXFwnYWRlbGFudGVcXCcnXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhZGRyZXNzMCA9PT0gRkFJTFVSRSkge1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbmRleDE7XG4gICAgICAgIHZhciBjaHVuazEgPSBudWxsLCBtYXgxID0gdGhpcy5fb2Zmc2V0ICsgMTQ7XG4gICAgICAgIGlmIChtYXgxIDw9IHRoaXMuX2lucHV0U2l6ZSkge1xuICAgICAgICAgIGNodW5rMSA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyh0aGlzLl9vZmZzZXQsIG1heDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaHVuazEgPT09ICdhIGxhIGl6cXVpZXJkYScpIHtcbiAgICAgICAgICBhZGRyZXNzMCA9IG5ldyBUcmVlTm9kZSh0aGlzLl9pbnB1dC5zdWJzdHJpbmcodGhpcy5fb2Zmc2V0LCB0aGlzLl9vZmZzZXQgKyAxNCksIHRoaXMuX29mZnNldCwgW10pO1xuICAgICAgICAgIHRoaXMuX29mZnNldCA9IHRoaXMuX29mZnNldCArIDE0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZHJlc3MwID0gRkFJTFVSRTtcbiAgICAgICAgICBpZiAodGhpcy5fb2Zmc2V0ID4gdGhpcy5fZmFpbHVyZSkge1xuICAgICAgICAgICAgdGhpcy5fZmFpbHVyZSA9IHRoaXMuX29mZnNldDtcbiAgICAgICAgICAgIHRoaXMuX2V4cGVjdGVkID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLl9vZmZzZXQgPT09IHRoaXMuX2ZhaWx1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2V4cGVjdGVkLnB1c2goWydTaURpTGE6Omxvb2tfdXBfZGlyZWN0aW9uJywgJ1xcJ2EgbGEgaXpxdWllcmRhXFwnJ10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWRkcmVzczAgPT09IEZBSUxVUkUpIHtcbiAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbmRleDE7XG4gICAgICAgICAgdmFyIGNodW5rMiA9IG51bGwsIG1heDIgPSB0aGlzLl9vZmZzZXQgKyAxMjtcbiAgICAgICAgICBpZiAobWF4MiA8PSB0aGlzLl9pbnB1dFNpemUpIHtcbiAgICAgICAgICAgIGNodW5rMiA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyh0aGlzLl9vZmZzZXQsIG1heDIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2h1bmsyID09PSAnYSBsYSBkZXJlY2hhJykge1xuICAgICAgICAgICAgYWRkcmVzczAgPSBuZXcgVHJlZU5vZGUodGhpcy5faW5wdXQuc3Vic3RyaW5nKHRoaXMuX29mZnNldCwgdGhpcy5fb2Zmc2V0ICsgMTIpLCB0aGlzLl9vZmZzZXQsIFtdKTtcbiAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IHRoaXMuX29mZnNldCArIDEyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGRyZXNzMCA9IEZBSUxVUkU7XG4gICAgICAgICAgICBpZiAodGhpcy5fb2Zmc2V0ID4gdGhpcy5fZmFpbHVyZSkge1xuICAgICAgICAgICAgICB0aGlzLl9mYWlsdXJlID0gdGhpcy5fb2Zmc2V0O1xuICAgICAgICAgICAgICB0aGlzLl9leHBlY3RlZCA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX29mZnNldCA9PT0gdGhpcy5fZmFpbHVyZSkge1xuICAgICAgICAgICAgICB0aGlzLl9leHBlY3RlZC5wdXNoKFsnU2lEaUxhOjpsb29rX3VwX2RpcmVjdGlvbicsICdcXCdhIGxhIGRlcmVjaGFcXCcnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhZGRyZXNzMCA9PT0gRkFJTFVSRSkge1xuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5kZXgxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fY2FjaGUuX2xvb2tfdXBfZGlyZWN0aW9uW2luZGV4MF0gPSBbYWRkcmVzczAsIHRoaXMuX29mZnNldF07XG4gICAgICByZXR1cm4gYWRkcmVzczA7XG4gICAgfSxcblxuICAgIF9yZWFkX21vdmUgKCkge1xuICAgICAgdmFyIGFkZHJlc3MwID0gRkFJTFVSRSwgaW5kZXgwID0gdGhpcy5fb2Zmc2V0O1xuICAgICAgdGhpcy5fY2FjaGUuX21vdmUgPSB0aGlzLl9jYWNoZS5fbW92ZSB8fCB7fTtcbiAgICAgIHZhciBjYWNoZWQgPSB0aGlzLl9jYWNoZS5fbW92ZVtpbmRleDBdO1xuICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSBjYWNoZWRbMV07XG4gICAgICAgIHJldHVybiBjYWNoZWRbMF07XG4gICAgICB9XG4gICAgICB2YXIgY2h1bmswID0gbnVsbCwgbWF4MCA9IHRoaXMuX29mZnNldCArIDc7XG4gICAgICBpZiAobWF4MCA8PSB0aGlzLl9pbnB1dFNpemUpIHtcbiAgICAgICAgY2h1bmswID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKHRoaXMuX29mZnNldCwgbWF4MCk7XG4gICAgICB9XG4gICAgICBpZiAoY2h1bmswID09PSAnYXZhbnphcicpIHtcbiAgICAgICAgYWRkcmVzczAgPSB0aGlzLl9hY3Rpb25zLm1ha2VNb3ZlKHRoaXMuX2lucHV0LCB0aGlzLl9vZmZzZXQsIHRoaXMuX29mZnNldCArIDcsIFtdKTtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0ICsgNztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZHJlc3MwID0gRkFJTFVSRTtcbiAgICAgICAgaWYgKHRoaXMuX29mZnNldCA+IHRoaXMuX2ZhaWx1cmUpIHtcbiAgICAgICAgICB0aGlzLl9mYWlsdXJlID0gdGhpcy5fb2Zmc2V0O1xuICAgICAgICAgIHRoaXMuX2V4cGVjdGVkID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX29mZnNldCA9PT0gdGhpcy5fZmFpbHVyZSkge1xuICAgICAgICAgIHRoaXMuX2V4cGVjdGVkLnB1c2goWydTaURpTGE6Om1vdmUnLCAnXFwnYXZhbnphclxcJyddKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fY2FjaGUuX21vdmVbaW5kZXgwXSA9IFthZGRyZXNzMCwgdGhpcy5fb2Zmc2V0XTtcbiAgICAgIHJldHVybiBhZGRyZXNzMDtcbiAgICB9LFxuXG4gICAgX3JlYWRfYmFjayAoKSB7XG4gICAgICB2YXIgYWRkcmVzczAgPSBGQUlMVVJFLCBpbmRleDAgPSB0aGlzLl9vZmZzZXQ7XG4gICAgICB0aGlzLl9jYWNoZS5fYmFjayA9IHRoaXMuX2NhY2hlLl9iYWNrIHx8IHt9O1xuICAgICAgdmFyIGNhY2hlZCA9IHRoaXMuX2NhY2hlLl9iYWNrW2luZGV4MF07XG4gICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgIHRoaXMuX29mZnNldCA9IGNhY2hlZFsxXTtcbiAgICAgICAgcmV0dXJuIGNhY2hlZFswXTtcbiAgICAgIH1cbiAgICAgIHZhciBjaHVuazAgPSBudWxsLCBtYXgwID0gdGhpcy5fb2Zmc2V0ICsgMTA7XG4gICAgICBpZiAobWF4MCA8PSB0aGlzLl9pbnB1dFNpemUpIHtcbiAgICAgICAgY2h1bmswID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKHRoaXMuX29mZnNldCwgbWF4MCk7XG4gICAgICB9XG4gICAgICBpZiAoY2h1bmswID09PSAncmV0cm9jZWRlcicpIHtcbiAgICAgICAgYWRkcmVzczAgPSB0aGlzLl9hY3Rpb25zLm1ha2VCYWNrKHRoaXMuX2lucHV0LCB0aGlzLl9vZmZzZXQsIHRoaXMuX29mZnNldCArIDEwLCBbXSk7XG4gICAgICAgIHRoaXMuX29mZnNldCA9IHRoaXMuX29mZnNldCArIDEwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkcmVzczAgPSBGQUlMVVJFO1xuICAgICAgICBpZiAodGhpcy5fb2Zmc2V0ID4gdGhpcy5fZmFpbHVyZSkge1xuICAgICAgICAgIHRoaXMuX2ZhaWx1cmUgPSB0aGlzLl9vZmZzZXQ7XG4gICAgICAgICAgdGhpcy5fZXhwZWN0ZWQgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fb2Zmc2V0ID09PSB0aGlzLl9mYWlsdXJlKSB7XG4gICAgICAgICAgdGhpcy5fZXhwZWN0ZWQucHVzaChbJ1NpRGlMYTo6YmFjaycsICdcXCdyZXRyb2NlZGVyXFwnJ10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9jYWNoZS5fYmFja1tpbmRleDBdID0gW2FkZHJlc3MwLCB0aGlzLl9vZmZzZXRdO1xuICAgICAgcmV0dXJuIGFkZHJlc3MwO1xuICAgIH0sXG5cbiAgICBfcmVhZF9zaG9vdCAoKSB7XG4gICAgICB2YXIgYWRkcmVzczAgPSBGQUlMVVJFLCBpbmRleDAgPSB0aGlzLl9vZmZzZXQ7XG4gICAgICB0aGlzLl9jYWNoZS5fc2hvb3QgPSB0aGlzLl9jYWNoZS5fc2hvb3QgfHwge307XG4gICAgICB2YXIgY2FjaGVkID0gdGhpcy5fY2FjaGUuX3Nob290W2luZGV4MF07XG4gICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgIHRoaXMuX29mZnNldCA9IGNhY2hlZFsxXTtcbiAgICAgICAgcmV0dXJuIGNhY2hlZFswXTtcbiAgICAgIH1cbiAgICAgIHZhciBjaHVuazAgPSBudWxsLCBtYXgwID0gdGhpcy5fb2Zmc2V0ICsgODtcbiAgICAgIGlmIChtYXgwIDw9IHRoaXMuX2lucHV0U2l6ZSkge1xuICAgICAgICBjaHVuazAgPSB0aGlzLl9pbnB1dC5zdWJzdHJpbmcodGhpcy5fb2Zmc2V0LCBtYXgwKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaHVuazAgPT09ICdkaXNwYXJhcicpIHtcbiAgICAgICAgYWRkcmVzczAgPSB0aGlzLl9hY3Rpb25zLm1ha2VTaG9vdCh0aGlzLl9pbnB1dCwgdGhpcy5fb2Zmc2V0LCB0aGlzLl9vZmZzZXQgKyA4LCBbXSk7XG4gICAgICAgIHRoaXMuX29mZnNldCA9IHRoaXMuX29mZnNldCArIDg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRyZXNzMCA9IEZBSUxVUkU7XG4gICAgICAgIGlmICh0aGlzLl9vZmZzZXQgPiB0aGlzLl9mYWlsdXJlKSB7XG4gICAgICAgICAgdGhpcy5fZmFpbHVyZSA9IHRoaXMuX29mZnNldDtcbiAgICAgICAgICB0aGlzLl9leHBlY3RlZCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9vZmZzZXQgPT09IHRoaXMuX2ZhaWx1cmUpIHtcbiAgICAgICAgICB0aGlzLl9leHBlY3RlZC5wdXNoKFsnU2lEaUxhOjpzaG9vdCcsICdcXCdkaXNwYXJhclxcJyddKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fY2FjaGUuX3Nob290W2luZGV4MF0gPSBbYWRkcmVzczAsIHRoaXMuX29mZnNldF07XG4gICAgICByZXR1cm4gYWRkcmVzczA7XG4gICAgfSxcblxuICAgIF9yZWFkX3R1cm4gKCkge1xuICAgICAgdmFyIGFkZHJlc3MwID0gRkFJTFVSRSwgaW5kZXgwID0gdGhpcy5fb2Zmc2V0O1xuICAgICAgdGhpcy5fY2FjaGUuX3R1cm4gPSB0aGlzLl9jYWNoZS5fdHVybiB8fCB7fTtcbiAgICAgIHZhciBjYWNoZWQgPSB0aGlzLl9jYWNoZS5fdHVybltpbmRleDBdO1xuICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSBjYWNoZWRbMV07XG4gICAgICAgIHJldHVybiBjYWNoZWRbMF07XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXgxID0gdGhpcy5fb2Zmc2V0LCBlbGVtZW50czAgPSBuZXcgQXJyYXkoMik7XG4gICAgICB2YXIgYWRkcmVzczEgPSBGQUlMVVJFO1xuICAgICAgdmFyIGNodW5rMCA9IG51bGwsIG1heDAgPSB0aGlzLl9vZmZzZXQgKyA1O1xuICAgICAgaWYgKG1heDAgPD0gdGhpcy5faW5wdXRTaXplKSB7XG4gICAgICAgIGNodW5rMCA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyh0aGlzLl9vZmZzZXQsIG1heDApO1xuICAgICAgfVxuICAgICAgaWYgKGNodW5rMCA9PT0gJ2dpcmFyJykge1xuICAgICAgICBhZGRyZXNzMSA9IG5ldyBUcmVlTm9kZSh0aGlzLl9pbnB1dC5zdWJzdHJpbmcodGhpcy5fb2Zmc2V0LCB0aGlzLl9vZmZzZXQgKyA1KSwgdGhpcy5fb2Zmc2V0LCBbXSk7XG4gICAgICAgIHRoaXMuX29mZnNldCA9IHRoaXMuX29mZnNldCArIDU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRyZXNzMSA9IEZBSUxVUkU7XG4gICAgICAgIGlmICh0aGlzLl9vZmZzZXQgPiB0aGlzLl9mYWlsdXJlKSB7XG4gICAgICAgICAgdGhpcy5fZmFpbHVyZSA9IHRoaXMuX29mZnNldDtcbiAgICAgICAgICB0aGlzLl9leHBlY3RlZCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9vZmZzZXQgPT09IHRoaXMuX2ZhaWx1cmUpIHtcbiAgICAgICAgICB0aGlzLl9leHBlY3RlZC5wdXNoKFsnU2lEaUxhOjp0dXJuJywgJ1xcJ2dpcmFyXFwnJ10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYWRkcmVzczEgIT09IEZBSUxVUkUpIHtcbiAgICAgICAgZWxlbWVudHMwWzBdID0gYWRkcmVzczE7XG4gICAgICAgIHZhciBhZGRyZXNzMiA9IEZBSUxVUkU7XG4gICAgICAgIGFkZHJlc3MyID0gdGhpcy5fcmVhZF93cygpO1xuICAgICAgICBpZiAoYWRkcmVzczIgIT09IEZBSUxVUkUpIHtcbiAgICAgICAgICB2YXIgYWRkcmVzczMgPSBGQUlMVVJFO1xuICAgICAgICAgIHZhciBjaHVuazEgPSBudWxsLCBtYXgxID0gdGhpcy5fb2Zmc2V0ICsgNTtcbiAgICAgICAgICBpZiAobWF4MSA8PSB0aGlzLl9pbnB1dFNpemUpIHtcbiAgICAgICAgICAgIGNodW5rMSA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyh0aGlzLl9vZmZzZXQsIG1heDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2h1bmsxID09PSAnaGFjaWEnKSB7XG4gICAgICAgICAgICBhZGRyZXNzMyA9IG5ldyBUcmVlTm9kZSh0aGlzLl9pbnB1dC5zdWJzdHJpbmcodGhpcy5fb2Zmc2V0LCB0aGlzLl9vZmZzZXQgKyA1KSwgdGhpcy5fb2Zmc2V0LCBbXSk7XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSB0aGlzLl9vZmZzZXQgKyA1O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGRyZXNzMyA9IEZBSUxVUkU7XG4gICAgICAgICAgICBpZiAodGhpcy5fb2Zmc2V0ID4gdGhpcy5fZmFpbHVyZSkge1xuICAgICAgICAgICAgICB0aGlzLl9mYWlsdXJlID0gdGhpcy5fb2Zmc2V0O1xuICAgICAgICAgICAgICB0aGlzLl9leHBlY3RlZCA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX29mZnNldCA9PT0gdGhpcy5fZmFpbHVyZSkge1xuICAgICAgICAgICAgICB0aGlzLl9leHBlY3RlZC5wdXNoKFsnU2lEaUxhOjp0dXJuJywgJ1xcJ2hhY2lhXFwnJ10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYWRkcmVzczMgIT09IEZBSUxVUkUpIHtcbiAgICAgICAgICAgIHZhciBhZGRyZXNzNCA9IEZBSUxVUkU7XG4gICAgICAgICAgICBhZGRyZXNzNCA9IHRoaXMuX3JlYWRfd3MoKTtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzNCAhPT0gRkFJTFVSRSkge1xuICAgICAgICAgICAgICB2YXIgYWRkcmVzczUgPSBGQUlMVVJFO1xuICAgICAgICAgICAgICBhZGRyZXNzNSA9IHRoaXMuX3JlYWRfZGlyZWN0aW9uKCk7XG4gICAgICAgICAgICAgIGlmIChhZGRyZXNzNSAhPT0gRkFJTFVSRSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzMFsxXSA9IGFkZHJlc3M1O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzMCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5kZXgxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbGVtZW50czAgPSBudWxsO1xuICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbmRleDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnRzMCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbmRleDE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW1lbnRzMCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5kZXgxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50czAgPSBudWxsO1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbmRleDE7XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudHMwID09PSBudWxsKSB7XG4gICAgICAgIGFkZHJlc3MwID0gRkFJTFVSRTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZHJlc3MwID0gdGhpcy5fYWN0aW9ucy5tYWtlVHVybih0aGlzLl9pbnB1dCwgaW5kZXgxLCB0aGlzLl9vZmZzZXQsIGVsZW1lbnRzMCk7XG4gICAgICAgIHRoaXMuX29mZnNldCA9IHRoaXMuX29mZnNldDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhY2hlLl90dXJuW2luZGV4MF0gPSBbYWRkcmVzczAsIHRoaXMuX29mZnNldF07XG4gICAgICByZXR1cm4gYWRkcmVzczA7XG4gICAgfSxcblxuICAgIF9yZWFkX2RpcmVjdGlvbiAoKSB7XG4gICAgICB2YXIgYWRkcmVzczAgPSBGQUlMVVJFLCBpbmRleDAgPSB0aGlzLl9vZmZzZXQ7XG4gICAgICB0aGlzLl9jYWNoZS5fZGlyZWN0aW9uID0gdGhpcy5fY2FjaGUuX2RpcmVjdGlvbiB8fCB7fTtcbiAgICAgIHZhciBjYWNoZWQgPSB0aGlzLl9jYWNoZS5fZGlyZWN0aW9uW2luZGV4MF07XG4gICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgIHRoaXMuX29mZnNldCA9IGNhY2hlZFsxXTtcbiAgICAgICAgcmV0dXJuIGNhY2hlZFswXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleDEgPSB0aGlzLl9vZmZzZXQ7XG4gICAgICB2YXIgY2h1bmswID0gbnVsbCwgbWF4MCA9IHRoaXMuX29mZnNldCArIDEyO1xuICAgICAgaWYgKG1heDAgPD0gdGhpcy5faW5wdXRTaXplKSB7XG4gICAgICAgIGNodW5rMCA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyh0aGlzLl9vZmZzZXQsIG1heDApO1xuICAgICAgfVxuICAgICAgaWYgKGNodW5rMCA9PT0gJ2xhIGl6cXVpZXJkYScpIHtcbiAgICAgICAgYWRkcmVzczAgPSBuZXcgVHJlZU5vZGUodGhpcy5faW5wdXQuc3Vic3RyaW5nKHRoaXMuX29mZnNldCwgdGhpcy5fb2Zmc2V0ICsgMTIpLCB0aGlzLl9vZmZzZXQsIFtdKTtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0ICsgMTI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRyZXNzMCA9IEZBSUxVUkU7XG4gICAgICAgIGlmICh0aGlzLl9vZmZzZXQgPiB0aGlzLl9mYWlsdXJlKSB7XG4gICAgICAgICAgdGhpcy5fZmFpbHVyZSA9IHRoaXMuX29mZnNldDtcbiAgICAgICAgICB0aGlzLl9leHBlY3RlZCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9vZmZzZXQgPT09IHRoaXMuX2ZhaWx1cmUpIHtcbiAgICAgICAgICB0aGlzLl9leHBlY3RlZC5wdXNoKFsnU2lEaUxhOjpkaXJlY3Rpb24nLCAnXFwnbGEgaXpxdWllcmRhXFwnJ10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYWRkcmVzczAgPT09IEZBSUxVUkUpIHtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5kZXgxO1xuICAgICAgICB2YXIgY2h1bmsxID0gbnVsbCwgbWF4MSA9IHRoaXMuX29mZnNldCArIDEwO1xuICAgICAgICBpZiAobWF4MSA8PSB0aGlzLl9pbnB1dFNpemUpIHtcbiAgICAgICAgICBjaHVuazEgPSB0aGlzLl9pbnB1dC5zdWJzdHJpbmcodGhpcy5fb2Zmc2V0LCBtYXgxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2h1bmsxID09PSAnbGEgZGVyZWNoYScpIHtcbiAgICAgICAgICBhZGRyZXNzMCA9IG5ldyBUcmVlTm9kZSh0aGlzLl9pbnB1dC5zdWJzdHJpbmcodGhpcy5fb2Zmc2V0LCB0aGlzLl9vZmZzZXQgKyAxMCksIHRoaXMuX29mZnNldCwgW10pO1xuICAgICAgICAgIHRoaXMuX29mZnNldCA9IHRoaXMuX29mZnNldCArIDEwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZHJlc3MwID0gRkFJTFVSRTtcbiAgICAgICAgICBpZiAodGhpcy5fb2Zmc2V0ID4gdGhpcy5fZmFpbHVyZSkge1xuICAgICAgICAgICAgdGhpcy5fZmFpbHVyZSA9IHRoaXMuX29mZnNldDtcbiAgICAgICAgICAgIHRoaXMuX2V4cGVjdGVkID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLl9vZmZzZXQgPT09IHRoaXMuX2ZhaWx1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2V4cGVjdGVkLnB1c2goWydTaURpTGE6OmRpcmVjdGlvbicsICdcXCdsYSBkZXJlY2hhXFwnJ10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWRkcmVzczAgPT09IEZBSUxVUkUpIHtcbiAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbmRleDE7XG4gICAgICAgICAgdmFyIGNodW5rMiA9IG51bGwsIG1heDIgPSB0aGlzLl9vZmZzZXQgKyA1O1xuICAgICAgICAgIGlmIChtYXgyIDw9IHRoaXMuX2lucHV0U2l6ZSkge1xuICAgICAgICAgICAgY2h1bmsyID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKHRoaXMuX29mZnNldCwgbWF4Mik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaHVuazIgPT09ICdhdHJhcycpIHtcbiAgICAgICAgICAgIGFkZHJlc3MwID0gbmV3IFRyZWVOb2RlKHRoaXMuX2lucHV0LnN1YnN0cmluZyh0aGlzLl9vZmZzZXQsIHRoaXMuX29mZnNldCArIDUpLCB0aGlzLl9vZmZzZXQsIFtdKTtcbiAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IHRoaXMuX29mZnNldCArIDU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZHJlc3MwID0gRkFJTFVSRTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vZmZzZXQgPiB0aGlzLl9mYWlsdXJlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2ZhaWx1cmUgPSB0aGlzLl9vZmZzZXQ7XG4gICAgICAgICAgICAgIHRoaXMuX2V4cGVjdGVkID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fb2Zmc2V0ID09PSB0aGlzLl9mYWlsdXJlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2V4cGVjdGVkLnB1c2goWydTaURpTGE6OmRpcmVjdGlvbicsICdcXCdhdHJhc1xcJyddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFkZHJlc3MwID09PSBGQUlMVVJFKSB7XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbmRleDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9jYWNoZS5fZGlyZWN0aW9uW2luZGV4MF0gPSBbYWRkcmVzczAsIHRoaXMuX29mZnNldF07XG4gICAgICByZXR1cm4gYWRkcmVzczA7XG4gICAgfSxcblxuICAgIF9yZWFkX3dzICgpIHtcbiAgICAgIHZhciBhZGRyZXNzMCA9IEZBSUxVUkUsIGluZGV4MCA9IHRoaXMuX29mZnNldDtcbiAgICAgIHRoaXMuX2NhY2hlLl93cyA9IHRoaXMuX2NhY2hlLl93cyB8fCB7fTtcbiAgICAgIHZhciBjYWNoZWQgPSB0aGlzLl9jYWNoZS5fd3NbaW5kZXgwXTtcbiAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gY2FjaGVkWzFdO1xuICAgICAgICByZXR1cm4gY2FjaGVkWzBdO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4MSA9IHRoaXMuX29mZnNldCwgZWxlbWVudHMwID0gW10sIGFkZHJlc3MxID0gbnVsbDtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBpbmRleDIgPSB0aGlzLl9vZmZzZXQsIGVsZW1lbnRzMSA9IFtdLCBhZGRyZXNzMiA9IG51bGw7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgdmFyIGNodW5rMCA9IG51bGwsIG1heDAgPSB0aGlzLl9vZmZzZXQgKyAxO1xuICAgICAgICAgIGlmIChtYXgwIDw9IHRoaXMuX2lucHV0U2l6ZSkge1xuICAgICAgICAgICAgY2h1bmswID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKHRoaXMuX29mZnNldCwgbWF4MCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaHVuazAgIT09IG51bGwgJiYgL15bIFxcdF0vLnRlc3QoY2h1bmswKSkge1xuICAgICAgICAgICAgYWRkcmVzczIgPSBuZXcgVHJlZU5vZGUodGhpcy5faW5wdXQuc3Vic3RyaW5nKHRoaXMuX29mZnNldCwgdGhpcy5fb2Zmc2V0ICsgMSksIHRoaXMuX29mZnNldCwgW10pO1xuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0ICsgMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRkcmVzczIgPSBGQUlMVVJFO1xuICAgICAgICAgICAgaWYgKHRoaXMuX29mZnNldCA+IHRoaXMuX2ZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZmFpbHVyZSA9IHRoaXMuX29mZnNldDtcbiAgICAgICAgICAgICAgdGhpcy5fZXhwZWN0ZWQgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9vZmZzZXQgPT09IHRoaXMuX2ZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZXhwZWN0ZWQucHVzaChbJ1NpRGlMYTo6d3MnLCAnWyBcXFxcdF0nXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhZGRyZXNzMiAhPT0gRkFJTFVSRSkge1xuICAgICAgICAgICAgZWxlbWVudHMxLnB1c2goYWRkcmVzczIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnRzMS5sZW5ndGggPj0gMSkge1xuICAgICAgICAgIGFkZHJlc3MxID0gbmV3IFRyZWVOb2RlKHRoaXMuX2lucHV0LnN1YnN0cmluZyhpbmRleDIsIHRoaXMuX29mZnNldCksIGluZGV4MiwgZWxlbWVudHMxKTtcbiAgICAgICAgICB0aGlzLl9vZmZzZXQgPSB0aGlzLl9vZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkcmVzczEgPSBGQUlMVVJFO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZGRyZXNzMSAhPT0gRkFJTFVSRSkge1xuICAgICAgICAgIGVsZW1lbnRzMC5wdXNoKGFkZHJlc3MxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnRzMC5sZW5ndGggPj0gMCkge1xuICAgICAgICBhZGRyZXNzMCA9IG5ldyBUcmVlTm9kZSh0aGlzLl9pbnB1dC5zdWJzdHJpbmcoaW5kZXgxLCB0aGlzLl9vZmZzZXQpLCBpbmRleDEsIGVsZW1lbnRzMCk7XG4gICAgICAgIHRoaXMuX29mZnNldCA9IHRoaXMuX29mZnNldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZHJlc3MwID0gRkFJTFVSRTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhY2hlLl93c1tpbmRleDBdID0gW2FkZHJlc3MwLCB0aGlzLl9vZmZzZXRdO1xuICAgICAgcmV0dXJuIGFkZHJlc3MwO1xuICAgIH0sXG5cbiAgICBfcmVhZF9ubCAoKSB7XG4gICAgICB2YXIgYWRkcmVzczAgPSBGQUlMVVJFLCBpbmRleDAgPSB0aGlzLl9vZmZzZXQ7XG4gICAgICB0aGlzLl9jYWNoZS5fbmwgPSB0aGlzLl9jYWNoZS5fbmwgfHwge307XG4gICAgICB2YXIgY2FjaGVkID0gdGhpcy5fY2FjaGUuX25sW2luZGV4MF07XG4gICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgIHRoaXMuX29mZnNldCA9IGNhY2hlZFsxXTtcbiAgICAgICAgcmV0dXJuIGNhY2hlZFswXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleDEgPSB0aGlzLl9vZmZzZXQsIGVsZW1lbnRzMCA9IFtdLCBhZGRyZXNzMSA9IG51bGw7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgaW5kZXgyID0gdGhpcy5fb2Zmc2V0LCBlbGVtZW50czEgPSBbXSwgYWRkcmVzczIgPSBudWxsO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIHZhciBjaHVuazAgPSBudWxsLCBtYXgwID0gdGhpcy5fb2Zmc2V0ICsgMTtcbiAgICAgICAgICBpZiAobWF4MCA8PSB0aGlzLl9pbnB1dFNpemUpIHtcbiAgICAgICAgICAgIGNodW5rMCA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyh0aGlzLl9vZmZzZXQsIG1heDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2h1bmswICE9PSBudWxsICYmIC9eW1xcclxcbl0vLnRlc3QoY2h1bmswKSkge1xuICAgICAgICAgICAgYWRkcmVzczIgPSBuZXcgVHJlZU5vZGUodGhpcy5faW5wdXQuc3Vic3RyaW5nKHRoaXMuX29mZnNldCwgdGhpcy5fb2Zmc2V0ICsgMSksIHRoaXMuX29mZnNldCwgW10pO1xuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0ICsgMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRkcmVzczIgPSBGQUlMVVJFO1xuICAgICAgICAgICAgaWYgKHRoaXMuX29mZnNldCA+IHRoaXMuX2ZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZmFpbHVyZSA9IHRoaXMuX29mZnNldDtcbiAgICAgICAgICAgICAgdGhpcy5fZXhwZWN0ZWQgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9vZmZzZXQgPT09IHRoaXMuX2ZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZXhwZWN0ZWQucHVzaChbJ1NpRGlMYTo6bmwnLCAnW1xcXFxyXFxcXG5dJ10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYWRkcmVzczIgIT09IEZBSUxVUkUpIHtcbiAgICAgICAgICAgIGVsZW1lbnRzMS5wdXNoKGFkZHJlc3MyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50czEubGVuZ3RoID49IDEpIHtcbiAgICAgICAgICBhZGRyZXNzMSA9IG5ldyBUcmVlTm9kZSh0aGlzLl9pbnB1dC5zdWJzdHJpbmcoaW5kZXgyLCB0aGlzLl9vZmZzZXQpLCBpbmRleDIsIGVsZW1lbnRzMSk7XG4gICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZHJlc3MxID0gRkFJTFVSRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWRkcmVzczEgIT09IEZBSUxVUkUpIHtcbiAgICAgICAgICBlbGVtZW50czAucHVzaChhZGRyZXNzMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50czAubGVuZ3RoID49IDApIHtcbiAgICAgICAgYWRkcmVzczAgPSBuZXcgVHJlZU5vZGUodGhpcy5faW5wdXQuc3Vic3RyaW5nKGluZGV4MSwgdGhpcy5fb2Zmc2V0KSwgaW5kZXgxLCBlbGVtZW50czApO1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSB0aGlzLl9vZmZzZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRyZXNzMCA9IEZBSUxVUkU7XG4gICAgICB9XG4gICAgICB0aGlzLl9jYWNoZS5fbmxbaW5kZXgwXSA9IFthZGRyZXNzMCwgdGhpcy5fb2Zmc2V0XTtcbiAgICAgIHJldHVybiBhZGRyZXNzMDtcbiAgICB9XG4gIH07XG5cbiAgdmFyIFBhcnNlciA9IGZ1bmN0aW9uKGlucHV0LCBhY3Rpb25zLCB0eXBlcykge1xuICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG4gICAgdGhpcy5faW5wdXRTaXplID0gaW5wdXQubGVuZ3RoO1xuICAgIHRoaXMuX2FjdGlvbnMgPSBhY3Rpb25zO1xuICAgIHRoaXMuX3R5cGVzID0gdHlwZXM7XG4gICAgdGhpcy5fb2Zmc2V0ID0gMDtcbiAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgIHRoaXMuX2ZhaWx1cmUgPSAwO1xuICAgIHRoaXMuX2V4cGVjdGVkID0gW107XG4gIH07XG5cbiAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0cmVlID0gdGhpcy5fcmVhZF9ib2R5KCk7XG4gICAgaWYgKHRyZWUgIT09IEZBSUxVUkUgJiYgdGhpcy5fb2Zmc2V0ID09PSB0aGlzLl9pbnB1dFNpemUpIHtcbiAgICAgIHJldHVybiB0cmVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZXhwZWN0ZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLl9mYWlsdXJlID0gdGhpcy5fb2Zmc2V0O1xuICAgICAgdGhpcy5fZXhwZWN0ZWQucHVzaChbJ1NpRGlMYScsICc8RU9GPiddKTtcbiAgICB9XG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5sYXN0RXJyb3IgPSB7IG9mZnNldDogdGhpcy5fb2Zmc2V0LCBleHBlY3RlZDogdGhpcy5fZXhwZWN0ZWQgfTtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoZm9ybWF0RXJyb3IodGhpcy5faW5wdXQsIHRoaXMuX2ZhaWx1cmUsIHRoaXMuX2V4cGVjdGVkKSk7XG4gIH07XG5cbiAgT2JqZWN0LmFzc2lnbihQYXJzZXIucHJvdG90eXBlLCBHcmFtbWFyKTtcblxuXG4gIGZ1bmN0aW9uIHBhcnNlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIoaW5wdXQsIG9wdGlvbnMuYWN0aW9ucywgb3B0aW9ucy50eXBlcyk7XG4gICAgcmV0dXJuIHBhcnNlci5wYXJzZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0RXJyb3IoaW5wdXQsIG9mZnNldCwgZXhwZWN0ZWQpIHtcbiAgICB2YXIgbGluZXMgPSBpbnB1dC5zcGxpdCgvXFxuL2cpLFxuICAgICAgICBsaW5lTm8gPSAwLFxuICAgICAgICBwb3NpdGlvbiA9IDA7XG5cbiAgICB3aGlsZSAocG9zaXRpb24gPD0gb2Zmc2V0KSB7XG4gICAgICBwb3NpdGlvbiArPSBsaW5lc1tsaW5lTm9dLmxlbmd0aCArIDE7XG4gICAgICBsaW5lTm8gKz0gMTtcbiAgICB9XG5cbiAgICB2YXIgbGluZSA9IGxpbmVzW2xpbmVObyAtIDFdLFxuICAgICAgICBtZXNzYWdlID0gJ0xpbmUgJyArIGxpbmVObyArICc6IGV4cGVjdGVkIG9uZSBvZjpcXG5cXG4nO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgbWVzc2FnZSArPSAnICAgIC0gJyArIGV4cGVjdGVkW2ldWzFdICsgJyBmcm9tICcgKyBleHBlY3RlZFtpXVswXSArICdcXG4nO1xuICAgIH1cbiAgICB2YXIgbnVtYmVyID0gbGluZU5vLnRvU3RyaW5nKCk7XG4gICAgd2hpbGUgKG51bWJlci5sZW5ndGggPCA2KSBudW1iZXIgPSAnICcgKyBudW1iZXI7XG4gICAgbWVzc2FnZSArPSAnXFxuJyArIG51bWJlciArICcgfCAnICsgbGluZSArICdcXG4nO1xuXG4gICAgcG9zaXRpb24gLT0gbGluZS5sZW5ndGggKyAxMDtcblxuICAgIHdoaWxlIChwb3NpdGlvbiA8IG9mZnNldCkge1xuICAgICAgbWVzc2FnZSArPSAnICc7XG4gICAgICBwb3NpdGlvbiArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZSArICdeJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaGVyaXQoc3ViY2xhc3MsIHBhcmVudCkge1xuICAgIGZ1bmN0aW9uIGNoYWluICgpIHt9O1xuICAgIGNoYWluLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgc3ViY2xhc3MucHJvdG90eXBlID0gbmV3IGNoYWluKCk7XG4gICAgc3ViY2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViY2xhc3M7XG4gIH1cblxuXG4gIHZhciBleHBvcnRlZCA9IHsgR3JhbW1hcjogR3JhbW1hciwgUGFyc2VyOiBQYXJzZXIsIHBhcnNlOiBwYXJzZSB9O1xuXG4gIGlmICh0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBPYmplY3QuYXNzaWduKGV4cG9ydHMsIGV4cG9ydGVkKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbnMgPSAodHlwZW9mIHRoaXMgPT09ICd1bmRlZmluZWQnKSA/IHdpbmRvdyA6IHRoaXM7XG4gICAgbnMuU2lEaUxhID0gZXhwb3J0ZWQ7XG4gIH1cbn0pKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///498\n")},43:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"CanvasPainter\": () => (/* reexport */ CanvasPainter),\n  \"CodeMirrorHelper\": () => (/* reexport */ CodeMirrorHelper),\n  \"Control\": () => (/* reexport */ Control),\n  \"EditorBoard\": () => (/* reexport */ EditorBoard),\n  \"GameBoard\": () => (/* reexport */ GameBoard),\n  \"GameResult\": () => (/* reexport */ GameResult),\n  \"PalettePainter\": () => (/* reexport */ PalettePainter),\n  \"ProgramListDropDownHandler\": () => (/* reexport */ ProgramListDropDownHandler),\n  \"Storage\": () => (/* reexport */ Storage),\n  \"parse\": () => (/* reexport */ parse)\n});\n\n;// CONCATENATED MODULE: ./src/util/grid-coordinates.js\nclass GridCoordinatesTranslator {\r\n  constructor(width, height) {\r\n    this.width = width;\r\n    this.height = height;\r\n    this.maxIndex = (width * height) - 1;\r\n  }\r\n\r\n  getSlotIndexFor(x, y) {\r\n    if (x > this.width - 1 || y > this.height - 1) {\r\n      throw new Error(`Coordinates out of bound: ${x},${y}`);\r\n    }\r\n    return x + y * this.width;\r\n  }\r\n\r\n  getCoordinatesFor(index) {\r\n    if (index > this.maxIndex) {\r\n      throw new Error(`Index out of bound: ${index}`);\r\n    }\r\n    return {\r\n      x: index % this.width,\r\n      y: Math.floor(index / this.width)\r\n    }\r\n  }\r\n}\n;// CONCATENATED MODULE: ./src/game/animation.js\nclass AnimationService {\r\n  constructor(animations, eventBus) {\r\n    this.animations = {};\r\n    for (const location in animations) {\r\n      if (Object.hasOwnProperty.call(animations, location)) {\r\n        this.animations[location] = AnimationService.createAnimationFromSettings(animations[location], eventBus);\r\n      }\r\n    }\r\n  }\r\n\r\n  getSprite(x, y, timestamp) {\r\n    return this.getAnimationAt(x, y)?.getSprite(timestamp);\r\n  }\r\n\r\n  getAnimationAt(x, y) {\r\n    const location = `${x},${y}`;\r\n    if (Object.hasOwnProperty.call(this.animations, location)) {\r\n      return this.animations[location];\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  trigger(x, y) {\r\n    const animation = this.getAnimationAt(x, y);\r\n    if ((animation !== undefined) && (animation instanceof TwoWaysAnimation)) {\r\n      animation.launch();\r\n    }\r\n  }\r\n\r\n  static createAnimationFromSettings(animation, eventBus) {\r\n    switch(animation.type) {\r\n      case 'loop': return new LoopAnimation(animation.settings, eventBus);\r\n      case 'two-ways': return new TwoWaysAnimation(animation.settings, eventBus);\r\n    }\r\n  }\r\n}\r\n\r\nclass LoopAnimation {\r\n  constructor(settings, eventBus) {\r\n    this.settings = settings;\r\n    this.loopLimit = settings.sprites.length * settings.period;\r\n  }\r\n\r\n  getSprite(timestamp) {\r\n    this.advanceTime(timestamp);\r\n    return this.settings.sprites[this.getIndexForCurrentTimestamp()];\r\n  }\r\n\r\n  advanceTime(timestamp) {\r\n    this.currentTimestamp = timestamp;\r\n  }\r\n\r\n  getIndexForCurrentTimestamp() {\r\n    return Math.floor(this.currentTimestamp / this.settings.period) % this.settings.sprites.length;\r\n  }\r\n}\r\n\r\nclass TwoWaysAnimation {\r\n  constructor(settings, eventBus) {\r\n    this.baseAnimation = new LoopAnimation(settings);\r\n    this.alternateTimestamp = 0;\r\n    this.animationRunning = false;\r\n    this.animationForward = true;\r\n    if (settings.subscribe !== undefined) {\r\n      eventBus.subscribe(settings.subscribe, () => this.launch());\r\n    }\r\n  }\r\n\r\n  launch() {\r\n    this.animationRunning = true;\r\n  }\r\n\r\n  getSprite(timestamp) {\r\n    this.advanceTime(timestamp);\r\n    return this.baseAnimation.getSprite(this.alternateTimestamp);\r\n  }\r\n\r\n  getDelta(timestamp) {\r\n    if (this.previousTimestamp === undefined) {\r\n      this.previousTimestamp = timestamp;\r\n      return 0;\r\n    }\r\n    const delta = timestamp - this.previousTimestamp;\r\n    this.previousTimestamp = timestamp;\r\n    return delta;\r\n  }\r\n\r\n  advanceTime(timestamp) {\r\n    if (this.animationRunning) {\r\n      if (this.animationForward) {\r\n        this.alternateTimestamp += this.getDelta(timestamp);\r\n      } else {\r\n        this.alternateTimestamp -= this.getDelta(timestamp);\r\n      }\r\n      if (this.alternateTimestamp < 0) {\r\n        this.alternateTimestamp = 0;\r\n        this.animationRunning = false;\r\n        this.animationForward = true;\r\n        this.previousTimestamp = undefined;\r\n      } else if (this.alternateTimestamp >= this.baseAnimation.loopLimit) {\r\n        this.alternateTimestamp = this.baseAnimation.loopLimit -1;\r\n        this.animationRunning = false;\r\n        this.animationForward = false;\r\n        this.previousTimestamp = undefined;\r\n      }\r\n    }\r\n  }\r\n}\n;// CONCATENATED MODULE: ./src/game/event.js\nclass Event {\r\n  static GameReset = new Event('game-reset');\r\n  static GameStarted = new Event('game-started');\r\n  static GameFinished = new Event('game-finished');\r\n  static PlayerMoved = new Event('player-moved');\r\n  static PlayerDied = new Event('player-died');\r\n  static PlayerWon = new Event('player-won');\r\n  static PlayerShot = new Event('player-shot');\r\n  static InterpreterStep = new Event('interpreter-step');\r\n  static Score = new Event('game-score');\r\n\r\n  constructor(channelName) {\r\n    this.channelName = channelName;\r\n  }\r\n}\n;// CONCATENATED MODULE: ./src/game/board.js\n\r\n\r\n\r\n\r\n// Enums\r\nclass LogicBlock {\r\n  static Wall = new LogicBlock(\"\");\r\n  static Exit = new LogicBlock(\"\");\r\n  static Space = new LogicBlock(\" \");\r\n  static Zombie = new LogicBlock(\"\");\r\n  static Sphinx = new LogicBlock(\"\");\r\n  static Null = new LogicBlock(\"X\");\r\n\r\n  constructor(symbol) {\r\n    this.symbol = symbol;\r\n  }\r\n}\r\n\r\nclass CardinalDirection {\r\n  static North = new CardinalDirection(\r\n    \"\", \r\n    position => ({x: position.x, y: position.y - 1}),\r\n    position => ({x: position.x, y: position.y + 1})\r\n  );\r\n  static East = new CardinalDirection(\r\n    \"\", \r\n    position => ({x: position.x + 1, y: position.y}),\r\n    position => ({x: position.x - 1, y: position.y})\r\n  );\r\n  static South = new CardinalDirection(\r\n    \"\", \r\n    position => ({x: position.x, y: position.y + 1}),\r\n    position => ({x: position.x, y: position.y - 1})\r\n  );\r\n  static West = new CardinalDirection(\r\n    \"\", \r\n    position => ({x: position.x - 1, y: position.y}),\r\n    position => ({x: position.x + 1, y: position.y})\r\n  );\r\n\r\n  constructor(symbol, advancePosition, retreatPosition) {\r\n    this.symbol = symbol;\r\n    this.advancePosition = advancePosition;\r\n    this.retreatPosition = retreatPosition;\r\n  }\r\n\r\n  advance(position) {\r\n    return this.advancePosition(position);\r\n  }\r\n\r\n  retreat(position) {\r\n    return this.retreatPosition(position);\r\n  }\r\n\r\n  static order = [this.North, this.East, this.South, this.West];\r\n  static toTheRight(direction) {\r\n    const index = this.order.indexOf(direction) + 1;\r\n    return this.order[index % 4];\r\n  }\r\n\r\n  static toTheLeft(direction) {\r\n    const index = this.order.indexOf(direction) - 1;\r\n    return this.order[((index > -1) ? index : 3)];\r\n  }\r\n\r\n  static backwards(direction) {\r\n    const index = this.order.indexOf(direction) + 2;\r\n    return this.order[index % 4];\r\n  }\r\n}\r\n\r\nclass MoveDirection {\r\n  static Forth = new MoveDirection((cardinalDirection, player) => cardinalDirection.advance(player));\r\n  static Back = new MoveDirection((cardinalDirection, player) => cardinalDirection.retreat(player));\r\n\r\n  constructor(apply) {\r\n    this.apply = apply;\r\n  }\r\n}\r\n\r\n// TODO: Maybe extract position class\r\nclass Movable {\r\n  constructor(x, y, direction) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.direction = direction;\r\n    this.crashed = false;\r\n  }\r\n  \r\n  isAt(x, y) {\r\n    return this.x == x && this.y == y;\r\n  }\r\n\r\n  move(moveDirection) {\r\n    const newPosition = moveDirection.apply(this.direction, this);\r\n    this.x = newPosition.x;\r\n    this.y = newPosition.y;\r\n  }\r\n\r\n  wouldMove(moveDirection) {\r\n    return moveDirection.apply(this.direction, this);\r\n  }\r\n\r\n  wouldMoveTo(moveDirection, x, y) {\r\n    const newPosition = this.wouldMove(moveDirection);\r\n    return newPosition.x === x && newPosition.y === y;\r\n  }\r\n\r\n  rotateLeft() {\r\n    this.direction = CardinalDirection.toTheLeft(this.direction);\r\n  }\r\n  rotateRight() {\r\n    this.direction = CardinalDirection.toTheRight(this.direction);\r\n  }\r\n  rotateBack() {\r\n    this.direction = CardinalDirection.backwards(this.direction);\r\n  }\r\n  \r\n  crash() {\r\n    this.crashed = true;\r\n  }\r\n}\r\n\r\nclass Zombie extends Movable {\r\n  constructor(x, y, direction) {\r\n    super(x, y, direction);\r\n    this.sprite = null;\r\n    this.dead = null;\r\n  }\r\n\r\n  setupSprites(theme) {\r\n    this.sprite = theme.sprite['zombie'];\r\n    this.dead = theme.sprite['deadZombie'];\r\n  }\r\n\r\n  getSprite() {\r\n    return (this.crashed) ? this.dead : this.sprite;\r\n  }\r\n}\r\n\r\nclass Player extends Movable {\r\n  constructor(x, y, direction) {\r\n    super(x, y, direction);\r\n    this.done = false;\r\n  }\r\n\r\n  setupSprites(theme) {\r\n    CardinalDirection.North.sprite = theme.sprite['north'];\r\n    CardinalDirection.East.sprite = theme.sprite['east'];\r\n    CardinalDirection.South.sprite = theme.sprite['south'];\r\n    CardinalDirection.West.sprite = theme.sprite['west'];\r\n    CardinalDirection.North.arrowSprite = theme.sprite['nextNorth'];\r\n    CardinalDirection.East.arrowSprite = theme.sprite['nextEast'];\r\n    CardinalDirection.South.arrowSprite = theme.sprite['nextSouth'];\r\n    CardinalDirection.West.arrowSprite = theme.sprite['nextWest'];\r\n    this.deadSprite = theme.sprite['dead'];\r\n  }\r\n\r\n  subscribeToEvents(eventBus) {\r\n    eventBus.subscribe(Event.PlayerDied.channelName, () => this.crash());\r\n    eventBus.subscribe(Event.PlayerWon.channelName, () => this.finish());\r\n  }\r\n\r\n  getSprite() {\r\n    if (this.crashed) {\r\n      return this.deadSprite;\r\n    } else if (this.done) {\r\n      return null;\r\n    } else {\r\n      return this.direction.sprite;\r\n    }\r\n  }\r\n  \r\n  getNextMoveSprite() {\r\n    if (this.crashed || this.done) {\r\n      return null;\r\n    }\r\n    return this.direction.arrowSprite;\r\n  }\r\n\r\n  getShootTarget() {\r\n    return this.direction.advance(this);\r\n  }\r\n\r\n  finish() {\r\n    this.done = true;\r\n  }\r\n\r\n  getLeftPosition() {\r\n    const leftDirection = CardinalDirection.toTheLeft(this.direction);\r\n    return MoveDirection.Forth.apply(leftDirection, this);\r\n  }\r\n  getRightPosition() {\r\n    const rightDirection = CardinalDirection.toTheRight(this.direction);\r\n    return MoveDirection.Forth.apply(rightDirection, this);\r\n  }\r\n}\r\n\r\nclass Board {\r\n  constructor(eventBus) {\r\n    this.eventBus = eventBus;\r\n  }\r\n\r\n  loadScene(scene) {\r\n    this.scene = scene;\r\n    this.gridCoordinatesTranslator = new GridCoordinatesTranslator(this.scene.width, this.scene.height);\r\n    this.animationService = new AnimationService(this.scene.theme.animations, this.eventBus);\r\n  }\r\n\r\n  getSprite(x, y, timestamp) {\r\n    const animationSprite = this.animationService.getSprite(x, y, timestamp);\r\n    if (animationSprite !== undefined) {\r\n      return animationSprite;\r\n    } else {\r\n      // Invert axis to match canvas to JSON matrix\r\n      return this.scene.map[y][x];\r\n    }\r\n  }\r\n\r\n  getLogicLabelForSprite(sprite) {\r\n    return this.scene.logic[sprite];\r\n  }\r\n\r\n  getLogic(x, y) {\r\n    const text = this.getLogicLabelForSprite(this.getSprite(x, y));\r\n    if (text === undefined) {\r\n      return LogicBlock.Wall;\r\n    }\r\n    return LogicBlock[text];\r\n  }\r\n\r\n  getSlotIndexFor(x, y) {\r\n    return this.gridCoordinatesTranslator.getSlotIndexFor(x, y);\r\n  }\r\n\r\n  getCoordinatesFor(index) {\r\n    return this.gridCoordinatesTranslator.getCoordinatesFor(index);\r\n  }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/sound.js\nconst soundBaseUrl = '/sidila/snd/';\r\n\r\nclass Sound {\r\n  constructor(file) {\r\n    this.sound = document.createElement(\"audio\");\r\n    this.sound.src = `${soundBaseUrl}/${file}`;\r\n  }\r\n\r\n  play() {\r\n    this.sound.play();\r\n  }\r\n  pause() {\r\n    this.sound.pause();\r\n  }\r\n}\n;// CONCATENATED MODULE: ./src/scene.js\nclass SceneService {\r\n  constructor() {\r\n    this.scenes = [\r\n      __webpack_require__(37),\r\n      __webpack_require__(679),\r\n      __webpack_require__(715),\r\n      __webpack_require__(387),\r\n      __webpack_require__(862)\r\n    ]\r\n  }\r\n\r\n  get(index) {\r\n    return this.scenes[index];\r\n  }\r\n\r\n  getSceneCount() {\r\n    return this.scenes.length;\r\n  }\r\n}\n;// CONCATENATED MODULE: ./src/game/game-board.js\n\r\n\r\n\r\n\r\n\r\nclass GameResult {\r\n  static NotFinished = new GameResult();\r\n  static Won = new GameResult();\r\n  static Died = new GameResult();\r\n}\r\n\r\nclass GameBoard extends Board {\r\n  constructor(eventBus) {\r\n    super(eventBus);\r\n    this.sceneService = new SceneService();\r\n    this.soundOn = true;\r\n    this.soundMap = {\r\n      step: new Sound('step.ogg'),\r\n      bang: new Sound('bang.ogg'),\r\n      win: new Sound('win.ogg'),\r\n      gameOver: new Sound('gameover.ogg')\r\n    };\r\n    this.subscribeToEvents();\r\n    this.reset(0);\r\n  }\r\n\r\n  // TODO: Let other classes subscribe events to simplify GameBoard \r\n  subscribeToEvents() {\r\n    this.eventBus.subscribe(Event.PlayerMoved.channelName, () => this.playSound(this.soundMap.step));\r\n    this.eventBus.subscribe(Event.PlayerShot.channelName, () => this.playSound(this.soundMap.bang));\r\n    this.eventBus.subscribe(Event.PlayerDied.channelName, () => this.playSound(this.soundMap.gameOver));\r\n    this.eventBus.subscribe(Event.PlayerWon.channelName, (coordinates) => {\r\n      this.animationService.trigger(coordinates.x, coordinates.y);\r\n      this.playSound(this.soundMap.win);\r\n    });\r\n  }\r\n\r\n  reset(sceneIndex) {\r\n    const scene = this.sceneService.get(sceneIndex);\r\n    this.loadScene(scene);\r\n    this.player = new Player(\r\n      this.scene.player.x,\r\n      this.scene.player.y,\r\n      CardinalDirection[this.scene.player.direction]\r\n    );\r\n    this.player.subscribeToEvents(this.eventBus);\r\n    this.zombie = new Zombie(\r\n      this.scene.zombie.x,\r\n      this.scene.zombie.y,\r\n      CardinalDirection.North\r\n    );\r\n    this.player.setupSprites(this.scene.theme);\r\n    this.zombie.setupSprites(this.scene.theme);\r\n    this.gameResult = GameResult.NotFinished;\r\n    this.moves = 0;\r\n    this.shots = 0;\r\n    this.publishNoDataEvent(Event.GameReset);\r\n  }\r\n\r\n  getSceneCount() {\r\n    return this.sceneService.getSceneCount();\r\n  }\r\n\r\n  canMoveInto(x, y) {\r\n    const logic = this.getLogic(x, y);\r\n    return logic === LogicBlock.Space || logic === LogicBlock.Exit;\r\n  }\r\n\r\n  isCrashed() {\r\n    return this.player.crashed;\r\n  }\r\n\r\n  isDone() {\r\n    return this.player.done;\r\n  }\r\n\r\n  start() {\r\n    this.publishNoDataEvent(Event.GameStarted);\r\n  }\r\n\r\n  movePlayer(moveDirection) {\r\n    this.publishPlayerMoved(moveDirection);\r\n    const newPosition = this.player.wouldMove(moveDirection);\r\n    if (this.canMoveInto(newPosition.x, newPosition.y)) {\r\n      this.player.move(moveDirection);\r\n      if (this.getLogicAround(this.player.x, this.player.y).includes(LogicBlock.Sphinx)) {\r\n        this.killPlayer();\r\n      }\r\n      const playerLogic = this.getLogic(this.player.x, this.player.y);\r\n      if (playerLogic === LogicBlock.Exit) {\r\n        this.exitPlayer();\r\n      }\r\n    } else {\r\n      this.killPlayer();\r\n    }\r\n    this.moves++;\r\n    if (this.player.crashed || this.player.done) {\r\n      this.publishGameFinished();\r\n    }\r\n  }\r\n  rotatePlayerLeft() {\r\n    this.player.rotateLeft();\r\n  }\r\n  rotatePlayerRight() {\r\n    this.player.rotateRight();\r\n  }\r\n  rotatePlayerBack() {\r\n    this.player.rotateBack();\r\n  }\r\n  playerShoot() {\r\n    this.publishNoDataEvent(Event.PlayerShot);\r\n    const shootAt = this.player.getShootTarget();\r\n    if (this.getLogic(shootAt.x, shootAt.y) === LogicBlock.Zombie) {\r\n      this.zombie.crash();\r\n    }\r\n    this.shots++;\r\n  }\r\n  killPlayer() {\r\n    this.publishPlayerDied();\r\n    this.gameResult = GameResult.Died;\r\n  }\r\n  exitPlayer() {\r\n    this.publishPlayerWon({ x: this.player.x, y: this.player.y });\r\n    this.gameResult = GameResult.Won;\r\n  }\r\n\r\n  getLogic(x, y) {\r\n    if (x < 0 || y < 0 || x > this.scene.width - 1 || y > this.scene.height - 1) {\r\n      return LogicBlock.Null;\r\n    }\r\n    if (this.zombie?.isAt(x, y) && this.zombie?.crashed !== true) {\r\n      return LogicBlock.Zombie;\r\n    }\r\n    return super.getLogic(x, y);\r\n  }\r\n  getLogicAround(x, y) {\r\n    return [\r\n      this.getLogic(x, y-1),\r\n      this.getLogic(x, y+1),\r\n      this.getLogic(x-1, y),\r\n      this.getLogic(x+1, y),\r\n    ];\r\n  }\r\n  getLogicInFrontOfPlayer() {\r\n    const inFrontPosition = this.player.wouldMove(MoveDirection.Forth);\r\n    return this.getLogic(inFrontPosition.x, inFrontPosition.y);\r\n  }\r\n  getLogicToTheLeftOfPlayer() {\r\n    const atTheLeftPosition = this.player.getLeftPosition();\r\n    return this.getLogic(atTheLeftPosition.x, atTheLeftPosition.y);\r\n  }\r\n  getLogicToTheRightOfPlayer() {\r\n    const atTheRightPosition = this.player.getRightPosition();\r\n    return this.getLogic(atTheRightPosition.x, atTheRightPosition.y);\r\n  }\r\n\r\n  getOverlaySprite(x, y, timestamp) {\r\n    if (this.player.isAt(x, y)) {\r\n      return this.player.getSprite();\r\n    }\r\n    if (this.zombie?.isAt(x, y)) {\r\n      return this.zombie.getSprite();\r\n    }\r\n    if (this.player.wouldMoveTo(MoveDirection.Forth, x, y)) {\r\n      return this.player.getNextMoveSprite();\r\n    }\r\n    return null;\r\n  }\r\n\r\n  setSound(on) {\r\n    this.soundOn = on;\r\n  }\r\n\r\n  playSound(fx) {\r\n    if (this.soundOn) {\r\n      fx.play();\r\n    }\r\n  }\r\n\r\n  publishPlayerMoved(moveDirection) {\r\n    this.eventBus.publish(Event.PlayerMoved.channelName, moveDirection);\r\n  }\r\n  publishPlayerDied() {\r\n    this.eventBus.publish(Event.PlayerDied.channelName, null);\r\n  }\r\n  publishPlayerWon(coordinates) {\r\n    this.eventBus.publish(Event.PlayerWon.channelName, coordinates);\r\n  }\r\n  publishGameFinished() {\r\n    this.eventBus.publish(Event.GameFinished.channelName, this.gameResult);\r\n  }\r\n  \r\n  publishNoDataEvent(event) {\r\n    this.eventBus.publish(event.channelName, null);\r\n  }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/util/event-bus.js\nclass EventBus {\r\n  constructor() {\r\n    this.subscribers = {};\r\n  }\r\n\r\n  subscribe(channel, subscriber) {\r\n    if (!Object.hasOwnProperty.call(this.subscribers, channel)) {\r\n      this.subscribers[channel] = [];\r\n    }\r\n    this.subscribers[channel].push(subscriber);\r\n  }\r\n\r\n  unsubscribe(channel, subscriber) {\r\n    if (Object.hasOwnProperty.call(this.subscribers, channel)) {\r\n      this.subscribers[channel].splice(this.subscribers[channel].indexOf(subscriber), 1);\r\n    }\r\n  }\r\n\r\n  publish(channel, event) {\r\n    if (Object.hasOwnProperty.call(this.subscribers, channel)) {\r\n      this.subscribers[channel].forEach(subscriber => {\r\n        subscriber(event);\r\n      });\r\n    }\r\n  }\r\n}\n;// CONCATENATED MODULE: ./src/game/editor-board.js\n\r\n\r\n\r\nconst MAX_UNDO_ITEMS = 100;\r\n\r\nclass EditorBoard extends Board {\r\n  constructor() {\r\n    super(new EventBus());\r\n    this.undo = [];\r\n  }\r\n\r\n  load(source) {\r\n    const scene = JSON.parse(source);\r\n    this.loadScene(scene);\r\n  }\r\n\r\n  save() {\r\n    return JSON.stringify(this.scene, null, 2);\r\n  }\r\n\r\n  setSlot(index, sprite) {\r\n    const coordinates = this.getCoordinatesFor(index);\r\n    if (this.scene.map[coordinates.y][coordinates.x] != sprite) {\r\n      const oldSprite = this.scene.map[coordinates.y][coordinates.x];\r\n      this.addUndo(() => this.scene.map[coordinates.y][coordinates.x] = oldSprite);\r\n      this.scene.map[coordinates.y][coordinates.x] = sprite;\r\n    }\r\n  }\r\n\r\n  addUndo(undoAction) {\r\n    this.undo.push(undoAction);\r\n    if (this.undo.length > MAX_UNDO_ITEMS) {\r\n      this.undo.pop();\r\n    }\r\n  }\r\n\r\n  undoLastAction() {\r\n    const undoAction = this.undo.pop();\r\n    if (undoAction !== undefined) {\r\n      undoAction();\r\n    }\r\n  }\r\n\r\n  getOverlaySprite(x, y) {\r\n    return null;\r\n  }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/drawing.js\n\r\n\r\nconst imageBaseUrl = '/sidila/img/';\r\n\r\nclass GridPainter {\r\n  constructor(canvas, width, height, slotWidth, slotHeight, hoverColor) {\r\n    this.canvas = canvas;\r\n    this.width = width;\r\n    this.height = height;\r\n    this.slotWidth = slotWidth;\r\n    this.slotHeight = slotHeight;\r\n    this.slotsInX = Math.floor(this.width / this.slotWidth);\r\n    this.slotsInY = Math.floor(this.height / this.slotHeight);\r\n    this.hoverColor = hoverColor;\r\n    this.scaleX = canvas.clientWidth / this.width;\r\n    this.scaleY = canvas.clientHeight / this.height;\r\n  }\r\n\r\n  getContext2D() {\r\n    return this.canvas.getContext('2d');\r\n  }\r\n\r\n  mouseOver(x, y) {\r\n    this.hover = this.getSlotIndexForDiscrete(\r\n      Math.floor(x / this.scaleX / this.slotWidth),\r\n      Math.floor(y / this.scaleY / this.slotHeight)\r\n    );\r\n    return this.hover;\r\n  }\r\n  getSlotIndexForDiscrete(x, y) {\r\n    return x + y * this.slotsInX;\r\n  }\r\n\r\n  getCanvasCoordinatesForSlot(index) {\r\n    const coordinates = this.getCoordinatesForSlot(index);\r\n    return {\r\n      x: coordinates.x * this.slotWidth,\r\n      y: coordinates.y * this.slotHeight\r\n    };\r\n  }\r\n  getCoordinatesForSlot(index) {\r\n    return {\r\n      x: (index % this.slotsInX),\r\n      y: Math.floor(index / this.slotsInX)\r\n    };\r\n  }\r\n\r\n  drawGridSlot(context, origin, color) {\r\n    context.strokeStyle = color;\r\n    context.strokeRect(origin.x + .5, origin.y + .5, this.slotWidth - 1, this.slotHeight - 1);\r\n  }\r\n\r\n  paintHover(context) {\r\n    if (this.hover !== undefined) {\r\n      const origin = this.getCanvasCoordinatesForSlot(this.hover);\r\n      this.drawGridSlot(context, origin, this.hoverColor);\r\n    }\r\n  }\r\n}\r\n\r\nclass CanvasPainter extends GridPainter {\r\n  constructor(canvas, board, eventBus) {\r\n    super(\r\n      canvas, \r\n      board.scene.width * board.scene.theme.spriteWidth,\r\n      board.scene.height * board.scene.theme.spriteHeight,\r\n      board.scene.theme.spriteWidth, \r\n      board.scene.theme.spriteHeight,\r\n      'red'\r\n    );\r\n    this.board = board;\r\n    this.eventBus = eventBus;\r\n    this.sceneUpdated();\r\n    if (this.eventBus !== undefined) {\r\n      this.subscribeToEvents();\r\n    }\r\n  }\r\n\r\n  subscribeToEvents() {\r\n    this.eventBus.subscribe(Event.GameReset.channelName, () => this.sceneUpdated());\r\n  }\r\n\r\n  sceneUpdated() {\r\n    this.sprites = new Image();\r\n    this.sprites.src = `${imageBaseUrl}${this.board.scene.theme.image}`;\r\n  }\r\n\r\n  paint(timestamp) {\r\n    const context = this.getContext2D();\r\n    context.fillStyle = this.board.scene.theme.background;\r\n    context.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n    for(let y=0; y < this.slotsInY; y++) {\r\n      for(let x=0; x < this.slotsInX; x++) {\r\n        const spriteNumber = this.board.getSprite(x, y, timestamp);\r\n        this.drawSprite(context, spriteNumber, x, y);\r\n        const overlaySpriteNumber = this.board.getOverlaySprite(x, y, timestamp);\r\n        if (overlaySpriteNumber != null) {\r\n          this.drawSprite(context, overlaySpriteNumber, x, y);\r\n        }\r\n      }\r\n    }\r\n    this.paintHover(context);\r\n  }\r\n\r\n  drawSprite(context, spriteNumber, x, y) {\r\n    const sourceX = this.getSourceX(spriteNumber);\r\n    const sourceY = this.getSourceY(spriteNumber);\r\n    context.drawImage(\r\n      this.sprites, \r\n      sourceX, \r\n      sourceY,\r\n      this.slotWidth,\r\n      this.slotHeight,\r\n      x * this.slotWidth,\r\n      y * this.slotHeight,\r\n      this.slotWidth,\r\n      this.slotHeight\r\n    );    \r\n  }\r\n\r\n  getSourceX(spriteNumber) {\r\n    return this.slotWidth * (spriteNumber % (this.sprites.width/this.slotWidth));\r\n  }\r\n\r\n  getSourceY(spriteNumber) {\r\n    return this.slotHeight * Math.floor(spriteNumber / (this.sprites.width/this.slotWidth));\r\n  }\r\n}\r\n\r\nclass PalettePainter extends GridPainter {\r\n  constructor(canvas, scene) {\r\n    super(\r\n      canvas, \r\n      scene.theme.imageWidth,\r\n      scene.theme.imageHeight,\r\n      scene.theme.spriteWidth, \r\n      scene.theme.spriteHeight,\r\n      'red'\r\n    );\r\n    this.scene = scene;\r\n    this.sprites = new Image();\r\n    this.sprites.src = `${imageBaseUrl}${scene.theme.image}`;\r\n    this.selected = 0;\r\n  }\r\n\r\n  paint() {\r\n    const context = this.getContext2D();\r\n    context.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n    context.drawImage(this.sprites, 0, 0);\r\n    if (this.selected !== undefined) {\r\n      const origin = this.getCanvasCoordinatesForSlot(this.selected);\r\n      this.drawGridSlot(context, origin, 'white');\r\n    }\r\n    this.paintHover(context);\r\n  }\r\n\r\n  selectSlot(index) {\r\n    this.selected = index;\r\n  }\r\n}\n;// CONCATENATED MODULE: ./src/util/storage.js\nconst STORAGE_PROGRAM_PREFIX = 'sidila-program-';\r\nconst PROGRAM_NAME_REGEX = /\\w{2,20}/g;\r\n\r\nclass Storage {\r\n\r\n  static requireValidProgramName(name) {\r\n    if (!name.match(PROGRAM_NAME_REGEX)) {\r\n      throw new Error('Nombre de programa invlido');\r\n    }\r\n  }\r\n\r\n  listSavedPrograms() {\r\n    const list = [];\r\n    for (let i=0, len=localStorage.length; i < len; ++i) {\r\n      if (localStorage.key(i).startsWith(STORAGE_PROGRAM_PREFIX)) {\r\n        list.push(Storage.getFilenameFromKey(localStorage.key(i)));\r\n      }\r\n    }\r\n    return list;\r\n  }\r\n  loadProgram(name) {\r\n    Storage.requireValidProgramName(name);\r\n    const key = Storage.getKeyFromFilename(name);\r\n    if (key != undefined && key != '') {\r\n      return localStorage.getItem(key);\r\n    }\r\n  }\r\n  saveProgram(name, program, overwrite) {\r\n    Storage.requireValidProgramName(name);\r\n    const key = Storage.getKeyFromFilename(name);\r\n    if (localStorage.getItem(key) !== null && !overwrite.checked) {\r\n      throw new Error('Ya existe un programa con ese nombre');\r\n    }\r\n    localStorage.setItem(key, program);\r\n  }\r\n  deleteProgram(name) {\r\n    Storage.requireValidProgramName(name);\r\n    const key = Storage.getKeyFromFilename(name);\r\n    localStorage.removeItem(key);\r\n  }\r\n\r\n  static getKeyFromFilename(filename) {\r\n    return STORAGE_PROGRAM_PREFIX + filename;\r\n  }\r\n\r\n  static getFilenameFromKey(key) {\r\n    return key.substring(STORAGE_PROGRAM_PREFIX.length, key.length);\r\n  }\r\n}\n;// CONCATENATED MODULE: ./src/game/score.js\nclass Score {\r\n  constructor() {\r\n    this.base = 200000; // 200k\r\n  }\r\n\r\n  getScore(lines, board) {\r\n    if (board.isCrashed()) {\r\n      return 0;\r\n    }\r\n    const zombieKilled = board.zombie.crashed;\r\n    const linesFactor = (zombieKilled) ? 0.96 : 1;\r\n    const moves = board.moves;\r\n    const movesFactor = (zombieKilled) ? 0.91 : 1;\r\n    const shots = board.shots;\r\n    const shotsFactor = (zombieKilled) ? 0.73 : 1;\r\n    return Math.ceil(\r\n      this.base \r\n      - (lines * 3002 * linesFactor) \r\n      - (moves * 996 * movesFactor)\r\n      - (shots * 603 * shotsFactor)\r\n    );\r\n  }\r\n}\n;// CONCATENATED MODULE: ./src/instructions/instruction.js\n\r\n\r\nclass Instruction {\r\n  constructor(start, end) {\r\n    this.location = { start, end };\r\n  }\r\n}\r\n\r\nclass Action extends Instruction {\r\n  constructor(start, end) {\r\n    super(start, end);\r\n  }\r\n}\r\n\r\nclass Move extends Action {\r\n  constructor(start, end) {\r\n    super(start, end);\r\n  }\r\n\r\n  execute(board) {\r\n    board.movePlayer(MoveDirection.Forth);\r\n  }\r\n}\r\n\r\nclass Back extends Action {\r\n  constructor(start, end) {\r\n    super(start, end);\r\n  }\r\n\r\n  execute(board) {\r\n    board.movePlayer(MoveDirection.Back);\r\n  }\r\n}\r\n\r\nclass Shoot extends Action {\r\n  constructor(start, end) {\r\n    super(start, end);\r\n  }\r\n\r\n  execute(board) {\r\n    board.playerShoot();\r\n  }\r\n}\r\n\r\nclass TurnDirection {\r\n  static Left = new TurnDirection((board) => board.rotatePlayerLeft());\r\n  static Right = new TurnDirection((board) => board.rotatePlayerRight());\r\n  static Back = new TurnDirection((board) => board.rotatePlayerBack());\r\n\r\n  constructor(action) {\r\n    this.action = action;\r\n  }\r\n}\r\n\r\nclass Turn extends Action {\r\n  constructor(start, end, direction) {\r\n    super(start, end);\r\n    switch (direction) {\r\n      case 'la derecha': \r\n        this.direction = TurnDirection.Right;\r\n        break;\r\n      case 'la izquierda':\r\n        this.direction = TurnDirection.Left;\r\n        break;\r\n      case 'atras':\r\n        this.direction = TurnDirection.Back;\r\n        break;\r\n      default:\r\n        throw new Error(`Invalid direction: '${direction}'`);\r\n    }\r\n  }\r\n\r\n  execute(board) {\r\n    this.direction.action(board);\r\n  }\r\n}\r\n\r\nclass Branch extends Instruction {\r\n  constructor(start, end, condition, body, elseBody) {\r\n    super(start, end);\r\n    this.condition = condition;\r\n    this.body = body;\r\n    this.elseBody = elseBody;\r\n  }\r\n\r\n  evaluate(board) {\r\n    return this.condition.evaluate(board);\r\n  }\r\n}\r\n\r\nclass Loop extends Instruction {\r\n  constructor(start, end, condition, body) {\r\n    super(start, end);\r\n    this.condition = condition;\r\n    this.body = body;\r\n  }\r\n\r\n  evaluate(board) {\r\n    return this.condition.evaluate(board);\r\n  }\r\n}\r\n\r\nclass LookAheadCondition extends Instruction {\r\n  constructor(start, end, not, spriteLabel, lookUpDirection) {\r\n    super(start, end);\r\n    this.not = not === 'no';\r\n    if (spriteLabel === 'pared') {\r\n      this.condition = (sprite) => sprite === LogicBlock.Wall;\r\n    } else if (spriteLabel === 'zombie') {\r\n      this.condition = (sprite) => sprite === LogicBlock.Zombie;\r\n    } else if (spriteLabel === 'espacio') {\r\n      this.condition = (sprite) => sprite === LogicBlock.Space;\r\n    } else if (spriteLabel === 'salida') {\r\n      this.condition = (sprite) => sprite === LogicBlock.Exit;\r\n    } else {\r\n      this.condition = (sprite) => sprite !== LogicBlock.Space;\r\n    }\r\n    if (lookUpDirection == 'adelante') {\r\n      this.lookUpDirection = (board) => board.getLogicInFrontOfPlayer();\r\n    } else if (lookUpDirection == 'a la izquierda') {\r\n      this.lookUpDirection = (board) => board.getLogicToTheLeftOfPlayer();\r\n    } else {\r\n      this.lookUpDirection = (board) => board.getLogicToTheRightOfPlayer();\r\n    }\r\n  }\r\n\r\n  evaluate(board) {\r\n    const evaluation = this.condition(this.lookUpDirection(board));\r\n    return (this.not) ? !evaluation : evaluation;\r\n  }\r\n}\r\n\r\nclass InGameCondition extends Instruction {\r\n  constructor(start, end, not) {\r\n    super(start, end);\r\n    this.not = not === 'no';\r\n  }\r\n\r\n  evaluate(board) {\r\n    const evaluation = board.isDone();\r\n    return (this.not) ? !evaluation : evaluation;\r\n  }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/instructions/interpreter.js\n\r\n\r\n\r\nclass StepInterpreter {\r\n  constructor(board, tree, eventBus) {\r\n    this.eventBus = eventBus;\r\n    this.board = board;\r\n    this.tree = tree;\r\n    this.stack = [];\r\n    this.stackBody(this.tree.elements);\r\n    this.gameTicks = 0;\r\n    this.finished = false;\r\n  }\r\n\r\n  stackBody(nodes) {\r\n    for(let i=nodes.length - 1; i >= 0; i--) {\r\n      this.stackNode(nodes[i]);\r\n    }\r\n  }\r\n  stackNode(node) {\r\n    this.stack.push(node);\r\n  }\r\n\r\n  tick() {\r\n    this.gameTicks++;\r\n    const node = this.stack.pop();\r\n    if (node !== undefined) {\r\n      this.visitNode(node);\r\n    }\r\n    this.finished = this.stack.length === 0;\r\n  }\r\n\r\n  isFinished() {\r\n    return this.finished;\r\n  }\r\n\r\n  visitNode(node) {\r\n    const instruction = node.elements[0];\r\n    this.publishStep(instruction);\r\n    if (instruction instanceof Action) {\r\n      instruction.execute(this.board);\r\n    } else if (instruction instanceof Branch) {\r\n      if (instruction.evaluate(this.board)) {\r\n        this.stackBody(instruction.body);\r\n      } else if (instruction.elseBody !== undefined) {\r\n        this.stackBody(instruction.elseBody);\r\n      }\r\n    } else if (instruction instanceof Loop) {\r\n      if (instruction.evaluate(this.board)) {\r\n        this.stackNode(node);\r\n        this.stackBody(instruction.body);\r\n      }\r\n    }\r\n  }\r\n\r\n  createStepEvent(node) {\r\n    return {\r\n      location: node.location,\r\n      gameTicks: this.gameTicks\r\n    };\r\n  }\r\n\r\n  publishStep(instruction) {\r\n    const event = this.createStepEvent(instruction);\r\n    this.eventBus.publish(Event.InterpreterStep.channelName, event);\r\n  }\r\n\r\n  subscribeToStep(subscriber) {\r\n    this.eventBus.subscribe(Event.InterpreterStep.channelName, subscriber);\r\n  }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/game/control.js\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass Control {\r\n  constructor(codeMirror, canvas) {\r\n    this.codeMirror = codeMirror;\r\n    this.eventBus = new EventBus();\r\n    this.board = new GameBoard(this.eventBus);\r\n    this.canvasPainter = new CanvasPainter(canvas, this.board, this.eventBus);\r\n    this.score = new Score();\r\n    this.running = false;\r\n    this.subscribeToEvents();\r\n  }\r\n\r\n  subscribeToEvents() {\r\n    this.eventBus.subscribe(Event.GameFinished.channelName, () => this.running = false);\r\n    this.codeMirror.on('changes', () => this.publishScore());\r\n  }\r\n\r\n  run(tree) {\r\n    this.interpreter = new StepInterpreter(this.board, tree, this.eventBus);\r\n    this.board.start();\r\n    this.running = true;\r\n  }\r\n\r\n  isRunning() {\r\n    return this.running;\r\n  }\r\n\r\n  tick() {\r\n    this.interpreter.tick();\r\n    if (this.interpreter.isFinished()) {\r\n      this.running = false;\r\n    }\r\n    this.publishScore();\r\n  }\r\n\r\n  paint(timestamp) {\r\n    this.canvasPainter.paint(timestamp);\r\n  }\r\n\r\n  publishScore() {\r\n    const lines = this.codeMirror.lineCount();\r\n    const score = this.score.getScore(lines, this.board);\r\n    this.eventBus.publish(Event.Score.channelName, score);\r\n  }\r\n\r\n  reset(sceneIndex) {\r\n    this.board.reset(sceneIndex);\r\n    this.running = false;\r\n  }\r\n\r\n  subscribeToStep(subscriber) {\r\n    this.eventBus.subscribe(Event.InterpreterStep.channelName, subscriber);\r\n  }\r\n  subscribeToScore(subscriber) {\r\n    this.eventBus.subscribe(Event.Score.channelName, subscriber);\r\n  }\r\n  subscribeToGameFinished(subscriber) {\r\n    this.eventBus.subscribe(Event.GameFinished.channelName, subscriber);\r\n  }\r\n\r\n  setSound(on) {\r\n    this.board.setSound(on);\r\n  }\r\n}\n;// CONCATENATED MODULE: ./src/grammar/sidila.js\n\r\n\r\nconst maps = __webpack_require__(498);\r\n\r\nclass Actions {\r\n  makeMove(input, start, end, elements) {\r\n    return new Move(start, end);\r\n  }\r\n  makeBack(input, start, end, elements) {\r\n    return new Back(start, end);\r\n  }\r\n  makeShoot(input, start, end, elements) {\r\n    return new Shoot(start, end);\r\n  }\r\n  makeTurn(input, start, end, elements) {\r\n    return new Turn(start, end, elements[1].text);\r\n  }\r\n  makeBranch(input, start, end, elements) {\r\n    const condition = elements[1];\r\n    const body = elements[2].elements;\r\n    const elseBody = elements[3].elements[1]?.elements;\r\n    return new Branch(start, end, condition, body, elseBody);\r\n  }\r\n  makeLoop(input, start, end, elements) {\r\n    const condition = elements[1];\r\n    const body = elements[2].elements;\r\n    return new Loop(start, end, condition, body);\r\n  }\r\n  makeLookAheadCondition(input, start, end, elements) {\r\n    const not = elements[0].text;\r\n    const spriteLabel = elements[2].text;\r\n    const lookUpDirection = elements[3].text\r\n    return new LookAheadCondition(start, end, not, spriteLabel, lookUpDirection);\r\n  }\r\n  makeInGameCondition(input, start, end, elements) {\r\n    return new InGameCondition(start, end, elements[0].text);\r\n  }\r\n}\r\n\r\nfunction parse(code) {\r\n  return maps.parse(code, { actions: new Actions() })\r\n}\n;// CONCATENATED MODULE: ./src/ux/program-list.js\nclass ProgramListDropDownHandler {\r\n  constructor(storage, selectWidget) {\r\n    this.storage = storage;\r\n    this.selectWidget = selectWidget;\r\n  }\r\n\r\n  loadFiles() {\r\n    this.emptySelectWidget();\r\n    this.storage.listSavedPrograms().forEach(item => {\r\n      const option = document.createElement(\"option\");\r\n      option.text = item;\r\n      option.value = item;\r\n      this.selectWidget.add(option);\r\n    });\r\n  }\r\n\r\n  emptySelectWidget() {\r\n    const placeholder = [].filter.call(this.selectWidget.options, option => option.value === \"\")[0];\r\n    while(this.selectWidget.length > 0) {\r\n      this.selectWidget.remove(this.selectWidget.length - 1);\r\n    }\r\n    this.selectWidget.add(placeholder);\r\n  }\r\n\r\n  getSelectedProgram() {\r\n    const name = this.selectWidget.options[this.selectWidget.selectedIndex].value;\r\n    return this.storage.loadProgram(name);\r\n  }\r\n}\n;// CONCATENATED MODULE: ./src/ux/code-mirror-helper.js\nclass CodeMirrorHelper {\r\n  constructor(codeMirror, debugClassName, errorClassName) {\r\n    this.codeMirror = codeMirror;\r\n    this.debugClassName = debugClassName;\r\n    this.errorClassName = errorClassName;\r\n  }\r\n\r\n  highlight(location) {\r\n    const start = this.codeMirror.posFromIndex(location.start);\r\n    const end = this.codeMirror.posFromIndex(location.end);\r\n    this.clearHighlight();\r\n    this.lastHighlightMarker = this.codeMirror.markText(start, end, { className: this.debugClassName});\r\n    this.codeMirror.scrollIntoView(start);\r\n  }\r\n\r\n  clearHighlight() {\r\n    if (this.lastHighlightMarker != undefined) {\r\n      this.lastHighlightMarker.clear();\r\n    }\r\n  }\r\n\r\n  markError(error) {\r\n    const lineString = error.match(/^Line ([0-9]+)/)[1];\r\n    const shiftString = error.match(/([ ]+)\\^$/)[1];\r\n    const line = parseInt(lineString) - 1;\r\n    const shift = shiftString.length - 9;\r\n    const start = { line: line, ch: shift };\r\n    const end = { line: line, ch: shift + 1 };\r\n    this.lastErrorMarker = this.codeMirror.markText(start, end, { className: this.errorClassName});\r\n    this.codeMirror.scrollIntoView(start);\r\n  }\r\n\r\n  clearError() {\r\n    if (this.lastErrorMarker != undefined) {\r\n      this.lastErrorMarker.clear();\r\n    }\r\n  }\r\n}\n;// CONCATENATED MODULE: ./src/app.js\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELEVBQUUsR0FBRyxFQUFFO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxNQUFNO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEM7O0FDdkJPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixFQUFFLEdBQUcsRUFBRTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDOztBQzNHTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQzs7QUNkcUU7QUFDdEI7QUFDZjtBQUNoQztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxrQkFBa0IsaUNBQWlDO0FBQ25ELGtCQUFrQixpQ0FBaUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlDQUFpQztBQUNuRCxrQkFBa0IsaUNBQWlDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQ0FBaUM7QUFDbkQsa0JBQWtCLGlDQUFpQztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUNBQWlDO0FBQ25ELGtCQUFrQixpQ0FBaUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFB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RUFBc0UsK0JBQStCO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsa0JBQWtCO0FBQ2xCLGtFQUFrRSwrQkFBK0I7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEM7O0FDckMwRDtBQUNSO0FBQ1E7QUFDakI7QUFDQTtBQUNBO0FBQ3NCO0FBQ0o7QUFDM0Q7QUFZRSIsInNvdXJjZXMiOlsid2VicGFjazovL3NpZGlsYS8uL3NyYy91dGlsL2dyaWQtY29vcmRpbmF0ZXMuanM/OTE5MiIsIndlYnBhY2s6Ly9zaWRpbGEvLi9zcmMvZ2FtZS9hbmltYXRpb24uanM/MDU5MyIsIndlYnBhY2s6Ly9zaWRpbGEvLi9zcmMvZ2FtZS9ldmVudC5qcz81YWNkIiwid2VicGFjazovL3NpZGlsYS8uL3NyYy9nYW1lL2JvYXJkLmpzPzE4MmUiLCJ3ZWJwYWNrOi8vc2lkaWxhLy4vc3JjL3NvdW5kLmpzPzM5ZmIiLCJ3ZWJwYWNrOi8vc2lkaWxhLy4vc3JjL3NjZW5lLmpzPzI2NGMiLCJ3ZWJwYWNrOi8vc2lkaWxhLy4vc3JjL2dhbWUvZ2FtZS1ib2FyZC5qcz82MjUyIiwid2VicGFjazovL3NpZGlsYS8uL3NyYy91dGlsL2V2ZW50LWJ1cy5qcz8wZjAxIiwid2VicGFjazovL3NpZGlsYS8uL3NyYy9nYW1lL2VkaXRvci1ib2FyZC5qcz82NGE5Iiwid2VicGFjazovL3NpZGlsYS8uL3NyYy9kcmF3aW5nLmpzPzcxODIiLCJ3ZWJwYWNrOi8vc2lkaWxhLy4vc3JjL3V0aWwvc3RvcmFnZS5qcz8yYjYxIiwid2VicGFjazovL3NpZGlsYS8uL3NyYy9nYW1lL3Njb3JlLmpzPzkwNzUiLCJ3ZWJwYWNrOi8vc2lkaWxhLy4vc3JjL2luc3RydWN0aW9ucy9pbnN0cnVjdGlvbi5qcz9iMjI2Iiwid2VicGFjazovL3NpZGlsYS8uL3NyYy9pbnN0cnVjdGlvbnMvaW50ZXJwcmV0ZXIuanM/Yzk5NSIsIndlYnBhY2s6Ly9zaWRpbGEvLi9zcmMvZ2FtZS9jb250cm9sLmpzPzhhOTEiLCJ3ZWJwYWNrOi8vc2lkaWxhLy4vc3JjL2dyYW1tYXIvc2lkaWxhLmpzP2M0MDMiLCJ3ZWJwYWNrOi8vc2lkaWxhLy4vc3JjL3V4L3Byb2dyYW0tbGlzdC5qcz8zODM5Iiwid2VicGFjazovL3NpZGlsYS8uL3NyYy91eC9jb2RlLW1pcnJvci1oZWxwZXIuanM/OGRjYiIsIndlYnBhY2s6Ly9zaWRpbGEvLi9zcmMvYXBwLmpzPzExMTIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIEdyaWRDb29yZGluYXRlc1RyYW5zbGF0b3Ige1xyXG4gIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgdGhpcy5tYXhJbmRleCA9ICh3aWR0aCAqIGhlaWdodCkgLSAxO1xyXG4gIH1cclxuXHJcbiAgZ2V0U2xvdEluZGV4Rm9yKHgsIHkpIHtcclxuICAgIGlmICh4ID4gdGhpcy53aWR0aCAtIDEgfHwgeSA+IHRoaXMuaGVpZ2h0IC0gMSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvb3JkaW5hdGVzIG91dCBvZiBib3VuZDogJHt4fSwke3l9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geCArIHkgKiB0aGlzLndpZHRoO1xyXG4gIH1cclxuXHJcbiAgZ2V0Q29vcmRpbmF0ZXNGb3IoaW5kZXgpIHtcclxuICAgIGlmIChpbmRleCA+IHRoaXMubWF4SW5kZXgpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbmRleCBvdXQgb2YgYm91bmQ6ICR7aW5kZXh9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB4OiBpbmRleCAlIHRoaXMud2lkdGgsXHJcbiAgICAgIHk6IE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLndpZHRoKVxyXG4gICAgfVxyXG4gIH1cclxufSIsImV4cG9ydCBjbGFzcyBBbmltYXRpb25TZXJ2aWNlIHtcclxuICBjb25zdHJ1Y3RvcihhbmltYXRpb25zLCBldmVudEJ1cykge1xyXG4gICAgdGhpcy5hbmltYXRpb25zID0ge307XHJcbiAgICBmb3IgKGNvbnN0IGxvY2F0aW9uIGluIGFuaW1hdGlvbnMpIHtcclxuICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFuaW1hdGlvbnMsIGxvY2F0aW9uKSkge1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uc1tsb2NhdGlvbl0gPSBBbmltYXRpb25TZXJ2aWNlLmNyZWF0ZUFuaW1hdGlvbkZyb21TZXR0aW5ncyhhbmltYXRpb25zW2xvY2F0aW9uXSwgZXZlbnRCdXMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXRTcHJpdGUoeCwgeSwgdGltZXN0YW1wKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRBbmltYXRpb25BdCh4LCB5KT8uZ2V0U3ByaXRlKHRpbWVzdGFtcCk7XHJcbiAgfVxyXG5cclxuICBnZXRBbmltYXRpb25BdCh4LCB5KSB7XHJcbiAgICBjb25zdCBsb2NhdGlvbiA9IGAke3h9LCR7eX1gO1xyXG4gICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYW5pbWF0aW9ucywgbG9jYXRpb24pKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbnNbbG9jYXRpb25dO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcblxyXG4gIHRyaWdnZXIoeCwgeSkge1xyXG4gICAgY29uc3QgYW5pbWF0aW9uID0gdGhpcy5nZXRBbmltYXRpb25BdCh4LCB5KTtcclxuICAgIGlmICgoYW5pbWF0aW9uICE9PSB1bmRlZmluZWQpICYmIChhbmltYXRpb24gaW5zdGFuY2VvZiBUd29XYXlzQW5pbWF0aW9uKSkge1xyXG4gICAgICBhbmltYXRpb24ubGF1bmNoKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgY3JlYXRlQW5pbWF0aW9uRnJvbVNldHRpbmdzKGFuaW1hdGlvbiwgZXZlbnRCdXMpIHtcclxuICAgIHN3aXRjaChhbmltYXRpb24udHlwZSkge1xyXG4gICAgICBjYXNlICdsb29wJzogcmV0dXJuIG5ldyBMb29wQW5pbWF0aW9uKGFuaW1hdGlvbi5zZXR0aW5ncywgZXZlbnRCdXMpO1xyXG4gICAgICBjYXNlICd0d28td2F5cyc6IHJldHVybiBuZXcgVHdvV2F5c0FuaW1hdGlvbihhbmltYXRpb24uc2V0dGluZ3MsIGV2ZW50QnVzKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBMb29wQW5pbWF0aW9uIHtcclxuICBjb25zdHJ1Y3RvcihzZXR0aW5ncywgZXZlbnRCdXMpIHtcclxuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcclxuICAgIHRoaXMubG9vcExpbWl0ID0gc2V0dGluZ3Muc3ByaXRlcy5sZW5ndGggKiBzZXR0aW5ncy5wZXJpb2Q7XHJcbiAgfVxyXG5cclxuICBnZXRTcHJpdGUodGltZXN0YW1wKSB7XHJcbiAgICB0aGlzLmFkdmFuY2VUaW1lKHRpbWVzdGFtcCk7XHJcbiAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5zcHJpdGVzW3RoaXMuZ2V0SW5kZXhGb3JDdXJyZW50VGltZXN0YW1wKCldO1xyXG4gIH1cclxuXHJcbiAgYWR2YW5jZVRpbWUodGltZXN0YW1wKSB7XHJcbiAgICB0aGlzLmN1cnJlbnRUaW1lc3RhbXAgPSB0aW1lc3RhbXA7XHJcbiAgfVxyXG5cclxuICBnZXRJbmRleEZvckN1cnJlbnRUaW1lc3RhbXAoKSB7XHJcbiAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLmN1cnJlbnRUaW1lc3RhbXAgLyB0aGlzLnNldHRpbmdzLnBlcmlvZCkgJSB0aGlzLnNldHRpbmdzLnNwcml0ZXMubGVuZ3RoO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFR3b1dheXNBbmltYXRpb24ge1xyXG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzLCBldmVudEJ1cykge1xyXG4gICAgdGhpcy5iYXNlQW5pbWF0aW9uID0gbmV3IExvb3BBbmltYXRpb24oc2V0dGluZ3MpO1xyXG4gICAgdGhpcy5hbHRlcm5hdGVUaW1lc3RhbXAgPSAwO1xyXG4gICAgdGhpcy5hbmltYXRpb25SdW5uaW5nID0gZmFsc2U7XHJcbiAgICB0aGlzLmFuaW1hdGlvbkZvcndhcmQgPSB0cnVlO1xyXG4gICAgaWYgKHNldHRpbmdzLnN1YnNjcmliZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGV2ZW50QnVzLnN1YnNjcmliZShzZXR0aW5ncy5zdWJzY3JpYmUsICgpID0+IHRoaXMubGF1bmNoKCkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbGF1bmNoKCkge1xyXG4gICAgdGhpcy5hbmltYXRpb25SdW5uaW5nID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGdldFNwcml0ZSh0aW1lc3RhbXApIHtcclxuICAgIHRoaXMuYWR2YW5jZVRpbWUodGltZXN0YW1wKTtcclxuICAgIHJldHVybiB0aGlzLmJhc2VBbmltYXRpb24uZ2V0U3ByaXRlKHRoaXMuYWx0ZXJuYXRlVGltZXN0YW1wKTtcclxuICB9XHJcblxyXG4gIGdldERlbHRhKHRpbWVzdGFtcCkge1xyXG4gICAgaWYgKHRoaXMucHJldmlvdXNUaW1lc3RhbXAgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aGlzLnByZXZpb3VzVGltZXN0YW1wID0gdGltZXN0YW1wO1xyXG4gICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIGNvbnN0IGRlbHRhID0gdGltZXN0YW1wIC0gdGhpcy5wcmV2aW91c1RpbWVzdGFtcDtcclxuICAgIHRoaXMucHJldmlvdXNUaW1lc3RhbXAgPSB0aW1lc3RhbXA7XHJcbiAgICByZXR1cm4gZGVsdGE7XHJcbiAgfVxyXG5cclxuICBhZHZhbmNlVGltZSh0aW1lc3RhbXApIHtcclxuICAgIGlmICh0aGlzLmFuaW1hdGlvblJ1bm5pbmcpIHtcclxuICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uRm9yd2FyZCkge1xyXG4gICAgICAgIHRoaXMuYWx0ZXJuYXRlVGltZXN0YW1wICs9IHRoaXMuZ2V0RGVsdGEodGltZXN0YW1wKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmFsdGVybmF0ZVRpbWVzdGFtcCAtPSB0aGlzLmdldERlbHRhKHRpbWVzdGFtcCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuYWx0ZXJuYXRlVGltZXN0YW1wIDwgMCkge1xyXG4gICAgICAgIHRoaXMuYWx0ZXJuYXRlVGltZXN0YW1wID0gMDtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvblJ1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvbkZvcndhcmQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMucHJldmlvdXNUaW1lc3RhbXAgPSB1bmRlZmluZWQ7XHJcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5hbHRlcm5hdGVUaW1lc3RhbXAgPj0gdGhpcy5iYXNlQW5pbWF0aW9uLmxvb3BMaW1pdCkge1xyXG4gICAgICAgIHRoaXMuYWx0ZXJuYXRlVGltZXN0YW1wID0gdGhpcy5iYXNlQW5pbWF0aW9uLmxvb3BMaW1pdCAtMTtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvblJ1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvbkZvcndhcmQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnByZXZpb3VzVGltZXN0YW1wID0gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59IiwiZXhwb3J0IGNsYXNzIEV2ZW50IHtcclxuICBzdGF0aWMgR2FtZVJlc2V0ID0gbmV3IEV2ZW50KCdnYW1lLXJlc2V0Jyk7XHJcbiAgc3RhdGljIEdhbWVTdGFydGVkID0gbmV3IEV2ZW50KCdnYW1lLXN0YXJ0ZWQnKTtcclxuICBzdGF0aWMgR2FtZUZpbmlzaGVkID0gbmV3IEV2ZW50KCdnYW1lLWZpbmlzaGVkJyk7XHJcbiAgc3RhdGljIFBsYXllck1vdmVkID0gbmV3IEV2ZW50KCdwbGF5ZXItbW92ZWQnKTtcclxuICBzdGF0aWMgUGxheWVyRGllZCA9IG5ldyBFdmVudCgncGxheWVyLWRpZWQnKTtcclxuICBzdGF0aWMgUGxheWVyV29uID0gbmV3IEV2ZW50KCdwbGF5ZXItd29uJyk7XHJcbiAgc3RhdGljIFBsYXllclNob3QgPSBuZXcgRXZlbnQoJ3BsYXllci1zaG90Jyk7XHJcbiAgc3RhdGljIEludGVycHJldGVyU3RlcCA9IG5ldyBFdmVudCgnaW50ZXJwcmV0ZXItc3RlcCcpO1xyXG4gIHN0YXRpYyBTY29yZSA9IG5ldyBFdmVudCgnZ2FtZS1zY29yZScpO1xyXG5cclxuICBjb25zdHJ1Y3RvcihjaGFubmVsTmFtZSkge1xyXG4gICAgdGhpcy5jaGFubmVsTmFtZSA9IGNoYW5uZWxOYW1lO1xyXG4gIH1cclxufSIsImltcG9ydCB7IEdyaWRDb29yZGluYXRlc1RyYW5zbGF0b3IgfSBmcm9tICcuLi91dGlsL2dyaWQtY29vcmRpbmF0ZXMnO1xyXG5pbXBvcnQgeyBBbmltYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9hbmltYXRpb24nO1xyXG5pbXBvcnQgeyBFdmVudCB9IGZyb20gJy4vZXZlbnQnO1xyXG5cclxuLy8gRW51bXNcclxuZXhwb3J0IGNsYXNzIExvZ2ljQmxvY2sge1xyXG4gIHN0YXRpYyBXYWxsID0gbmV3IExvZ2ljQmxvY2soXCLilohcIik7XHJcbiAgc3RhdGljIEV4aXQgPSBuZXcgTG9naWNCbG9jayhcIuKWkVwiKTtcclxuICBzdGF0aWMgU3BhY2UgPSBuZXcgTG9naWNCbG9jayhcIiBcIik7XHJcbiAgc3RhdGljIFpvbWJpZSA9IG5ldyBMb2dpY0Jsb2NrKFwi8J+RvlwiKTtcclxuICBzdGF0aWMgU3BoaW54ID0gbmV3IExvZ2ljQmxvY2soXCLwn5KAXCIpO1xyXG4gIHN0YXRpYyBOdWxsID0gbmV3IExvZ2ljQmxvY2soXCJYXCIpO1xyXG5cclxuICBjb25zdHJ1Y3RvcihzeW1ib2wpIHtcclxuICAgIHRoaXMuc3ltYm9sID0gc3ltYm9sO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIENhcmRpbmFsRGlyZWN0aW9uIHtcclxuICBzdGF0aWMgTm9ydGggPSBuZXcgQ2FyZGluYWxEaXJlY3Rpb24oXHJcbiAgICBcIuKWslwiLCBcclxuICAgIHBvc2l0aW9uID0+ICh7eDogcG9zaXRpb24ueCwgeTogcG9zaXRpb24ueSAtIDF9KSxcclxuICAgIHBvc2l0aW9uID0+ICh7eDogcG9zaXRpb24ueCwgeTogcG9zaXRpb24ueSArIDF9KVxyXG4gICk7XHJcbiAgc3RhdGljIEVhc3QgPSBuZXcgQ2FyZGluYWxEaXJlY3Rpb24oXHJcbiAgICBcIuKWtlwiLCBcclxuICAgIHBvc2l0aW9uID0+ICh7eDogcG9zaXRpb24ueCArIDEsIHk6IHBvc2l0aW9uLnl9KSxcclxuICAgIHBvc2l0aW9uID0+ICh7eDogcG9zaXRpb24ueCAtIDEsIHk6IHBvc2l0aW9uLnl9KVxyXG4gICk7XHJcbiAgc3RhdGljIFNvdXRoID0gbmV3IENhcmRpbmFsRGlyZWN0aW9uKFxyXG4gICAgXCLilrxcIiwgXHJcbiAgICBwb3NpdGlvbiA9PiAoe3g6IHBvc2l0aW9uLngsIHk6IHBvc2l0aW9uLnkgKyAxfSksXHJcbiAgICBwb3NpdGlvbiA9PiAoe3g6IHBvc2l0aW9uLngsIHk6IHBvc2l0aW9uLnkgLSAxfSlcclxuICApO1xyXG4gIHN0YXRpYyBXZXN0ID0gbmV3IENhcmRpbmFsRGlyZWN0aW9uKFxyXG4gICAgXCLil4BcIiwgXHJcbiAgICBwb3NpdGlvbiA9PiAoe3g6IHBvc2l0aW9uLnggLSAxLCB5OiBwb3NpdGlvbi55fSksXHJcbiAgICBwb3NpdGlvbiA9PiAoe3g6IHBvc2l0aW9uLnggKyAxLCB5OiBwb3NpdGlvbi55fSlcclxuICApO1xyXG5cclxuICBjb25zdHJ1Y3RvcihzeW1ib2wsIGFkdmFuY2VQb3NpdGlvbiwgcmV0cmVhdFBvc2l0aW9uKSB7XHJcbiAgICB0aGlzLnN5bWJvbCA9IHN5bWJvbDtcclxuICAgIHRoaXMuYWR2YW5jZVBvc2l0aW9uID0gYWR2YW5jZVBvc2l0aW9uO1xyXG4gICAgdGhpcy5yZXRyZWF0UG9zaXRpb24gPSByZXRyZWF0UG9zaXRpb247XHJcbiAgfVxyXG5cclxuICBhZHZhbmNlKHBvc2l0aW9uKSB7XHJcbiAgICByZXR1cm4gdGhpcy5hZHZhbmNlUG9zaXRpb24ocG9zaXRpb24pO1xyXG4gIH1cclxuXHJcbiAgcmV0cmVhdChwb3NpdGlvbikge1xyXG4gICAgcmV0dXJuIHRoaXMucmV0cmVhdFBvc2l0aW9uKHBvc2l0aW9uKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBvcmRlciA9IFt0aGlzLk5vcnRoLCB0aGlzLkVhc3QsIHRoaXMuU291dGgsIHRoaXMuV2VzdF07XHJcbiAgc3RhdGljIHRvVGhlUmlnaHQoZGlyZWN0aW9uKSB7XHJcbiAgICBjb25zdCBpbmRleCA9IHRoaXMub3JkZXIuaW5kZXhPZihkaXJlY3Rpb24pICsgMTtcclxuICAgIHJldHVybiB0aGlzLm9yZGVyW2luZGV4ICUgNF07XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgdG9UaGVMZWZ0KGRpcmVjdGlvbikge1xyXG4gICAgY29uc3QgaW5kZXggPSB0aGlzLm9yZGVyLmluZGV4T2YoZGlyZWN0aW9uKSAtIDE7XHJcbiAgICByZXR1cm4gdGhpcy5vcmRlclsoKGluZGV4ID4gLTEpID8gaW5kZXggOiAzKV07XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgYmFja3dhcmRzKGRpcmVjdGlvbikge1xyXG4gICAgY29uc3QgaW5kZXggPSB0aGlzLm9yZGVyLmluZGV4T2YoZGlyZWN0aW9uKSArIDI7XHJcbiAgICByZXR1cm4gdGhpcy5vcmRlcltpbmRleCAlIDRdO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIE1vdmVEaXJlY3Rpb24ge1xyXG4gIHN0YXRpYyBGb3J0aCA9IG5ldyBNb3ZlRGlyZWN0aW9uKChjYXJkaW5hbERpcmVjdGlvbiwgcGxheWVyKSA9PiBjYXJkaW5hbERpcmVjdGlvbi5hZHZhbmNlKHBsYXllcikpO1xyXG4gIHN0YXRpYyBCYWNrID0gbmV3IE1vdmVEaXJlY3Rpb24oKGNhcmRpbmFsRGlyZWN0aW9uLCBwbGF5ZXIpID0+IGNhcmRpbmFsRGlyZWN0aW9uLnJldHJlYXQocGxheWVyKSk7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGFwcGx5KSB7XHJcbiAgICB0aGlzLmFwcGx5ID0gYXBwbHk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBUT0RPOiBNYXliZSBleHRyYWN0IHBvc2l0aW9uIGNsYXNzXHJcbmNsYXNzIE1vdmFibGUge1xyXG4gIGNvbnN0cnVjdG9yKHgsIHksIGRpcmVjdGlvbikge1xyXG4gICAgdGhpcy54ID0geDtcclxuICAgIHRoaXMueSA9IHk7XHJcbiAgICB0aGlzLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcclxuICAgIHRoaXMuY3Jhc2hlZCA9IGZhbHNlO1xyXG4gIH1cclxuICBcclxuICBpc0F0KHgsIHkpIHtcclxuICAgIHJldHVybiB0aGlzLnggPT0geCAmJiB0aGlzLnkgPT0geTtcclxuICB9XHJcblxyXG4gIG1vdmUobW92ZURpcmVjdGlvbikge1xyXG4gICAgY29uc3QgbmV3UG9zaXRpb24gPSBtb3ZlRGlyZWN0aW9uLmFwcGx5KHRoaXMuZGlyZWN0aW9uLCB0aGlzKTtcclxuICAgIHRoaXMueCA9IG5ld1Bvc2l0aW9uLng7XHJcbiAgICB0aGlzLnkgPSBuZXdQb3NpdGlvbi55O1xyXG4gIH1cclxuXHJcbiAgd291bGRNb3ZlKG1vdmVEaXJlY3Rpb24pIHtcclxuICAgIHJldHVybiBtb3ZlRGlyZWN0aW9uLmFwcGx5KHRoaXMuZGlyZWN0aW9uLCB0aGlzKTtcclxuICB9XHJcblxyXG4gIHdvdWxkTW92ZVRvKG1vdmVEaXJlY3Rpb24sIHgsIHkpIHtcclxuICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0gdGhpcy53b3VsZE1vdmUobW92ZURpcmVjdGlvbik7XHJcbiAgICByZXR1cm4gbmV3UG9zaXRpb24ueCA9PT0geCAmJiBuZXdQb3NpdGlvbi55ID09PSB5O1xyXG4gIH1cclxuXHJcbiAgcm90YXRlTGVmdCgpIHtcclxuICAgIHRoaXMuZGlyZWN0aW9uID0gQ2FyZGluYWxEaXJlY3Rpb24udG9UaGVMZWZ0KHRoaXMuZGlyZWN0aW9uKTtcclxuICB9XHJcbiAgcm90YXRlUmlnaHQoKSB7XHJcbiAgICB0aGlzLmRpcmVjdGlvbiA9IENhcmRpbmFsRGlyZWN0aW9uLnRvVGhlUmlnaHQodGhpcy5kaXJlY3Rpb24pO1xyXG4gIH1cclxuICByb3RhdGVCYWNrKCkge1xyXG4gICAgdGhpcy5kaXJlY3Rpb24gPSBDYXJkaW5hbERpcmVjdGlvbi5iYWNrd2FyZHModGhpcy5kaXJlY3Rpb24pO1xyXG4gIH1cclxuICBcclxuICBjcmFzaCgpIHtcclxuICAgIHRoaXMuY3Jhc2hlZCA9IHRydWU7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgWm9tYmllIGV4dGVuZHMgTW92YWJsZSB7XHJcbiAgY29uc3RydWN0b3IoeCwgeSwgZGlyZWN0aW9uKSB7XHJcbiAgICBzdXBlcih4LCB5LCBkaXJlY3Rpb24pO1xyXG4gICAgdGhpcy5zcHJpdGUgPSBudWxsO1xyXG4gICAgdGhpcy5kZWFkID0gbnVsbDtcclxuICB9XHJcblxyXG4gIHNldHVwU3ByaXRlcyh0aGVtZSkge1xyXG4gICAgdGhpcy5zcHJpdGUgPSB0aGVtZS5zcHJpdGVbJ3pvbWJpZSddO1xyXG4gICAgdGhpcy5kZWFkID0gdGhlbWUuc3ByaXRlWydkZWFkWm9tYmllJ107XHJcbiAgfVxyXG5cclxuICBnZXRTcHJpdGUoKSB7XHJcbiAgICByZXR1cm4gKHRoaXMuY3Jhc2hlZCkgPyB0aGlzLmRlYWQgOiB0aGlzLnNwcml0ZTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBQbGF5ZXIgZXh0ZW5kcyBNb3ZhYmxlIHtcclxuICBjb25zdHJ1Y3Rvcih4LCB5LCBkaXJlY3Rpb24pIHtcclxuICAgIHN1cGVyKHgsIHksIGRpcmVjdGlvbik7XHJcbiAgICB0aGlzLmRvbmUgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIHNldHVwU3ByaXRlcyh0aGVtZSkge1xyXG4gICAgQ2FyZGluYWxEaXJlY3Rpb24uTm9ydGguc3ByaXRlID0gdGhlbWUuc3ByaXRlWydub3J0aCddO1xyXG4gICAgQ2FyZGluYWxEaXJlY3Rpb24uRWFzdC5zcHJpdGUgPSB0aGVtZS5zcHJpdGVbJ2Vhc3QnXTtcclxuICAgIENhcmRpbmFsRGlyZWN0aW9uLlNvdXRoLnNwcml0ZSA9IHRoZW1lLnNwcml0ZVsnc291dGgnXTtcclxuICAgIENhcmRpbmFsRGlyZWN0aW9uLldlc3Quc3ByaXRlID0gdGhlbWUuc3ByaXRlWyd3ZXN0J107XHJcbiAgICBDYXJkaW5hbERpcmVjdGlvbi5Ob3J0aC5hcnJvd1Nwcml0ZSA9IHRoZW1lLnNwcml0ZVsnbmV4dE5vcnRoJ107XHJcbiAgICBDYXJkaW5hbERpcmVjdGlvbi5FYXN0LmFycm93U3ByaXRlID0gdGhlbWUuc3ByaXRlWyduZXh0RWFzdCddO1xyXG4gICAgQ2FyZGluYWxEaXJlY3Rpb24uU291dGguYXJyb3dTcHJpdGUgPSB0aGVtZS5zcHJpdGVbJ25leHRTb3V0aCddO1xyXG4gICAgQ2FyZGluYWxEaXJlY3Rpb24uV2VzdC5hcnJvd1Nwcml0ZSA9IHRoZW1lLnNwcml0ZVsnbmV4dFdlc3QnXTtcclxuICAgIHRoaXMuZGVhZFNwcml0ZSA9IHRoZW1lLnNwcml0ZVsnZGVhZCddO1xyXG4gIH1cclxuXHJcbiAgc3Vic2NyaWJlVG9FdmVudHMoZXZlbnRCdXMpIHtcclxuICAgIGV2ZW50QnVzLnN1YnNjcmliZShFdmVudC5QbGF5ZXJEaWVkLmNoYW5uZWxOYW1lLCAoKSA9PiB0aGlzLmNyYXNoKCkpO1xyXG4gICAgZXZlbnRCdXMuc3Vic2NyaWJlKEV2ZW50LlBsYXllcldvbi5jaGFubmVsTmFtZSwgKCkgPT4gdGhpcy5maW5pc2goKSk7XHJcbiAgfVxyXG5cclxuICBnZXRTcHJpdGUoKSB7XHJcbiAgICBpZiAodGhpcy5jcmFzaGVkKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmRlYWRTcHJpdGU7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuZG9uZSkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmRpcmVjdGlvbi5zcHJpdGU7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIGdldE5leHRNb3ZlU3ByaXRlKCkge1xyXG4gICAgaWYgKHRoaXMuY3Jhc2hlZCB8fCB0aGlzLmRvbmUpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb24uYXJyb3dTcHJpdGU7XHJcbiAgfVxyXG5cclxuICBnZXRTaG9vdFRhcmdldCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRpcmVjdGlvbi5hZHZhbmNlKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgZmluaXNoKCkge1xyXG4gICAgdGhpcy5kb25lID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGdldExlZnRQb3NpdGlvbigpIHtcclxuICAgIGNvbnN0IGxlZnREaXJlY3Rpb24gPSBDYXJkaW5hbERpcmVjdGlvbi50b1RoZUxlZnQodGhpcy5kaXJlY3Rpb24pO1xyXG4gICAgcmV0dXJuIE1vdmVEaXJlY3Rpb24uRm9ydGguYXBwbHkobGVmdERpcmVjdGlvbiwgdGhpcyk7XHJcbiAgfVxyXG4gIGdldFJpZ2h0UG9zaXRpb24oKSB7XHJcbiAgICBjb25zdCByaWdodERpcmVjdGlvbiA9IENhcmRpbmFsRGlyZWN0aW9uLnRvVGhlUmlnaHQodGhpcy5kaXJlY3Rpb24pO1xyXG4gICAgcmV0dXJuIE1vdmVEaXJlY3Rpb24uRm9ydGguYXBwbHkocmlnaHREaXJlY3Rpb24sIHRoaXMpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEJvYXJkIHtcclxuICBjb25zdHJ1Y3RvcihldmVudEJ1cykge1xyXG4gICAgdGhpcy5ldmVudEJ1cyA9IGV2ZW50QnVzO1xyXG4gIH1cclxuXHJcbiAgbG9hZFNjZW5lKHNjZW5lKSB7XHJcbiAgICB0aGlzLnNjZW5lID0gc2NlbmU7XHJcbiAgICB0aGlzLmdyaWRDb29yZGluYXRlc1RyYW5zbGF0b3IgPSBuZXcgR3JpZENvb3JkaW5hdGVzVHJhbnNsYXRvcih0aGlzLnNjZW5lLndpZHRoLCB0aGlzLnNjZW5lLmhlaWdodCk7XHJcbiAgICB0aGlzLmFuaW1hdGlvblNlcnZpY2UgPSBuZXcgQW5pbWF0aW9uU2VydmljZSh0aGlzLnNjZW5lLnRoZW1lLmFuaW1hdGlvbnMsIHRoaXMuZXZlbnRCdXMpO1xyXG4gIH1cclxuXHJcbiAgZ2V0U3ByaXRlKHgsIHksIHRpbWVzdGFtcCkge1xyXG4gICAgY29uc3QgYW5pbWF0aW9uU3ByaXRlID0gdGhpcy5hbmltYXRpb25TZXJ2aWNlLmdldFNwcml0ZSh4LCB5LCB0aW1lc3RhbXApO1xyXG4gICAgaWYgKGFuaW1hdGlvblNwcml0ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybiBhbmltYXRpb25TcHJpdGU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBJbnZlcnQgYXhpcyB0byBtYXRjaCBjYW52YXMgdG8gSlNPTiBtYXRyaXhcclxuICAgICAgcmV0dXJuIHRoaXMuc2NlbmUubWFwW3ldW3hdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZ2V0TG9naWNMYWJlbEZvclNwcml0ZShzcHJpdGUpIHtcclxuICAgIHJldHVybiB0aGlzLnNjZW5lLmxvZ2ljW3Nwcml0ZV07XHJcbiAgfVxyXG5cclxuICBnZXRMb2dpYyh4LCB5KSB7XHJcbiAgICBjb25zdCB0ZXh0ID0gdGhpcy5nZXRMb2dpY0xhYmVsRm9yU3ByaXRlKHRoaXMuZ2V0U3ByaXRlKHgsIHkpKTtcclxuICAgIGlmICh0ZXh0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuIExvZ2ljQmxvY2suV2FsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBMb2dpY0Jsb2NrW3RleHRdO1xyXG4gIH1cclxuXHJcbiAgZ2V0U2xvdEluZGV4Rm9yKHgsIHkpIHtcclxuICAgIHJldHVybiB0aGlzLmdyaWRDb29yZGluYXRlc1RyYW5zbGF0b3IuZ2V0U2xvdEluZGV4Rm9yKHgsIHkpO1xyXG4gIH1cclxuXHJcbiAgZ2V0Q29vcmRpbmF0ZXNGb3IoaW5kZXgpIHtcclxuICAgIHJldHVybiB0aGlzLmdyaWRDb29yZGluYXRlc1RyYW5zbGF0b3IuZ2V0Q29vcmRpbmF0ZXNGb3IoaW5kZXgpO1xyXG4gIH1cclxufVxyXG4iLCJjb25zdCBzb3VuZEJhc2VVcmwgPSAnL3NpZGlsYS9zbmQvJztcclxuXHJcbmV4cG9ydCBjbGFzcyBTb3VuZCB7XHJcbiAgY29uc3RydWN0b3IoZmlsZSkge1xyXG4gICAgdGhpcy5zb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhdWRpb1wiKTtcclxuICAgIHRoaXMuc291bmQuc3JjID0gYCR7c291bmRCYXNlVXJsfS8ke2ZpbGV9YDtcclxuICB9XHJcblxyXG4gIHBsYXkoKSB7XHJcbiAgICB0aGlzLnNvdW5kLnBsYXkoKTtcclxuICB9XHJcbiAgcGF1c2UoKSB7XHJcbiAgICB0aGlzLnNvdW5kLnBhdXNlKCk7XHJcbiAgfVxyXG59IiwiZXhwb3J0IGNsYXNzIFNjZW5lU2VydmljZSB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLnNjZW5lcyA9IFtcclxuICAgICAgcmVxdWlyZSgnLi9zY2VuZS9kdW5nZW9uLTEnKSxcclxuICAgICAgcmVxdWlyZSgnLi9zY2VuZS9kdW5nZW9uLTInKSxcclxuICAgICAgcmVxdWlyZSgnLi9zY2VuZS9kdW5nZW9uLTMnKSxcclxuICAgICAgcmVxdWlyZSgnLi9zY2VuZS9kdW5nZW9uLTQnKSxcclxuICAgICAgcmVxdWlyZSgnLi9zY2VuZS9jZW1ldGVyeS0xJylcclxuICAgIF1cclxuICB9XHJcblxyXG4gIGdldChpbmRleCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc2NlbmVzW2luZGV4XTtcclxuICB9XHJcblxyXG4gIGdldFNjZW5lQ291bnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zY2VuZXMubGVuZ3RoO1xyXG4gIH1cclxufSIsImltcG9ydCB7IExvZ2ljQmxvY2ssIENhcmRpbmFsRGlyZWN0aW9uLCBQbGF5ZXIsIFpvbWJpZSwgQm9hcmQsIE1vdmVEaXJlY3Rpb24gfSBmcm9tICcuL2JvYXJkJztcclxuaW1wb3J0IHsgU291bmQgfSBmcm9tICcuLi9zb3VuZCc7XHJcbmltcG9ydCB7IFNjZW5lU2VydmljZSB9IGZyb20gJy4uL3NjZW5lJztcclxuaW1wb3J0IHsgRXZlbnQgfSBmcm9tICcuL2V2ZW50JztcclxuXHJcbmV4cG9ydCBjbGFzcyBHYW1lUmVzdWx0IHtcclxuICBzdGF0aWMgTm90RmluaXNoZWQgPSBuZXcgR2FtZVJlc3VsdCgpO1xyXG4gIHN0YXRpYyBXb24gPSBuZXcgR2FtZVJlc3VsdCgpO1xyXG4gIHN0YXRpYyBEaWVkID0gbmV3IEdhbWVSZXN1bHQoKTtcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEdhbWVCb2FyZCBleHRlbmRzIEJvYXJkIHtcclxuICBjb25zdHJ1Y3RvcihldmVudEJ1cykge1xyXG4gICAgc3VwZXIoZXZlbnRCdXMpO1xyXG4gICAgdGhpcy5zY2VuZVNlcnZpY2UgPSBuZXcgU2NlbmVTZXJ2aWNlKCk7XHJcbiAgICB0aGlzLnNvdW5kT24gPSB0cnVlO1xyXG4gICAgdGhpcy5zb3VuZE1hcCA9IHtcclxuICAgICAgc3RlcDogbmV3IFNvdW5kKCdzdGVwLm9nZycpLFxyXG4gICAgICBiYW5nOiBuZXcgU291bmQoJ2Jhbmcub2dnJyksXHJcbiAgICAgIHdpbjogbmV3IFNvdW5kKCd3aW4ub2dnJyksXHJcbiAgICAgIGdhbWVPdmVyOiBuZXcgU291bmQoJ2dhbWVvdmVyLm9nZycpXHJcbiAgICB9O1xyXG4gICAgdGhpcy5zdWJzY3JpYmVUb0V2ZW50cygpO1xyXG4gICAgdGhpcy5yZXNldCgwKTtcclxuICB9XHJcblxyXG4gIC8vIFRPRE86IExldCBvdGhlciBjbGFzc2VzIHN1YnNjcmliZSBldmVudHMgdG8gc2ltcGxpZnkgR2FtZUJvYXJkIFxyXG4gIHN1YnNjcmliZVRvRXZlbnRzKCkge1xyXG4gICAgdGhpcy5ldmVudEJ1cy5zdWJzY3JpYmUoRXZlbnQuUGxheWVyTW92ZWQuY2hhbm5lbE5hbWUsICgpID0+IHRoaXMucGxheVNvdW5kKHRoaXMuc291bmRNYXAuc3RlcCkpO1xyXG4gICAgdGhpcy5ldmVudEJ1cy5zdWJzY3JpYmUoRXZlbnQuUGxheWVyU2hvdC5jaGFubmVsTmFtZSwgKCkgPT4gdGhpcy5wbGF5U291bmQodGhpcy5zb3VuZE1hcC5iYW5nKSk7XHJcbiAgICB0aGlzLmV2ZW50QnVzLnN1YnNjcmliZShFdmVudC5QbGF5ZXJEaWVkLmNoYW5uZWxOYW1lLCAoKSA9PiB0aGlzLnBsYXlTb3VuZCh0aGlzLnNvdW5kTWFwLmdhbWVPdmVyKSk7XHJcbiAgICB0aGlzLmV2ZW50QnVzLnN1YnNjcmliZShFdmVudC5QbGF5ZXJXb24uY2hhbm5lbE5hbWUsIChjb29yZGluYXRlcykgPT4ge1xyXG4gICAgICB0aGlzLmFuaW1hdGlvblNlcnZpY2UudHJpZ2dlcihjb29yZGluYXRlcy54LCBjb29yZGluYXRlcy55KTtcclxuICAgICAgdGhpcy5wbGF5U291bmQodGhpcy5zb3VuZE1hcC53aW4pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICByZXNldChzY2VuZUluZGV4KSB7XHJcbiAgICBjb25zdCBzY2VuZSA9IHRoaXMuc2NlbmVTZXJ2aWNlLmdldChzY2VuZUluZGV4KTtcclxuICAgIHRoaXMubG9hZFNjZW5lKHNjZW5lKTtcclxuICAgIHRoaXMucGxheWVyID0gbmV3IFBsYXllcihcclxuICAgICAgdGhpcy5zY2VuZS5wbGF5ZXIueCxcclxuICAgICAgdGhpcy5zY2VuZS5wbGF5ZXIueSxcclxuICAgICAgQ2FyZGluYWxEaXJlY3Rpb25bdGhpcy5zY2VuZS5wbGF5ZXIuZGlyZWN0aW9uXVxyXG4gICAgKTtcclxuICAgIHRoaXMucGxheWVyLnN1YnNjcmliZVRvRXZlbnRzKHRoaXMuZXZlbnRCdXMpO1xyXG4gICAgdGhpcy56b21iaWUgPSBuZXcgWm9tYmllKFxyXG4gICAgICB0aGlzLnNjZW5lLnpvbWJpZS54LFxyXG4gICAgICB0aGlzLnNjZW5lLnpvbWJpZS55LFxyXG4gICAgICBDYXJkaW5hbERpcmVjdGlvbi5Ob3J0aFxyXG4gICAgKTtcclxuICAgIHRoaXMucGxheWVyLnNldHVwU3ByaXRlcyh0aGlzLnNjZW5lLnRoZW1lKTtcclxuICAgIHRoaXMuem9tYmllLnNldHVwU3ByaXRlcyh0aGlzLnNjZW5lLnRoZW1lKTtcclxuICAgIHRoaXMuZ2FtZVJlc3VsdCA9IEdhbWVSZXN1bHQuTm90RmluaXNoZWQ7XHJcbiAgICB0aGlzLm1vdmVzID0gMDtcclxuICAgIHRoaXMuc2hvdHMgPSAwO1xyXG4gICAgdGhpcy5wdWJsaXNoTm9EYXRhRXZlbnQoRXZlbnQuR2FtZVJlc2V0KTtcclxuICB9XHJcblxyXG4gIGdldFNjZW5lQ291bnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zY2VuZVNlcnZpY2UuZ2V0U2NlbmVDb3VudCgpO1xyXG4gIH1cclxuXHJcbiAgY2FuTW92ZUludG8oeCwgeSkge1xyXG4gICAgY29uc3QgbG9naWMgPSB0aGlzLmdldExvZ2ljKHgsIHkpO1xyXG4gICAgcmV0dXJuIGxvZ2ljID09PSBMb2dpY0Jsb2NrLlNwYWNlIHx8IGxvZ2ljID09PSBMb2dpY0Jsb2NrLkV4aXQ7XHJcbiAgfVxyXG5cclxuICBpc0NyYXNoZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wbGF5ZXIuY3Jhc2hlZDtcclxuICB9XHJcblxyXG4gIGlzRG9uZSgpIHtcclxuICAgIHJldHVybiB0aGlzLnBsYXllci5kb25lO1xyXG4gIH1cclxuXHJcbiAgc3RhcnQoKSB7XHJcbiAgICB0aGlzLnB1Ymxpc2hOb0RhdGFFdmVudChFdmVudC5HYW1lU3RhcnRlZCk7XHJcbiAgfVxyXG5cclxuICBtb3ZlUGxheWVyKG1vdmVEaXJlY3Rpb24pIHtcclxuICAgIHRoaXMucHVibGlzaFBsYXllck1vdmVkKG1vdmVEaXJlY3Rpb24pO1xyXG4gICAgY29uc3QgbmV3UG9zaXRpb24gPSB0aGlzLnBsYXllci53b3VsZE1vdmUobW92ZURpcmVjdGlvbik7XHJcbiAgICBpZiAodGhpcy5jYW5Nb3ZlSW50byhuZXdQb3NpdGlvbi54LCBuZXdQb3NpdGlvbi55KSkge1xyXG4gICAgICB0aGlzLnBsYXllci5tb3ZlKG1vdmVEaXJlY3Rpb24pO1xyXG4gICAgICBpZiAodGhpcy5nZXRMb2dpY0Fyb3VuZCh0aGlzLnBsYXllci54LCB0aGlzLnBsYXllci55KS5pbmNsdWRlcyhMb2dpY0Jsb2NrLlNwaGlueCkpIHtcclxuICAgICAgICB0aGlzLmtpbGxQbGF5ZXIoKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBwbGF5ZXJMb2dpYyA9IHRoaXMuZ2V0TG9naWModGhpcy5wbGF5ZXIueCwgdGhpcy5wbGF5ZXIueSk7XHJcbiAgICAgIGlmIChwbGF5ZXJMb2dpYyA9PT0gTG9naWNCbG9jay5FeGl0KSB7XHJcbiAgICAgICAgdGhpcy5leGl0UGxheWVyKCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMua2lsbFBsYXllcigpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5tb3ZlcysrO1xyXG4gICAgaWYgKHRoaXMucGxheWVyLmNyYXNoZWQgfHwgdGhpcy5wbGF5ZXIuZG9uZSkge1xyXG4gICAgICB0aGlzLnB1Ymxpc2hHYW1lRmluaXNoZWQoKTtcclxuICAgIH1cclxuICB9XHJcbiAgcm90YXRlUGxheWVyTGVmdCgpIHtcclxuICAgIHRoaXMucGxheWVyLnJvdGF0ZUxlZnQoKTtcclxuICB9XHJcbiAgcm90YXRlUGxheWVyUmlnaHQoKSB7XHJcbiAgICB0aGlzLnBsYXllci5yb3RhdGVSaWdodCgpO1xyXG4gIH1cclxuICByb3RhdGVQbGF5ZXJCYWNrKCkge1xyXG4gICAgdGhpcy5wbGF5ZXIucm90YXRlQmFjaygpO1xyXG4gIH1cclxuICBwbGF5ZXJTaG9vdCgpIHtcclxuICAgIHRoaXMucHVibGlzaE5vRGF0YUV2ZW50KEV2ZW50LlBsYXllclNob3QpO1xyXG4gICAgY29uc3Qgc2hvb3RBdCA9IHRoaXMucGxheWVyLmdldFNob290VGFyZ2V0KCk7XHJcbiAgICBpZiAodGhpcy5nZXRMb2dpYyhzaG9vdEF0LngsIHNob290QXQueSkgPT09IExvZ2ljQmxvY2suWm9tYmllKSB7XHJcbiAgICAgIHRoaXMuem9tYmllLmNyYXNoKCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnNob3RzKys7XHJcbiAgfVxyXG4gIGtpbGxQbGF5ZXIoKSB7XHJcbiAgICB0aGlzLnB1Ymxpc2hQbGF5ZXJEaWVkKCk7XHJcbiAgICB0aGlzLmdhbWVSZXN1bHQgPSBHYW1lUmVzdWx0LkRpZWQ7XHJcbiAgfVxyXG4gIGV4aXRQbGF5ZXIoKSB7XHJcbiAgICB0aGlzLnB1Ymxpc2hQbGF5ZXJXb24oeyB4OiB0aGlzLnBsYXllci54LCB5OiB0aGlzLnBsYXllci55IH0pO1xyXG4gICAgdGhpcy5nYW1lUmVzdWx0ID0gR2FtZVJlc3VsdC5Xb247XHJcbiAgfVxyXG5cclxuICBnZXRMb2dpYyh4LCB5KSB7XHJcbiAgICBpZiAoeCA8IDAgfHwgeSA8IDAgfHwgeCA+IHRoaXMuc2NlbmUud2lkdGggLSAxIHx8IHkgPiB0aGlzLnNjZW5lLmhlaWdodCAtIDEpIHtcclxuICAgICAgcmV0dXJuIExvZ2ljQmxvY2suTnVsbDtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLnpvbWJpZT8uaXNBdCh4LCB5KSAmJiB0aGlzLnpvbWJpZT8uY3Jhc2hlZCAhPT0gdHJ1ZSkge1xyXG4gICAgICByZXR1cm4gTG9naWNCbG9jay5ab21iaWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3VwZXIuZ2V0TG9naWMoeCwgeSk7XHJcbiAgfVxyXG4gIGdldExvZ2ljQXJvdW5kKHgsIHkpIHtcclxuICAgIHJldHVybiBbXHJcbiAgICAgIHRoaXMuZ2V0TG9naWMoeCwgeS0xKSxcclxuICAgICAgdGhpcy5nZXRMb2dpYyh4LCB5KzEpLFxyXG4gICAgICB0aGlzLmdldExvZ2ljKHgtMSwgeSksXHJcbiAgICAgIHRoaXMuZ2V0TG9naWMoeCsxLCB5KSxcclxuICAgIF07XHJcbiAgfVxyXG4gIGdldExvZ2ljSW5Gcm9udE9mUGxheWVyKCkge1xyXG4gICAgY29uc3QgaW5Gcm9udFBvc2l0aW9uID0gdGhpcy5wbGF5ZXIud291bGRNb3ZlKE1vdmVEaXJlY3Rpb24uRm9ydGgpO1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0TG9naWMoaW5Gcm9udFBvc2l0aW9uLngsIGluRnJvbnRQb3NpdGlvbi55KTtcclxuICB9XHJcbiAgZ2V0TG9naWNUb1RoZUxlZnRPZlBsYXllcigpIHtcclxuICAgIGNvbnN0IGF0VGhlTGVmdFBvc2l0aW9uID0gdGhpcy5wbGF5ZXIuZ2V0TGVmdFBvc2l0aW9uKCk7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRMb2dpYyhhdFRoZUxlZnRQb3NpdGlvbi54LCBhdFRoZUxlZnRQb3NpdGlvbi55KTtcclxuICB9XHJcbiAgZ2V0TG9naWNUb1RoZVJpZ2h0T2ZQbGF5ZXIoKSB7XHJcbiAgICBjb25zdCBhdFRoZVJpZ2h0UG9zaXRpb24gPSB0aGlzLnBsYXllci5nZXRSaWdodFBvc2l0aW9uKCk7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRMb2dpYyhhdFRoZVJpZ2h0UG9zaXRpb24ueCwgYXRUaGVSaWdodFBvc2l0aW9uLnkpO1xyXG4gIH1cclxuXHJcbiAgZ2V0T3ZlcmxheVNwcml0ZSh4LCB5LCB0aW1lc3RhbXApIHtcclxuICAgIGlmICh0aGlzLnBsYXllci5pc0F0KHgsIHkpKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnBsYXllci5nZXRTcHJpdGUoKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLnpvbWJpZT8uaXNBdCh4LCB5KSkge1xyXG4gICAgICByZXR1cm4gdGhpcy56b21iaWUuZ2V0U3ByaXRlKCk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5wbGF5ZXIud291bGRNb3ZlVG8oTW92ZURpcmVjdGlvbi5Gb3J0aCwgeCwgeSkpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucGxheWVyLmdldE5leHRNb3ZlU3ByaXRlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIHNldFNvdW5kKG9uKSB7XHJcbiAgICB0aGlzLnNvdW5kT24gPSBvbjtcclxuICB9XHJcblxyXG4gIHBsYXlTb3VuZChmeCkge1xyXG4gICAgaWYgKHRoaXMuc291bmRPbikge1xyXG4gICAgICBmeC5wbGF5KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwdWJsaXNoUGxheWVyTW92ZWQobW92ZURpcmVjdGlvbikge1xyXG4gICAgdGhpcy5ldmVudEJ1cy5wdWJsaXNoKEV2ZW50LlBsYXllck1vdmVkLmNoYW5uZWxOYW1lLCBtb3ZlRGlyZWN0aW9uKTtcclxuICB9XHJcbiAgcHVibGlzaFBsYXllckRpZWQoKSB7XHJcbiAgICB0aGlzLmV2ZW50QnVzLnB1Ymxpc2goRXZlbnQuUGxheWVyRGllZC5jaGFubmVsTmFtZSwgbnVsbCk7XHJcbiAgfVxyXG4gIHB1Ymxpc2hQbGF5ZXJXb24oY29vcmRpbmF0ZXMpIHtcclxuICAgIHRoaXMuZXZlbnRCdXMucHVibGlzaChFdmVudC5QbGF5ZXJXb24uY2hhbm5lbE5hbWUsIGNvb3JkaW5hdGVzKTtcclxuICB9XHJcbiAgcHVibGlzaEdhbWVGaW5pc2hlZCgpIHtcclxuICAgIHRoaXMuZXZlbnRCdXMucHVibGlzaChFdmVudC5HYW1lRmluaXNoZWQuY2hhbm5lbE5hbWUsIHRoaXMuZ2FtZVJlc3VsdCk7XHJcbiAgfVxyXG4gIFxyXG4gIHB1Ymxpc2hOb0RhdGFFdmVudChldmVudCkge1xyXG4gICAgdGhpcy5ldmVudEJ1cy5wdWJsaXNoKGV2ZW50LmNoYW5uZWxOYW1lLCBudWxsKTtcclxuICB9XHJcbn1cclxuIiwiZXhwb3J0IGNsYXNzIEV2ZW50QnVzIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuc3Vic2NyaWJlcnMgPSB7fTtcclxuICB9XHJcblxyXG4gIHN1YnNjcmliZShjaGFubmVsLCBzdWJzY3JpYmVyKSB7XHJcbiAgICBpZiAoIU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuc3Vic2NyaWJlcnMsIGNoYW5uZWwpKSB7XHJcbiAgICAgIHRoaXMuc3Vic2NyaWJlcnNbY2hhbm5lbF0gPSBbXTtcclxuICAgIH1cclxuICAgIHRoaXMuc3Vic2NyaWJlcnNbY2hhbm5lbF0ucHVzaChzdWJzY3JpYmVyKTtcclxuICB9XHJcblxyXG4gIHVuc3Vic2NyaWJlKGNoYW5uZWwsIHN1YnNjcmliZXIpIHtcclxuICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnN1YnNjcmliZXJzLCBjaGFubmVsKSkge1xyXG4gICAgICB0aGlzLnN1YnNjcmliZXJzW2NoYW5uZWxdLnNwbGljZSh0aGlzLnN1YnNjcmliZXJzW2NoYW5uZWxdLmluZGV4T2Yoc3Vic2NyaWJlciksIDEpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHVibGlzaChjaGFubmVsLCBldmVudCkge1xyXG4gICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuc3Vic2NyaWJlcnMsIGNoYW5uZWwpKSB7XHJcbiAgICAgIHRoaXMuc3Vic2NyaWJlcnNbY2hhbm5lbF0uZm9yRWFjaChzdWJzY3JpYmVyID0+IHtcclxuICAgICAgICBzdWJzY3JpYmVyKGV2ZW50KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwiaW1wb3J0IHsgQm9hcmQgfSBmcm9tICcuL2JvYXJkJztcclxuaW1wb3J0IHsgRXZlbnRCdXMgfSBmcm9tICcuLi91dGlsL2V2ZW50LWJ1cyc7XHJcblxyXG5jb25zdCBNQVhfVU5ET19JVEVNUyA9IDEwMDtcclxuXHJcbmV4cG9ydCBjbGFzcyBFZGl0b3JCb2FyZCBleHRlbmRzIEJvYXJkIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKG5ldyBFdmVudEJ1cygpKTtcclxuICAgIHRoaXMudW5kbyA9IFtdO1xyXG4gIH1cclxuXHJcbiAgbG9hZChzb3VyY2UpIHtcclxuICAgIGNvbnN0IHNjZW5lID0gSlNPTi5wYXJzZShzb3VyY2UpO1xyXG4gICAgdGhpcy5sb2FkU2NlbmUoc2NlbmUpO1xyXG4gIH1cclxuXHJcbiAgc2F2ZSgpIHtcclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnNjZW5lLCBudWxsLCAyKTtcclxuICB9XHJcblxyXG4gIHNldFNsb3QoaW5kZXgsIHNwcml0ZSkge1xyXG4gICAgY29uc3QgY29vcmRpbmF0ZXMgPSB0aGlzLmdldENvb3JkaW5hdGVzRm9yKGluZGV4KTtcclxuICAgIGlmICh0aGlzLnNjZW5lLm1hcFtjb29yZGluYXRlcy55XVtjb29yZGluYXRlcy54XSAhPSBzcHJpdGUpIHtcclxuICAgICAgY29uc3Qgb2xkU3ByaXRlID0gdGhpcy5zY2VuZS5tYXBbY29vcmRpbmF0ZXMueV1bY29vcmRpbmF0ZXMueF07XHJcbiAgICAgIHRoaXMuYWRkVW5kbygoKSA9PiB0aGlzLnNjZW5lLm1hcFtjb29yZGluYXRlcy55XVtjb29yZGluYXRlcy54XSA9IG9sZFNwcml0ZSk7XHJcbiAgICAgIHRoaXMuc2NlbmUubWFwW2Nvb3JkaW5hdGVzLnldW2Nvb3JkaW5hdGVzLnhdID0gc3ByaXRlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYWRkVW5kbyh1bmRvQWN0aW9uKSB7XHJcbiAgICB0aGlzLnVuZG8ucHVzaCh1bmRvQWN0aW9uKTtcclxuICAgIGlmICh0aGlzLnVuZG8ubGVuZ3RoID4gTUFYX1VORE9fSVRFTVMpIHtcclxuICAgICAgdGhpcy51bmRvLnBvcCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdW5kb0xhc3RBY3Rpb24oKSB7XHJcbiAgICBjb25zdCB1bmRvQWN0aW9uID0gdGhpcy51bmRvLnBvcCgpO1xyXG4gICAgaWYgKHVuZG9BY3Rpb24gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB1bmRvQWN0aW9uKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXRPdmVybGF5U3ByaXRlKHgsIHkpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBFdmVudCB9IGZyb20gJy4vZ2FtZS9ldmVudCc7XHJcblxyXG5jb25zdCBpbWFnZUJhc2VVcmwgPSAnL3NpZGlsYS9pbWcvJztcclxuXHJcbmNsYXNzIEdyaWRQYWludGVyIHtcclxuICBjb25zdHJ1Y3RvcihjYW52YXMsIHdpZHRoLCBoZWlnaHQsIHNsb3RXaWR0aCwgc2xvdEhlaWdodCwgaG92ZXJDb2xvcikge1xyXG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XHJcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgIHRoaXMuc2xvdFdpZHRoID0gc2xvdFdpZHRoO1xyXG4gICAgdGhpcy5zbG90SGVpZ2h0ID0gc2xvdEhlaWdodDtcclxuICAgIHRoaXMuc2xvdHNJblggPSBNYXRoLmZsb29yKHRoaXMud2lkdGggLyB0aGlzLnNsb3RXaWR0aCk7XHJcbiAgICB0aGlzLnNsb3RzSW5ZID0gTWF0aC5mbG9vcih0aGlzLmhlaWdodCAvIHRoaXMuc2xvdEhlaWdodCk7XHJcbiAgICB0aGlzLmhvdmVyQ29sb3IgPSBob3ZlckNvbG9yO1xyXG4gICAgdGhpcy5zY2FsZVggPSBjYW52YXMuY2xpZW50V2lkdGggLyB0aGlzLndpZHRoO1xyXG4gICAgdGhpcy5zY2FsZVkgPSBjYW52YXMuY2xpZW50SGVpZ2h0IC8gdGhpcy5oZWlnaHQ7XHJcbiAgfVxyXG5cclxuICBnZXRDb250ZXh0MkQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICB9XHJcblxyXG4gIG1vdXNlT3Zlcih4LCB5KSB7XHJcbiAgICB0aGlzLmhvdmVyID0gdGhpcy5nZXRTbG90SW5kZXhGb3JEaXNjcmV0ZShcclxuICAgICAgTWF0aC5mbG9vcih4IC8gdGhpcy5zY2FsZVggLyB0aGlzLnNsb3RXaWR0aCksXHJcbiAgICAgIE1hdGguZmxvb3IoeSAvIHRoaXMuc2NhbGVZIC8gdGhpcy5zbG90SGVpZ2h0KVxyXG4gICAgKTtcclxuICAgIHJldHVybiB0aGlzLmhvdmVyO1xyXG4gIH1cclxuICBnZXRTbG90SW5kZXhGb3JEaXNjcmV0ZSh4LCB5KSB7XHJcbiAgICByZXR1cm4geCArIHkgKiB0aGlzLnNsb3RzSW5YO1xyXG4gIH1cclxuXHJcbiAgZ2V0Q2FudmFzQ29vcmRpbmF0ZXNGb3JTbG90KGluZGV4KSB7XHJcbiAgICBjb25zdCBjb29yZGluYXRlcyA9IHRoaXMuZ2V0Q29vcmRpbmF0ZXNGb3JTbG90KGluZGV4KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHg6IGNvb3JkaW5hdGVzLnggKiB0aGlzLnNsb3RXaWR0aCxcclxuICAgICAgeTogY29vcmRpbmF0ZXMueSAqIHRoaXMuc2xvdEhlaWdodFxyXG4gICAgfTtcclxuICB9XHJcbiAgZ2V0Q29vcmRpbmF0ZXNGb3JTbG90KGluZGV4KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB4OiAoaW5kZXggJSB0aGlzLnNsb3RzSW5YKSxcclxuICAgICAgeTogTWF0aC5mbG9vcihpbmRleCAvIHRoaXMuc2xvdHNJblgpXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZHJhd0dyaWRTbG90KGNvbnRleHQsIG9yaWdpbiwgY29sb3IpIHtcclxuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvcjtcclxuICAgIGNvbnRleHQuc3Ryb2tlUmVjdChvcmlnaW4ueCArIC41LCBvcmlnaW4ueSArIC41LCB0aGlzLnNsb3RXaWR0aCAtIDEsIHRoaXMuc2xvdEhlaWdodCAtIDEpO1xyXG4gIH1cclxuXHJcbiAgcGFpbnRIb3Zlcihjb250ZXh0KSB7XHJcbiAgICBpZiAodGhpcy5ob3ZlciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGNvbnN0IG9yaWdpbiA9IHRoaXMuZ2V0Q2FudmFzQ29vcmRpbmF0ZXNGb3JTbG90KHRoaXMuaG92ZXIpO1xyXG4gICAgICB0aGlzLmRyYXdHcmlkU2xvdChjb250ZXh0LCBvcmlnaW4sIHRoaXMuaG92ZXJDb2xvcik7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgQ2FudmFzUGFpbnRlciBleHRlbmRzIEdyaWRQYWludGVyIHtcclxuICBjb25zdHJ1Y3RvcihjYW52YXMsIGJvYXJkLCBldmVudEJ1cykge1xyXG4gICAgc3VwZXIoXHJcbiAgICAgIGNhbnZhcywgXHJcbiAgICAgIGJvYXJkLnNjZW5lLndpZHRoICogYm9hcmQuc2NlbmUudGhlbWUuc3ByaXRlV2lkdGgsXHJcbiAgICAgIGJvYXJkLnNjZW5lLmhlaWdodCAqIGJvYXJkLnNjZW5lLnRoZW1lLnNwcml0ZUhlaWdodCxcclxuICAgICAgYm9hcmQuc2NlbmUudGhlbWUuc3ByaXRlV2lkdGgsIFxyXG4gICAgICBib2FyZC5zY2VuZS50aGVtZS5zcHJpdGVIZWlnaHQsXHJcbiAgICAgICdyZWQnXHJcbiAgICApO1xyXG4gICAgdGhpcy5ib2FyZCA9IGJvYXJkO1xyXG4gICAgdGhpcy5ldmVudEJ1cyA9IGV2ZW50QnVzO1xyXG4gICAgdGhpcy5zY2VuZVVwZGF0ZWQoKTtcclxuICAgIGlmICh0aGlzLmV2ZW50QnVzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhpcy5zdWJzY3JpYmVUb0V2ZW50cygpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc3Vic2NyaWJlVG9FdmVudHMoKSB7XHJcbiAgICB0aGlzLmV2ZW50QnVzLnN1YnNjcmliZShFdmVudC5HYW1lUmVzZXQuY2hhbm5lbE5hbWUsICgpID0+IHRoaXMuc2NlbmVVcGRhdGVkKCkpO1xyXG4gIH1cclxuXHJcbiAgc2NlbmVVcGRhdGVkKCkge1xyXG4gICAgdGhpcy5zcHJpdGVzID0gbmV3IEltYWdlKCk7XHJcbiAgICB0aGlzLnNwcml0ZXMuc3JjID0gYCR7aW1hZ2VCYXNlVXJsfSR7dGhpcy5ib2FyZC5zY2VuZS50aGVtZS5pbWFnZX1gO1xyXG4gIH1cclxuXHJcbiAgcGFpbnQodGltZXN0YW1wKSB7XHJcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0MkQoKTtcclxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5ib2FyZC5zY2VuZS50aGVtZS5iYWNrZ3JvdW5kO1xyXG4gICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcclxuICAgIGZvcihsZXQgeT0wOyB5IDwgdGhpcy5zbG90c0luWTsgeSsrKSB7XHJcbiAgICAgIGZvcihsZXQgeD0wOyB4IDwgdGhpcy5zbG90c0luWDsgeCsrKSB7XHJcbiAgICAgICAgY29uc3Qgc3ByaXRlTnVtYmVyID0gdGhpcy5ib2FyZC5nZXRTcHJpdGUoeCwgeSwgdGltZXN0YW1wKTtcclxuICAgICAgICB0aGlzLmRyYXdTcHJpdGUoY29udGV4dCwgc3ByaXRlTnVtYmVyLCB4LCB5KTtcclxuICAgICAgICBjb25zdCBvdmVybGF5U3ByaXRlTnVtYmVyID0gdGhpcy5ib2FyZC5nZXRPdmVybGF5U3ByaXRlKHgsIHksIHRpbWVzdGFtcCk7XHJcbiAgICAgICAgaWYgKG92ZXJsYXlTcHJpdGVOdW1iZXIgIT0gbnVsbCkge1xyXG4gICAgICAgICAgdGhpcy5kcmF3U3ByaXRlKGNvbnRleHQsIG92ZXJsYXlTcHJpdGVOdW1iZXIsIHgsIHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5wYWludEhvdmVyKGNvbnRleHQpO1xyXG4gIH1cclxuXHJcbiAgZHJhd1Nwcml0ZShjb250ZXh0LCBzcHJpdGVOdW1iZXIsIHgsIHkpIHtcclxuICAgIGNvbnN0IHNvdXJjZVggPSB0aGlzLmdldFNvdXJjZVgoc3ByaXRlTnVtYmVyKTtcclxuICAgIGNvbnN0IHNvdXJjZVkgPSB0aGlzLmdldFNvdXJjZVkoc3ByaXRlTnVtYmVyKTtcclxuICAgIGNvbnRleHQuZHJhd0ltYWdlKFxyXG4gICAgICB0aGlzLnNwcml0ZXMsIFxyXG4gICAgICBzb3VyY2VYLCBcclxuICAgICAgc291cmNlWSxcclxuICAgICAgdGhpcy5zbG90V2lkdGgsXHJcbiAgICAgIHRoaXMuc2xvdEhlaWdodCxcclxuICAgICAgeCAqIHRoaXMuc2xvdFdpZHRoLFxyXG4gICAgICB5ICogdGhpcy5zbG90SGVpZ2h0LFxyXG4gICAgICB0aGlzLnNsb3RXaWR0aCxcclxuICAgICAgdGhpcy5zbG90SGVpZ2h0XHJcbiAgICApOyAgICBcclxuICB9XHJcblxyXG4gIGdldFNvdXJjZVgoc3ByaXRlTnVtYmVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zbG90V2lkdGggKiAoc3ByaXRlTnVtYmVyICUgKHRoaXMuc3ByaXRlcy53aWR0aC90aGlzLnNsb3RXaWR0aCkpO1xyXG4gIH1cclxuXHJcbiAgZ2V0U291cmNlWShzcHJpdGVOdW1iZXIpIHtcclxuICAgIHJldHVybiB0aGlzLnNsb3RIZWlnaHQgKiBNYXRoLmZsb29yKHNwcml0ZU51bWJlciAvICh0aGlzLnNwcml0ZXMud2lkdGgvdGhpcy5zbG90V2lkdGgpKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBQYWxldHRlUGFpbnRlciBleHRlbmRzIEdyaWRQYWludGVyIHtcclxuICBjb25zdHJ1Y3RvcihjYW52YXMsIHNjZW5lKSB7XHJcbiAgICBzdXBlcihcclxuICAgICAgY2FudmFzLCBcclxuICAgICAgc2NlbmUudGhlbWUuaW1hZ2VXaWR0aCxcclxuICAgICAgc2NlbmUudGhlbWUuaW1hZ2VIZWlnaHQsXHJcbiAgICAgIHNjZW5lLnRoZW1lLnNwcml0ZVdpZHRoLCBcclxuICAgICAgc2NlbmUudGhlbWUuc3ByaXRlSGVpZ2h0LFxyXG4gICAgICAncmVkJ1xyXG4gICAgKTtcclxuICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcclxuICAgIHRoaXMuc3ByaXRlcyA9IG5ldyBJbWFnZSgpO1xyXG4gICAgdGhpcy5zcHJpdGVzLnNyYyA9IGAke2ltYWdlQmFzZVVybH0ke3NjZW5lLnRoZW1lLmltYWdlfWA7XHJcbiAgICB0aGlzLnNlbGVjdGVkID0gMDtcclxuICB9XHJcblxyXG4gIHBhaW50KCkge1xyXG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dDJEKCk7XHJcbiAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcclxuICAgIGNvbnRleHQuZHJhd0ltYWdlKHRoaXMuc3ByaXRlcywgMCwgMCk7XHJcbiAgICBpZiAodGhpcy5zZWxlY3RlZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGNvbnN0IG9yaWdpbiA9IHRoaXMuZ2V0Q2FudmFzQ29vcmRpbmF0ZXNGb3JTbG90KHRoaXMuc2VsZWN0ZWQpO1xyXG4gICAgICB0aGlzLmRyYXdHcmlkU2xvdChjb250ZXh0LCBvcmlnaW4sICd3aGl0ZScpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5wYWludEhvdmVyKGNvbnRleHQpO1xyXG4gIH1cclxuXHJcbiAgc2VsZWN0U2xvdChpbmRleCkge1xyXG4gICAgdGhpcy5zZWxlY3RlZCA9IGluZGV4O1xyXG4gIH1cclxufSIsImNvbnN0IFNUT1JBR0VfUFJPR1JBTV9QUkVGSVggPSAnc2lkaWxhLXByb2dyYW0tJztcclxuY29uc3QgUFJPR1JBTV9OQU1FX1JFR0VYID0gL1xcd3syLDIwfS9nO1xyXG5cclxuZXhwb3J0IGNsYXNzIFN0b3JhZ2Uge1xyXG5cclxuICBzdGF0aWMgcmVxdWlyZVZhbGlkUHJvZ3JhbU5hbWUobmFtZSkge1xyXG4gICAgaWYgKCFuYW1lLm1hdGNoKFBST0dSQU1fTkFNRV9SRUdFWCkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb21icmUgZGUgcHJvZ3JhbWEgaW52w6FsaWRvJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBsaXN0U2F2ZWRQcm9ncmFtcygpIHtcclxuICAgIGNvbnN0IGxpc3QgPSBbXTtcclxuICAgIGZvciAobGV0IGk9MCwgbGVuPWxvY2FsU3RvcmFnZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICBpZiAobG9jYWxTdG9yYWdlLmtleShpKS5zdGFydHNXaXRoKFNUT1JBR0VfUFJPR1JBTV9QUkVGSVgpKSB7XHJcbiAgICAgICAgbGlzdC5wdXNoKFN0b3JhZ2UuZ2V0RmlsZW5hbWVGcm9tS2V5KGxvY2FsU3RvcmFnZS5rZXkoaSkpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxpc3Q7XHJcbiAgfVxyXG4gIGxvYWRQcm9ncmFtKG5hbWUpIHtcclxuICAgIFN0b3JhZ2UucmVxdWlyZVZhbGlkUHJvZ3JhbU5hbWUobmFtZSk7XHJcbiAgICBjb25zdCBrZXkgPSBTdG9yYWdlLmdldEtleUZyb21GaWxlbmFtZShuYW1lKTtcclxuICAgIGlmIChrZXkgIT0gdW5kZWZpbmVkICYmIGtleSAhPSAnJykge1xyXG4gICAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcclxuICAgIH1cclxuICB9XHJcbiAgc2F2ZVByb2dyYW0obmFtZSwgcHJvZ3JhbSwgb3ZlcndyaXRlKSB7XHJcbiAgICBTdG9yYWdlLnJlcXVpcmVWYWxpZFByb2dyYW1OYW1lKG5hbWUpO1xyXG4gICAgY29uc3Qga2V5ID0gU3RvcmFnZS5nZXRLZXlGcm9tRmlsZW5hbWUobmFtZSk7XHJcbiAgICBpZiAobG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KSAhPT0gbnVsbCAmJiAhb3ZlcndyaXRlLmNoZWNrZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZYSBleGlzdGUgdW4gcHJvZ3JhbWEgY29uIGVzZSBub21icmUnKTtcclxuICAgIH1cclxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgcHJvZ3JhbSk7XHJcbiAgfVxyXG4gIGRlbGV0ZVByb2dyYW0obmFtZSkge1xyXG4gICAgU3RvcmFnZS5yZXF1aXJlVmFsaWRQcm9ncmFtTmFtZShuYW1lKTtcclxuICAgIGNvbnN0IGtleSA9IFN0b3JhZ2UuZ2V0S2V5RnJvbUZpbGVuYW1lKG5hbWUpO1xyXG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBnZXRLZXlGcm9tRmlsZW5hbWUoZmlsZW5hbWUpIHtcclxuICAgIHJldHVybiBTVE9SQUdFX1BST0dSQU1fUFJFRklYICsgZmlsZW5hbWU7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZ2V0RmlsZW5hbWVGcm9tS2V5KGtleSkge1xyXG4gICAgcmV0dXJuIGtleS5zdWJzdHJpbmcoU1RPUkFHRV9QUk9HUkFNX1BSRUZJWC5sZW5ndGgsIGtleS5sZW5ndGgpO1xyXG4gIH1cclxufSIsImV4cG9ydCBjbGFzcyBTY29yZSB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLmJhc2UgPSAyMDAwMDA7IC8vIDIwMGtcclxuICB9XHJcblxyXG4gIGdldFNjb3JlKGxpbmVzLCBib2FyZCkge1xyXG4gICAgaWYgKGJvYXJkLmlzQ3Jhc2hlZCgpKSB7XHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgem9tYmllS2lsbGVkID0gYm9hcmQuem9tYmllLmNyYXNoZWQ7XHJcbiAgICBjb25zdCBsaW5lc0ZhY3RvciA9ICh6b21iaWVLaWxsZWQpID8gMC45NiA6IDE7XHJcbiAgICBjb25zdCBtb3ZlcyA9IGJvYXJkLm1vdmVzO1xyXG4gICAgY29uc3QgbW92ZXNGYWN0b3IgPSAoem9tYmllS2lsbGVkKSA/IDAuOTEgOiAxO1xyXG4gICAgY29uc3Qgc2hvdHMgPSBib2FyZC5zaG90cztcclxuICAgIGNvbnN0IHNob3RzRmFjdG9yID0gKHpvbWJpZUtpbGxlZCkgPyAwLjczIDogMTtcclxuICAgIHJldHVybiBNYXRoLmNlaWwoXHJcbiAgICAgIHRoaXMuYmFzZSBcclxuICAgICAgLSAobGluZXMgKiAzMDAyICogbGluZXNGYWN0b3IpIFxyXG4gICAgICAtIChtb3ZlcyAqIDk5NiAqIG1vdmVzRmFjdG9yKVxyXG4gICAgICAtIChzaG90cyAqIDYwMyAqIHNob3RzRmFjdG9yKVxyXG4gICAgKTtcclxuICB9XHJcbn0iLCJpbXBvcnQgeyBMb2dpY0Jsb2NrLCBNb3ZlRGlyZWN0aW9uIH0gZnJvbSBcIi4uL2dhbWUvYm9hcmRcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBJbnN0cnVjdGlvbiB7XHJcbiAgY29uc3RydWN0b3Ioc3RhcnQsIGVuZCkge1xyXG4gICAgdGhpcy5sb2NhdGlvbiA9IHsgc3RhcnQsIGVuZCB9O1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEFjdGlvbiBleHRlbmRzIEluc3RydWN0aW9uIHtcclxuICBjb25zdHJ1Y3RvcihzdGFydCwgZW5kKSB7XHJcbiAgICBzdXBlcihzdGFydCwgZW5kKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBNb3ZlIGV4dGVuZHMgQWN0aW9uIHtcclxuICBjb25zdHJ1Y3RvcihzdGFydCwgZW5kKSB7XHJcbiAgICBzdXBlcihzdGFydCwgZW5kKTtcclxuICB9XHJcblxyXG4gIGV4ZWN1dGUoYm9hcmQpIHtcclxuICAgIGJvYXJkLm1vdmVQbGF5ZXIoTW92ZURpcmVjdGlvbi5Gb3J0aCk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgQmFjayBleHRlbmRzIEFjdGlvbiB7XHJcbiAgY29uc3RydWN0b3Ioc3RhcnQsIGVuZCkge1xyXG4gICAgc3VwZXIoc3RhcnQsIGVuZCk7XHJcbiAgfVxyXG5cclxuICBleGVjdXRlKGJvYXJkKSB7XHJcbiAgICBib2FyZC5tb3ZlUGxheWVyKE1vdmVEaXJlY3Rpb24uQmFjayk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgU2hvb3QgZXh0ZW5kcyBBY3Rpb24ge1xyXG4gIGNvbnN0cnVjdG9yKHN0YXJ0LCBlbmQpIHtcclxuICAgIHN1cGVyKHN0YXJ0LCBlbmQpO1xyXG4gIH1cclxuXHJcbiAgZXhlY3V0ZShib2FyZCkge1xyXG4gICAgYm9hcmQucGxheWVyU2hvb3QoKTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIFR1cm5EaXJlY3Rpb24ge1xyXG4gIHN0YXRpYyBMZWZ0ID0gbmV3IFR1cm5EaXJlY3Rpb24oKGJvYXJkKSA9PiBib2FyZC5yb3RhdGVQbGF5ZXJMZWZ0KCkpO1xyXG4gIHN0YXRpYyBSaWdodCA9IG5ldyBUdXJuRGlyZWN0aW9uKChib2FyZCkgPT4gYm9hcmQucm90YXRlUGxheWVyUmlnaHQoKSk7XHJcbiAgc3RhdGljIEJhY2sgPSBuZXcgVHVybkRpcmVjdGlvbigoYm9hcmQpID0+IGJvYXJkLnJvdGF0ZVBsYXllckJhY2soKSk7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGFjdGlvbikge1xyXG4gICAgdGhpcy5hY3Rpb24gPSBhY3Rpb247XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgVHVybiBleHRlbmRzIEFjdGlvbiB7XHJcbiAgY29uc3RydWN0b3Ioc3RhcnQsIGVuZCwgZGlyZWN0aW9uKSB7XHJcbiAgICBzdXBlcihzdGFydCwgZW5kKTtcclxuICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XHJcbiAgICAgIGNhc2UgJ2xhIGRlcmVjaGEnOiBcclxuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IFR1cm5EaXJlY3Rpb24uUmlnaHQ7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2xhIGl6cXVpZXJkYSc6XHJcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBUdXJuRGlyZWN0aW9uLkxlZnQ7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2F0cmFzJzpcclxuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IFR1cm5EaXJlY3Rpb24uQmFjaztcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZGlyZWN0aW9uOiAnJHtkaXJlY3Rpb259J2ApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZXhlY3V0ZShib2FyZCkge1xyXG4gICAgdGhpcy5kaXJlY3Rpb24uYWN0aW9uKGJvYXJkKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBCcmFuY2ggZXh0ZW5kcyBJbnN0cnVjdGlvbiB7XHJcbiAgY29uc3RydWN0b3Ioc3RhcnQsIGVuZCwgY29uZGl0aW9uLCBib2R5LCBlbHNlQm9keSkge1xyXG4gICAgc3VwZXIoc3RhcnQsIGVuZCk7XHJcbiAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcclxuICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcbiAgICB0aGlzLmVsc2VCb2R5ID0gZWxzZUJvZHk7XHJcbiAgfVxyXG5cclxuICBldmFsdWF0ZShib2FyZCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uLmV2YWx1YXRlKGJvYXJkKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBMb29wIGV4dGVuZHMgSW5zdHJ1Y3Rpb24ge1xyXG4gIGNvbnN0cnVjdG9yKHN0YXJ0LCBlbmQsIGNvbmRpdGlvbiwgYm9keSkge1xyXG4gICAgc3VwZXIoc3RhcnQsIGVuZCk7XHJcbiAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcclxuICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcbiAgfVxyXG5cclxuICBldmFsdWF0ZShib2FyZCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uLmV2YWx1YXRlKGJvYXJkKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBMb29rQWhlYWRDb25kaXRpb24gZXh0ZW5kcyBJbnN0cnVjdGlvbiB7XHJcbiAgY29uc3RydWN0b3Ioc3RhcnQsIGVuZCwgbm90LCBzcHJpdGVMYWJlbCwgbG9va1VwRGlyZWN0aW9uKSB7XHJcbiAgICBzdXBlcihzdGFydCwgZW5kKTtcclxuICAgIHRoaXMubm90ID0gbm90ID09PSAnbm8nO1xyXG4gICAgaWYgKHNwcml0ZUxhYmVsID09PSAncGFyZWQnKSB7XHJcbiAgICAgIHRoaXMuY29uZGl0aW9uID0gKHNwcml0ZSkgPT4gc3ByaXRlID09PSBMb2dpY0Jsb2NrLldhbGw7XHJcbiAgICB9IGVsc2UgaWYgKHNwcml0ZUxhYmVsID09PSAnem9tYmllJykge1xyXG4gICAgICB0aGlzLmNvbmRpdGlvbiA9IChzcHJpdGUpID0+IHNwcml0ZSA9PT0gTG9naWNCbG9jay5ab21iaWU7XHJcbiAgICB9IGVsc2UgaWYgKHNwcml0ZUxhYmVsID09PSAnZXNwYWNpbycpIHtcclxuICAgICAgdGhpcy5jb25kaXRpb24gPSAoc3ByaXRlKSA9PiBzcHJpdGUgPT09IExvZ2ljQmxvY2suU3BhY2U7XHJcbiAgICB9IGVsc2UgaWYgKHNwcml0ZUxhYmVsID09PSAnc2FsaWRhJykge1xyXG4gICAgICB0aGlzLmNvbmRpdGlvbiA9IChzcHJpdGUpID0+IHNwcml0ZSA9PT0gTG9naWNCbG9jay5FeGl0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5jb25kaXRpb24gPSAoc3ByaXRlKSA9PiBzcHJpdGUgIT09IExvZ2ljQmxvY2suU3BhY2U7XHJcbiAgICB9XHJcbiAgICBpZiAobG9va1VwRGlyZWN0aW9uID09ICdhZGVsYW50ZScpIHtcclxuICAgICAgdGhpcy5sb29rVXBEaXJlY3Rpb24gPSAoYm9hcmQpID0+IGJvYXJkLmdldExvZ2ljSW5Gcm9udE9mUGxheWVyKCk7XHJcbiAgICB9IGVsc2UgaWYgKGxvb2tVcERpcmVjdGlvbiA9PSAnYSBsYSBpenF1aWVyZGEnKSB7XHJcbiAgICAgIHRoaXMubG9va1VwRGlyZWN0aW9uID0gKGJvYXJkKSA9PiBib2FyZC5nZXRMb2dpY1RvVGhlTGVmdE9mUGxheWVyKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmxvb2tVcERpcmVjdGlvbiA9IChib2FyZCkgPT4gYm9hcmQuZ2V0TG9naWNUb1RoZVJpZ2h0T2ZQbGF5ZXIoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGV2YWx1YXRlKGJvYXJkKSB7XHJcbiAgICBjb25zdCBldmFsdWF0aW9uID0gdGhpcy5jb25kaXRpb24odGhpcy5sb29rVXBEaXJlY3Rpb24oYm9hcmQpKTtcclxuICAgIHJldHVybiAodGhpcy5ub3QpID8gIWV2YWx1YXRpb24gOiBldmFsdWF0aW9uO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEluR2FtZUNvbmRpdGlvbiBleHRlbmRzIEluc3RydWN0aW9uIHtcclxuICBjb25zdHJ1Y3RvcihzdGFydCwgZW5kLCBub3QpIHtcclxuICAgIHN1cGVyKHN0YXJ0LCBlbmQpO1xyXG4gICAgdGhpcy5ub3QgPSBub3QgPT09ICdubyc7XHJcbiAgfVxyXG5cclxuICBldmFsdWF0ZShib2FyZCkge1xyXG4gICAgY29uc3QgZXZhbHVhdGlvbiA9IGJvYXJkLmlzRG9uZSgpO1xyXG4gICAgcmV0dXJuICh0aGlzLm5vdCkgPyAhZXZhbHVhdGlvbiA6IGV2YWx1YXRpb247XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IEV2ZW50IH0gZnJvbSAnLi4vZ2FtZS9ldmVudCc7XHJcbmltcG9ydCB7IEFjdGlvbiwgQnJhbmNoLCBMb29wIH0gZnJvbSAnLi9pbnN0cnVjdGlvbic7XHJcblxyXG5leHBvcnQgY2xhc3MgU3RlcEludGVycHJldGVyIHtcclxuICBjb25zdHJ1Y3Rvcihib2FyZCwgdHJlZSwgZXZlbnRCdXMpIHtcclxuICAgIHRoaXMuZXZlbnRCdXMgPSBldmVudEJ1cztcclxuICAgIHRoaXMuYm9hcmQgPSBib2FyZDtcclxuICAgIHRoaXMudHJlZSA9IHRyZWU7XHJcbiAgICB0aGlzLnN0YWNrID0gW107XHJcbiAgICB0aGlzLnN0YWNrQm9keSh0aGlzLnRyZWUuZWxlbWVudHMpO1xyXG4gICAgdGhpcy5nYW1lVGlja3MgPSAwO1xyXG4gICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgc3RhY2tCb2R5KG5vZGVzKSB7XHJcbiAgICBmb3IobGV0IGk9bm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgdGhpcy5zdGFja05vZGUobm9kZXNbaV0pO1xyXG4gICAgfVxyXG4gIH1cclxuICBzdGFja05vZGUobm9kZSkge1xyXG4gICAgdGhpcy5zdGFjay5wdXNoKG5vZGUpO1xyXG4gIH1cclxuXHJcbiAgdGljaygpIHtcclxuICAgIHRoaXMuZ2FtZVRpY2tzKys7XHJcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFjay5wb3AoKTtcclxuICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhpcy52aXNpdE5vZGUobm9kZSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmZpbmlzaGVkID0gdGhpcy5zdGFjay5sZW5ndGggPT09IDA7XHJcbiAgfVxyXG5cclxuICBpc0ZpbmlzaGVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoZWQ7XHJcbiAgfVxyXG5cclxuICB2aXNpdE5vZGUobm9kZSkge1xyXG4gICAgY29uc3QgaW5zdHJ1Y3Rpb24gPSBub2RlLmVsZW1lbnRzWzBdO1xyXG4gICAgdGhpcy5wdWJsaXNoU3RlcChpbnN0cnVjdGlvbik7XHJcbiAgICBpZiAoaW5zdHJ1Y3Rpb24gaW5zdGFuY2VvZiBBY3Rpb24pIHtcclxuICAgICAgaW5zdHJ1Y3Rpb24uZXhlY3V0ZSh0aGlzLmJvYXJkKTtcclxuICAgIH0gZWxzZSBpZiAoaW5zdHJ1Y3Rpb24gaW5zdGFuY2VvZiBCcmFuY2gpIHtcclxuICAgICAgaWYgKGluc3RydWN0aW9uLmV2YWx1YXRlKHRoaXMuYm9hcmQpKSB7XHJcbiAgICAgICAgdGhpcy5zdGFja0JvZHkoaW5zdHJ1Y3Rpb24uYm9keSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoaW5zdHJ1Y3Rpb24uZWxzZUJvZHkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRoaXMuc3RhY2tCb2R5KGluc3RydWN0aW9uLmVsc2VCb2R5KTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChpbnN0cnVjdGlvbiBpbnN0YW5jZW9mIExvb3ApIHtcclxuICAgICAgaWYgKGluc3RydWN0aW9uLmV2YWx1YXRlKHRoaXMuYm9hcmQpKSB7XHJcbiAgICAgICAgdGhpcy5zdGFja05vZGUobm9kZSk7XHJcbiAgICAgICAgdGhpcy5zdGFja0JvZHkoaW5zdHJ1Y3Rpb24uYm9keSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNyZWF0ZVN0ZXBFdmVudChub2RlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBsb2NhdGlvbjogbm9kZS5sb2NhdGlvbixcclxuICAgICAgZ2FtZVRpY2tzOiB0aGlzLmdhbWVUaWNrc1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHB1Ymxpc2hTdGVwKGluc3RydWN0aW9uKSB7XHJcbiAgICBjb25zdCBldmVudCA9IHRoaXMuY3JlYXRlU3RlcEV2ZW50KGluc3RydWN0aW9uKTtcclxuICAgIHRoaXMuZXZlbnRCdXMucHVibGlzaChFdmVudC5JbnRlcnByZXRlclN0ZXAuY2hhbm5lbE5hbWUsIGV2ZW50KTtcclxuICB9XHJcblxyXG4gIHN1YnNjcmliZVRvU3RlcChzdWJzY3JpYmVyKSB7XHJcbiAgICB0aGlzLmV2ZW50QnVzLnN1YnNjcmliZShFdmVudC5JbnRlcnByZXRlclN0ZXAuY2hhbm5lbE5hbWUsIHN1YnNjcmliZXIpO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBFdmVudCB9IGZyb20gJy4vZXZlbnQnO1xyXG5pbXBvcnQgeyBHYW1lQm9hcmQgfSBmcm9tICcuL2dhbWUtYm9hcmQnO1xyXG5pbXBvcnQgeyBTY29yZSB9IGZyb20gJy4vc2NvcmUnO1xyXG5pbXBvcnQgeyBTdGVwSW50ZXJwcmV0ZXIgfSBmcm9tICcuLi9pbnN0cnVjdGlvbnMvaW50ZXJwcmV0ZXInO1xyXG5pbXBvcnQgeyBFdmVudEJ1cyB9IGZyb20gJy4uL3V0aWwvZXZlbnQtYnVzJztcclxuaW1wb3J0IHsgQ2FudmFzUGFpbnRlciB9IGZyb20gJy4uL2RyYXdpbmcnO1xyXG5cclxuZXhwb3J0IGNsYXNzIENvbnRyb2wge1xyXG4gIGNvbnN0cnVjdG9yKGNvZGVNaXJyb3IsIGNhbnZhcykge1xyXG4gICAgdGhpcy5jb2RlTWlycm9yID0gY29kZU1pcnJvcjtcclxuICAgIHRoaXMuZXZlbnRCdXMgPSBuZXcgRXZlbnRCdXMoKTtcclxuICAgIHRoaXMuYm9hcmQgPSBuZXcgR2FtZUJvYXJkKHRoaXMuZXZlbnRCdXMpO1xyXG4gICAgdGhpcy5jYW52YXNQYWludGVyID0gbmV3IENhbnZhc1BhaW50ZXIoY2FudmFzLCB0aGlzLmJvYXJkLCB0aGlzLmV2ZW50QnVzKTtcclxuICAgIHRoaXMuc2NvcmUgPSBuZXcgU2NvcmUoKTtcclxuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xyXG4gICAgdGhpcy5zdWJzY3JpYmVUb0V2ZW50cygpO1xyXG4gIH1cclxuXHJcbiAgc3Vic2NyaWJlVG9FdmVudHMoKSB7XHJcbiAgICB0aGlzLmV2ZW50QnVzLnN1YnNjcmliZShFdmVudC5HYW1lRmluaXNoZWQuY2hhbm5lbE5hbWUsICgpID0+IHRoaXMucnVubmluZyA9IGZhbHNlKTtcclxuICAgIHRoaXMuY29kZU1pcnJvci5vbignY2hhbmdlcycsICgpID0+IHRoaXMucHVibGlzaFNjb3JlKCkpO1xyXG4gIH1cclxuXHJcbiAgcnVuKHRyZWUpIHtcclxuICAgIHRoaXMuaW50ZXJwcmV0ZXIgPSBuZXcgU3RlcEludGVycHJldGVyKHRoaXMuYm9hcmQsIHRyZWUsIHRoaXMuZXZlbnRCdXMpO1xyXG4gICAgdGhpcy5ib2FyZC5zdGFydCgpO1xyXG4gICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlzUnVubmluZygpIHtcclxuICAgIHJldHVybiB0aGlzLnJ1bm5pbmc7XHJcbiAgfVxyXG5cclxuICB0aWNrKCkge1xyXG4gICAgdGhpcy5pbnRlcnByZXRlci50aWNrKCk7XHJcbiAgICBpZiAodGhpcy5pbnRlcnByZXRlci5pc0ZpbmlzaGVkKCkpIHtcclxuICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB0aGlzLnB1Ymxpc2hTY29yZSgpO1xyXG4gIH1cclxuXHJcbiAgcGFpbnQodGltZXN0YW1wKSB7XHJcbiAgICB0aGlzLmNhbnZhc1BhaW50ZXIucGFpbnQodGltZXN0YW1wKTtcclxuICB9XHJcblxyXG4gIHB1Ymxpc2hTY29yZSgpIHtcclxuICAgIGNvbnN0IGxpbmVzID0gdGhpcy5jb2RlTWlycm9yLmxpbmVDb3VudCgpO1xyXG4gICAgY29uc3Qgc2NvcmUgPSB0aGlzLnNjb3JlLmdldFNjb3JlKGxpbmVzLCB0aGlzLmJvYXJkKTtcclxuICAgIHRoaXMuZXZlbnRCdXMucHVibGlzaChFdmVudC5TY29yZS5jaGFubmVsTmFtZSwgc2NvcmUpO1xyXG4gIH1cclxuXHJcbiAgcmVzZXQoc2NlbmVJbmRleCkge1xyXG4gICAgdGhpcy5ib2FyZC5yZXNldChzY2VuZUluZGV4KTtcclxuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgc3Vic2NyaWJlVG9TdGVwKHN1YnNjcmliZXIpIHtcclxuICAgIHRoaXMuZXZlbnRCdXMuc3Vic2NyaWJlKEV2ZW50LkludGVycHJldGVyU3RlcC5jaGFubmVsTmFtZSwgc3Vic2NyaWJlcik7XHJcbiAgfVxyXG4gIHN1YnNjcmliZVRvU2NvcmUoc3Vic2NyaWJlcikge1xyXG4gICAgdGhpcy5ldmVudEJ1cy5zdWJzY3JpYmUoRXZlbnQuU2NvcmUuY2hhbm5lbE5hbWUsIHN1YnNjcmliZXIpO1xyXG4gIH1cclxuICBzdWJzY3JpYmVUb0dhbWVGaW5pc2hlZChzdWJzY3JpYmVyKSB7XHJcbiAgICB0aGlzLmV2ZW50QnVzLnN1YnNjcmliZShFdmVudC5HYW1lRmluaXNoZWQuY2hhbm5lbE5hbWUsIHN1YnNjcmliZXIpO1xyXG4gIH1cclxuXHJcbiAgc2V0U291bmQob24pIHtcclxuICAgIHRoaXMuYm9hcmQuc2V0U291bmQob24pO1xyXG4gIH1cclxufSIsImltcG9ydCB7IE1vdmUsIEJhY2ssIFNob290LCBUdXJuLCBCcmFuY2gsIExvb3AsIExvb2tBaGVhZENvbmRpdGlvbiwgSW5HYW1lQ29uZGl0aW9uIH0gZnJvbSAnLi4vaW5zdHJ1Y3Rpb25zL2luc3RydWN0aW9uJztcclxuXHJcbmNvbnN0IG1hcHMgPSByZXF1aXJlKCcuLi8uLi9idWlsZC9wZWcnKTtcclxuXHJcbmNsYXNzIEFjdGlvbnMge1xyXG4gIG1ha2VNb3ZlKGlucHV0LCBzdGFydCwgZW5kLCBlbGVtZW50cykge1xyXG4gICAgcmV0dXJuIG5ldyBNb3ZlKHN0YXJ0LCBlbmQpO1xyXG4gIH1cclxuICBtYWtlQmFjayhpbnB1dCwgc3RhcnQsIGVuZCwgZWxlbWVudHMpIHtcclxuICAgIHJldHVybiBuZXcgQmFjayhzdGFydCwgZW5kKTtcclxuICB9XHJcbiAgbWFrZVNob290KGlucHV0LCBzdGFydCwgZW5kLCBlbGVtZW50cykge1xyXG4gICAgcmV0dXJuIG5ldyBTaG9vdChzdGFydCwgZW5kKTtcclxuICB9XHJcbiAgbWFrZVR1cm4oaW5wdXQsIHN0YXJ0LCBlbmQsIGVsZW1lbnRzKSB7XHJcbiAgICByZXR1cm4gbmV3IFR1cm4oc3RhcnQsIGVuZCwgZWxlbWVudHNbMV0udGV4dCk7XHJcbiAgfVxyXG4gIG1ha2VCcmFuY2goaW5wdXQsIHN0YXJ0LCBlbmQsIGVsZW1lbnRzKSB7XHJcbiAgICBjb25zdCBjb25kaXRpb24gPSBlbGVtZW50c1sxXTtcclxuICAgIGNvbnN0IGJvZHkgPSBlbGVtZW50c1syXS5lbGVtZW50cztcclxuICAgIGNvbnN0IGVsc2VCb2R5ID0gZWxlbWVudHNbM10uZWxlbWVudHNbMV0/LmVsZW1lbnRzO1xyXG4gICAgcmV0dXJuIG5ldyBCcmFuY2goc3RhcnQsIGVuZCwgY29uZGl0aW9uLCBib2R5LCBlbHNlQm9keSk7XHJcbiAgfVxyXG4gIG1ha2VMb29wKGlucHV0LCBzdGFydCwgZW5kLCBlbGVtZW50cykge1xyXG4gICAgY29uc3QgY29uZGl0aW9uID0gZWxlbWVudHNbMV07XHJcbiAgICBjb25zdCBib2R5ID0gZWxlbWVudHNbMl0uZWxlbWVudHM7XHJcbiAgICByZXR1cm4gbmV3IExvb3Aoc3RhcnQsIGVuZCwgY29uZGl0aW9uLCBib2R5KTtcclxuICB9XHJcbiAgbWFrZUxvb2tBaGVhZENvbmRpdGlvbihpbnB1dCwgc3RhcnQsIGVuZCwgZWxlbWVudHMpIHtcclxuICAgIGNvbnN0IG5vdCA9IGVsZW1lbnRzWzBdLnRleHQ7XHJcbiAgICBjb25zdCBzcHJpdGVMYWJlbCA9IGVsZW1lbnRzWzJdLnRleHQ7XHJcbiAgICBjb25zdCBsb29rVXBEaXJlY3Rpb24gPSBlbGVtZW50c1szXS50ZXh0XHJcbiAgICByZXR1cm4gbmV3IExvb2tBaGVhZENvbmRpdGlvbihzdGFydCwgZW5kLCBub3QsIHNwcml0ZUxhYmVsLCBsb29rVXBEaXJlY3Rpb24pO1xyXG4gIH1cclxuICBtYWtlSW5HYW1lQ29uZGl0aW9uKGlucHV0LCBzdGFydCwgZW5kLCBlbGVtZW50cykge1xyXG4gICAgcmV0dXJuIG5ldyBJbkdhbWVDb25kaXRpb24oc3RhcnQsIGVuZCwgZWxlbWVudHNbMF0udGV4dCk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcGFyc2UoY29kZSkge1xyXG4gIHJldHVybiBtYXBzLnBhcnNlKGNvZGUsIHsgYWN0aW9uczogbmV3IEFjdGlvbnMoKSB9KVxyXG59IiwiZXhwb3J0IGNsYXNzIFByb2dyYW1MaXN0RHJvcERvd25IYW5kbGVyIHtcclxuICBjb25zdHJ1Y3RvcihzdG9yYWdlLCBzZWxlY3RXaWRnZXQpIHtcclxuICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XHJcbiAgICB0aGlzLnNlbGVjdFdpZGdldCA9IHNlbGVjdFdpZGdldDtcclxuICB9XHJcblxyXG4gIGxvYWRGaWxlcygpIHtcclxuICAgIHRoaXMuZW1wdHlTZWxlY3RXaWRnZXQoKTtcclxuICAgIHRoaXMuc3RvcmFnZS5saXN0U2F2ZWRQcm9ncmFtcygpLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgIGNvbnN0IG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XHJcbiAgICAgIG9wdGlvbi50ZXh0ID0gaXRlbTtcclxuICAgICAgb3B0aW9uLnZhbHVlID0gaXRlbTtcclxuICAgICAgdGhpcy5zZWxlY3RXaWRnZXQuYWRkKG9wdGlvbik7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGVtcHR5U2VsZWN0V2lkZ2V0KCkge1xyXG4gICAgY29uc3QgcGxhY2Vob2xkZXIgPSBbXS5maWx0ZXIuY2FsbCh0aGlzLnNlbGVjdFdpZGdldC5vcHRpb25zLCBvcHRpb24gPT4gb3B0aW9uLnZhbHVlID09PSBcIlwiKVswXTtcclxuICAgIHdoaWxlKHRoaXMuc2VsZWN0V2lkZ2V0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgdGhpcy5zZWxlY3RXaWRnZXQucmVtb3ZlKHRoaXMuc2VsZWN0V2lkZ2V0Lmxlbmd0aCAtIDEpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5zZWxlY3RXaWRnZXQuYWRkKHBsYWNlaG9sZGVyKTtcclxuICB9XHJcblxyXG4gIGdldFNlbGVjdGVkUHJvZ3JhbSgpIHtcclxuICAgIGNvbnN0IG5hbWUgPSB0aGlzLnNlbGVjdFdpZGdldC5vcHRpb25zW3RoaXMuc2VsZWN0V2lkZ2V0LnNlbGVjdGVkSW5kZXhdLnZhbHVlO1xyXG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5sb2FkUHJvZ3JhbShuYW1lKTtcclxuICB9XHJcbn0iLCJleHBvcnQgY2xhc3MgQ29kZU1pcnJvckhlbHBlciB7XHJcbiAgY29uc3RydWN0b3IoY29kZU1pcnJvciwgZGVidWdDbGFzc05hbWUsIGVycm9yQ2xhc3NOYW1lKSB7XHJcbiAgICB0aGlzLmNvZGVNaXJyb3IgPSBjb2RlTWlycm9yO1xyXG4gICAgdGhpcy5kZWJ1Z0NsYXNzTmFtZSA9IGRlYnVnQ2xhc3NOYW1lO1xyXG4gICAgdGhpcy5lcnJvckNsYXNzTmFtZSA9IGVycm9yQ2xhc3NOYW1lO1xyXG4gIH1cclxuXHJcbiAgaGlnaGxpZ2h0KGxvY2F0aW9uKSB7XHJcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuY29kZU1pcnJvci5wb3NGcm9tSW5kZXgobG9jYXRpb24uc3RhcnQpO1xyXG4gICAgY29uc3QgZW5kID0gdGhpcy5jb2RlTWlycm9yLnBvc0Zyb21JbmRleChsb2NhdGlvbi5lbmQpO1xyXG4gICAgdGhpcy5jbGVhckhpZ2hsaWdodCgpO1xyXG4gICAgdGhpcy5sYXN0SGlnaGxpZ2h0TWFya2VyID0gdGhpcy5jb2RlTWlycm9yLm1hcmtUZXh0KHN0YXJ0LCBlbmQsIHsgY2xhc3NOYW1lOiB0aGlzLmRlYnVnQ2xhc3NOYW1lfSk7XHJcbiAgICB0aGlzLmNvZGVNaXJyb3Iuc2Nyb2xsSW50b1ZpZXcoc3RhcnQpO1xyXG4gIH1cclxuXHJcbiAgY2xlYXJIaWdobGlnaHQoKSB7XHJcbiAgICBpZiAodGhpcy5sYXN0SGlnaGxpZ2h0TWFya2VyICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aGlzLmxhc3RIaWdobGlnaHRNYXJrZXIuY2xlYXIoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG1hcmtFcnJvcihlcnJvcikge1xyXG4gICAgY29uc3QgbGluZVN0cmluZyA9IGVycm9yLm1hdGNoKC9eTGluZSAoWzAtOV0rKS8pWzFdO1xyXG4gICAgY29uc3Qgc2hpZnRTdHJpbmcgPSBlcnJvci5tYXRjaCgvKFsgXSspXFxeJC8pWzFdO1xyXG4gICAgY29uc3QgbGluZSA9IHBhcnNlSW50KGxpbmVTdHJpbmcpIC0gMTtcclxuICAgIGNvbnN0IHNoaWZ0ID0gc2hpZnRTdHJpbmcubGVuZ3RoIC0gOTtcclxuICAgIGNvbnN0IHN0YXJ0ID0geyBsaW5lOiBsaW5lLCBjaDogc2hpZnQgfTtcclxuICAgIGNvbnN0IGVuZCA9IHsgbGluZTogbGluZSwgY2g6IHNoaWZ0ICsgMSB9O1xyXG4gICAgdGhpcy5sYXN0RXJyb3JNYXJrZXIgPSB0aGlzLmNvZGVNaXJyb3IubWFya1RleHQoc3RhcnQsIGVuZCwgeyBjbGFzc05hbWU6IHRoaXMuZXJyb3JDbGFzc05hbWV9KTtcclxuICAgIHRoaXMuY29kZU1pcnJvci5zY3JvbGxJbnRvVmlldyhzdGFydCk7XHJcbiAgfVxyXG5cclxuICBjbGVhckVycm9yKCkge1xyXG4gICAgaWYgKHRoaXMubGFzdEVycm9yTWFya2VyICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aGlzLmxhc3RFcnJvck1hcmtlci5jbGVhcigpO1xyXG4gICAgfVxyXG4gIH1cclxufSIsImltcG9ydCB7IEdhbWVCb2FyZCwgR2FtZVJlc3VsdCB9IGZyb20gJy4vZ2FtZS9nYW1lLWJvYXJkJztcclxuaW1wb3J0IHsgRWRpdG9yQm9hcmQgfSBmcm9tICcuL2dhbWUvZWRpdG9yLWJvYXJkJztcclxuaW1wb3J0IHsgQ2FudmFzUGFpbnRlciwgUGFsZXR0ZVBhaW50ZXIgfSBmcm9tICcuL2RyYXdpbmcnO1xyXG5pbXBvcnQgeyBTdG9yYWdlIH0gZnJvbSAnLi91dGlsL3N0b3JhZ2UnO1xyXG5pbXBvcnQgeyBDb250cm9sIH0gZnJvbSAnLi9nYW1lL2NvbnRyb2wnO1xyXG5pbXBvcnQgeyBwYXJzZSB9IGZyb20gJy4vZ3JhbW1hci9zaWRpbGEnO1xyXG5pbXBvcnQgeyBQcm9ncmFtTGlzdERyb3BEb3duSGFuZGxlciB9IGZyb20gJy4vdXgvcHJvZ3JhbS1saXN0JztcclxuaW1wb3J0IHsgQ29kZU1pcnJvckhlbHBlciB9IGZyb20gJy4vdXgvY29kZS1taXJyb3ItaGVscGVyJztcclxuXHJcbmV4cG9ydCB7IFxyXG4gIEVkaXRvckJvYXJkLFxyXG4gIEdhbWVCb2FyZCxcclxuICBHYW1lUmVzdWx0LFxyXG4gIENhbnZhc1BhaW50ZXIsXHJcbiAgUGFsZXR0ZVBhaW50ZXIsXHJcbiAgU3RvcmFnZSxcclxuICBDb250cm9sLFxyXG4gIFByb2dyYW1MaXN0RHJvcERvd25IYW5kbGVyLFxyXG4gIENvZGVNaXJyb3JIZWxwZXIsXHJcbiAgcGFyc2VcclxufTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///43\n")},862:g=>{"use strict";g.exports=JSON.parse('{"width":16,"height":16,"player":{"x":1,"y":1,"direction":"South"},"zombie":{"x":8,"y":1},"theme":{"image":"nes_tileset_cemetery.png","imageWidth":384,"imageHeight":128,"spriteWidth":16,"spriteHeight":16,"background":"#077704","sprite":{"north":186,"east":185,"south":184,"west":187,"dead":100,"nextNorth":0,"nextEast":0,"nextSouth":0,"nextWest":0,"zombie":164,"deadZombie":165},"animations":{}},"logic":{"0":"Exit","1":"Space","5":"Space","13":"Space","29":"Space","32":"Space","33":"Space","34":"Space","61":"Space","63":"Space","64":"Space","96":"Sphinx","99":"Sphinx","122":"Space","123":"Space","124":"Space","125":"Space","129":"Space","151":"Space","170":"Space","176":"Space","177":"Space"},"space":1,"map":[[25,26,27,27,27,27,27,27,27,27,27,27,27,27,27,28],[52,1,1,1,1,1,1,1,1,1,1,1,1,1,151,24],[52,1,1,1,1,1,1,89,1,1,1,1,151,151,1,24],[52,1,151,151,1,124,101,113,102,103,100,124,124,1,1,24],[52,1,1,1,125,126,144,144,144,144,144,144,145,177,1,24],[36,11,11,1,125,42,43,43,43,174,174,174,45,177,1,24],[36,37,37,1,1,64,64,64,34,14,174,128,129,1,1,24],[62,63,63,1,1,1,1,151,170,14,174,128,177,151,151,24],[52,1,1,1,1,49,51,1,170,14,174,128,177,151,70,24],[52,30,31,1,1,73,75,1,86,171,174,175,177,151,71,111],[52,53,54,1,1,122,122,170,126,106,106,175,177,151,151,111],[52,122,122,1,1,51,1,170,42,106,106,175,177,1,1,24],[52,1,1,1,49,78,1,1,34,42,44,45,177,1,1,24],[52,1,96,1,73,98,102,103,101,64,64,64,1,1,151,24],[52,1,99,1,122,122,122,122,122,1,1,1,1,1,1,24],[148,149,149,149,140,140,140,149,149,149,138,150,0,168,149,141]]}')},37:g=>{"use strict";g.exports=JSON.parse('{"width":16,"height":16,"player":{"x":12,"y":2,"direction":"South"},"zombie":{"x":6,"y":7},"theme":{"image":"dungeon.png","imageWidth":384,"imageHeight":160,"spriteWidth":16,"spriteHeight":16,"background":"#91b09a","sprite":{"north":189,"east":189,"south":189,"west":189,"dead":165,"nextNorth":212,"nextEast":213,"nextSouth":237,"nextWest":236,"zombie":188,"deadZombie":164},"animations":{"11,0":{"type":"two-ways","settings":{"sprites":[204,201,198,195,192],"period":75,"subscribe":"game-started"}},"11,1":{"type":"two-ways","settings":{"sprites":[228,225,222,219,216],"period":75,"subscribe":"game-started"}},"12,0":{"type":"two-ways","settings":{"sprites":[205,202,199,196,193],"period":75,"subscribe":"game-started"}},"12,1":{"type":"two-ways","settings":{"sprites":[229,226,223,220,217],"period":75,"subscribe":"game-started"}},"13,0":{"type":"two-ways","settings":{"sprites":[206,203,200,197,194],"period":75,"subscribe":"game-started"}},"13,1":{"type":"two-ways","settings":{"sprites":[230,227,224,221,218],"period":75,"subscribe":"game-started"}},"7,13":{"type":"loop","settings":{"sprites":[157,158],"period":300}},"13,12":{"type":"two-ways","settings":{"sprites":[175,174,173,172],"period":100}}}},"logic":{"54":"Space","172":"Exit","173":"Exit","174":"Exit","175":"Exit","190":"Sphinx"},"space":54,"map":[[5,6,6,6,6,104,6,6,6,6,6,204,205,206,6,7],[29,30,30,147,30,128,30,30,168,30,30,228,229,230,30,31],[53,184,186,54,54,54,54,54,54,54,54,54,54,54,54,55],[102,54,54,54,54,54,54,54,209,210,54,54,54,54,54,75],[76,54,182,54,54,54,54,54,233,234,54,54,54,54,54,99],[100,54,54,54,54,54,54,54,54,54,54,54,54,54,54,55],[53,54,54,54,54,54,54,54,54,54,54,54,54,54,54,55],[53,54,54,54,54,54,54,54,54,54,54,54,54,54,54,55],[102,54,54,54,54,54,54,54,54,54,8,78,78,127,78,4],[53,54,54,54,54,54,54,54,54,182,99,25,25,25,25,25],[76,54,54,54,54,54,54,54,182,182,55,25,25,25,25,25],[100,54,54,54,54,190,54,54,54,54,56,6,6,6,6,7],[53,54,54,54,54,54,54,54,54,54,80,171,30,175,30,31],[53,54,54,54,54,54,54,158,54,54,54,54,54,54,54,55],[53,54,54,54,54,54,54,54,54,54,54,54,54,54,54,55],[77,78,78,78,127,78,78,78,78,78,127,78,78,78,78,79]]}')},679:g=>{"use strict";g.exports=JSON.parse('{"width":16,"height":16,"player":{"x":7,"y":2,"direction":"South"},"zombie":{"x":9,"y":9},"theme":{"image":"dungeon.png","imageWidth":384,"imageHeight":160,"spriteWidth":16,"spriteHeight":16,"background":"#91b09a","sprite":{"north":189,"east":189,"south":189,"west":189,"dead":165,"nextNorth":212,"nextEast":213,"nextSouth":237,"nextWest":236,"zombie":188,"deadZombie":164},"animations":{"3,5":{"type":"loop","settings":{"sprites":[34,36,38,40,42],"period":120}},"4,5":{"type":"loop","settings":{"sprites":[35,37,39,41,43],"period":120}},"7,12":{"type":"two-ways","settings":{"sprites":[175,174,173,172],"period":100}}}},"logic":{"54":"Space","172":"Exit","173":"Exit","174":"Exit","175":"Exit","190":"Sphinx"},"space":54,"map":[[5,6,6,6,6,104,6,6,6,6,104,105,6,6,6,7],[29,30,30,30,30,128,30,148,30,30,128,129,30,30,30,31],[53,54,54,54,54,54,54,54,182,182,54,54,54,185,183,55],[102,54,54,54,54,54,54,54,182,54,54,54,54,54,186,75],[76,54,54,18,19,54,54,54,182,182,54,54,54,54,54,99],[100,54,54,34,35,54,54,54,182,54,54,54,54,54,54,55],[53,54,54,66,67,54,54,182,54,54,54,54,54,54,54,55],[53,54,54,54,54,54,54,54,54,54,207,208,54,54,54,55],[102,54,54,54,54,54,54,54,54,54,231,232,54,8,78,4],[53,54,54,54,8,78,78,127,9,54,54,54,54,32,25,25],[76,54,54,54,32,25,25,25,33,54,54,54,54,55,25,25],[100,54,54,54,56,6,6,6,57,54,54,54,54,56,6,7],[53,54,54,54,80,30,30,175,81,54,54,54,54,80,30,31],[53,54,54,54,190,54,54,54,54,54,54,54,54,54,186,55],[53,186,54,54,54,54,54,54,54,54,54,54,54,54,54,55],[77,78,78,78,127,78,78,78,78,78,127,78,78,78,78,79]]}')},715:g=>{"use strict";g.exports=JSON.parse('{"width":16,"height":16,"player":{"x":13,"y":13,"direction":"West"},"zombie":{"x":3,"y":9},"theme":{"image":"dungeon.png","imageWidth":384,"imageHeight":160,"spriteWidth":16,"spriteHeight":16,"background":"#91b09a","sprite":{"north":189,"east":189,"south":189,"west":189,"dead":165,"nextNorth":212,"nextEast":213,"nextSouth":237,"nextWest":236,"zombie":188,"deadZombie":164},"animations":{"12,11":{"type":"two-ways","settings":{"sprites":[204,201,198,195,192],"period":75,"subscribe":"game-started"}},"12,12":{"type":"two-ways","settings":{"sprites":[228,225,222,219,216],"period":75,"subscribe":"game-started"}},"13,11":{"type":"two-ways","settings":{"sprites":[205,202,199,196,193],"period":75,"subscribe":"game-started"}},"13,12":{"type":"two-ways","settings":{"sprites":[229,226,223,220,217],"period":75,"subscribe":"game-started"}},"14,11":{"type":"two-ways","settings":{"sprites":[206,203,200,197,194],"period":75,"subscribe":"game-started"}},"14,12":{"type":"two-ways","settings":{"sprites":[230,227,224,221,218],"period":75,"subscribe":"game-started"}},"7,1":{"type":"two-ways","settings":{"sprites":[175,174,173,172],"period":100}}}},"logic":{"54":"Space","172":"Exit","173":"Exit","174":"Exit","175":"Exit","190":"Sphinx"},"space":54,"map":[[5,6,6,6,6,104,6,6,6,6,104,105,6,6,6,7],[29,30,30,30,30,128,30,175,30,30,128,129,30,30,30,31],[53,182,182,54,54,54,54,54,182,182,54,54,54,185,183,55],[102,54,54,54,54,54,54,54,54,54,54,54,54,54,186,75],[76,54,54,8,78,78,78,9,54,54,190,54,54,54,54,99],[100,54,54,32,25,25,25,33,54,54,54,54,54,54,54,55],[53,54,54,56,6,6,105,57,54,54,54,54,54,54,54,55],[53,54,54,80,30,30,129,81,54,54,54,54,54,54,54,55],[102,54,54,54,209,210,54,54,54,54,54,8,78,78,78,4],[53,54,54,54,233,234,54,54,54,54,54,32,25,25,25,25],[76,54,54,54,54,54,54,54,54,54,54,55,25,25,25,25],[100,54,54,54,54,54,54,54,54,54,54,56,192,193,194,7],[53,54,54,54,54,54,54,54,54,54,54,80,216,217,218,31],[53,54,54,54,54,54,54,54,54,54,54,54,54,54,54,55],[53,54,54,54,54,54,54,54,54,54,54,54,54,54,54,55],[77,78,78,78,127,78,78,78,78,78,127,78,78,78,78,79]]}')},387:g=>{"use strict";g.exports=JSON.parse('{"width":16,"height":16,"player":{"x":14,"y":14,"direction":"West"},"zombie":{"x":1,"y":13},"theme":{"image":"dungeon.png","imageWidth":384,"imageHeight":160,"spriteWidth":16,"spriteHeight":16,"background":"#91b09a","sprite":{"north":189,"east":189,"south":189,"west":189,"dead":165,"nextNorth":212,"nextEast":213,"nextSouth":237,"nextWest":236,"zombie":188,"deadZombie":164},"animations":{"14,13":{"type":"two-ways","settings":{"sprites":[144,145,146,147,148],"period":75,"subscribe":"game-started"}},"7,1":{"type":"two-ways","settings":{"sprites":[175,174,173,172],"period":100}}}},"logic":{"54":"Space","172":"Exit","173":"Exit","174":"Exit","175":"Exit","190":"Sphinx"},"space":54,"map":[[5,6,6,6,6,104,6,6,6,6,104,105,6,6,6,7],[29,30,30,30,30,128,30,175,30,30,128,129,30,30,30,31],[53,182,182,54,54,54,54,54,54,190,54,54,54,54,54,55],[102,54,182,54,54,54,54,54,54,54,54,54,8,9,54,75],[76,54,54,8,78,78,78,9,54,54,54,54,32,33,54,99],[100,54,54,32,25,25,25,77,78,78,78,78,79,53,54,55],[77,9,54,56,6,6,105,7,25,25,5,6,6,57,54,55],[5,57,54,80,30,30,129,31,25,25,29,30,30,81,54,55],[29,81,54,54,209,210,54,55,5,6,57,54,54,54,54,55],[53,54,54,54,233,234,54,75,29,30,81,54,8,78,78,79],[76,54,8,78,78,9,54,99,53,54,54,54,32,25,25,25],[100,54,55,25,25,53,54,55,53,54,8,78,79,25,25,25],[53,54,56,6,6,57,54,56,57,54,56,6,6,6,6,7],[53,54,80,30,30,81,54,80,81,54,80,30,30,30,144,31],[53,54,54,54,54,54,54,54,54,54,54,54,54,54,54,55],[77,78,78,78,127,78,78,78,78,78,127,78,78,78,78,79]]}')}},__webpack_module_cache__={};function __webpack_require__(g){var I=__webpack_module_cache__[g];if(void 0!==I)return I.exports;var C=__webpack_module_cache__[g]={exports:{}};return __webpack_modules__[g](C,C.exports,__webpack_require__),C.exports}__webpack_require__.d=(g,I)=>{for(var C in I)__webpack_require__.o(I,C)&&!__webpack_require__.o(g,C)&&Object.defineProperty(g,C,{enumerable:!0,get:I[C]})},__webpack_require__.o=(g,I)=>Object.prototype.hasOwnProperty.call(g,I),__webpack_require__.r=g=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__(43);sidila=__webpack_exports__})();